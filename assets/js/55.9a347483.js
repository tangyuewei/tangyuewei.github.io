(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{220:function(a,e,v){"use strict";v.r(e);var l=v(0),t=Object(l.a)({},(function(){var a=this.$createElement;this._self._c;return this._m(0)}),[function(){var a=this,e=a.$createElement,v=a._self._c||e;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"gc（垃圾回收）"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#gc（垃圾回收）"}},[a._v("#")]),a._v(" GC（垃圾回收）")]),a._v(" "),v("h2",{attrs:{id:"回收算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回收算法"}},[a._v("#")]),a._v(" 回收算法")]),a._v(" "),v("h3",{attrs:{id:"标记清除算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记清除算法"}},[a._v("#")]),a._v(" 标记清除算法")]),a._v(" "),v("blockquote",[v("p",[a._v("标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法,它将垃圾收集分为两个阶段:1.标记阶段 2.清除阶段")])]),a._v(" "),v("p",[a._v("效率低、回收的频率高")]),a._v(" "),v("h3",{attrs:{id:"复制算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#复制算法"}},[a._v("#")]),a._v(" 复制算法")]),a._v(" "),v("blockquote",[v("p",[a._v("它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收")])]),a._v(" "),v("p",[a._v("运行高效但可用的内存大小缩小了一半")]),a._v(" "),v("h3",{attrs:{id:"标记整理算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标记整理算法"}},[a._v("#")]),a._v(" 标记整理算法")]),a._v(" "),v("blockquote",[v("p",[a._v("标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边")])]),a._v(" "),v("p",[a._v("比标记-清除算法运行效率高")]),a._v(" "),v("h3",{attrs:{id:"分代收集算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分代收集算法"}},[a._v("#")]),a._v(" 分代收集算法")]),a._v(" "),v("blockquote",[v("p",[a._v("根据对象的存活周期将内存划分为:年轻代、老年代 和 永久代")])]),a._v(" "),v("ul",[v("li",[a._v("新生代（Young generation）\n"),v("ul",[v("li",[a._v("新生代中存在一个Eden区和两个Survivor区。新对象会首先分配在Eden中（如果新对象过大，会直接分配在老年代中）。在GC中，Eden中的对象会被移动到Survivor中，直至对象满足一定的年纪（定义为熬过GC的次数），会被移动到老年代")])])]),a._v(" "),v("li",[a._v("老年代（Old generation）\n"),v("ul",[v("li",[a._v("占用的空间要比新生代多,正由于其相对较大的空间，发生在老年代上的GC要比新生代要少得多。对象从老年代中消失的过程，可以称之为major GC（或者full GC）。")])])]),a._v(" "),v("li",[a._v("永久代（permanent generation）\n"),v("ul",[v("li",[a._v("几乎都是静态的并且很少被卸载和回收")])])])]),a._v(" "),v("h2",{attrs:{id:"垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[a._v("#")]),a._v(" 垃圾回收器")]),a._v(" "),v("blockquote",[v("p",[a._v("垃圾收集器就是内存回收的具体实现")])]),a._v(" "),v("ul",[v("li",[a._v("新生代回收器：Serial、ParNew、Parallel Scavenge")]),a._v(" "),v("li",[a._v("老年代回收器：Serial Old、Parallel Old、CMS")]),a._v(" "),v("li",[a._v("整堆回收器：G1")])]),a._v(" "),v("p",[a._v("###单线程垃圾回收器")]),a._v(" "),v("p",[a._v("单CPU的环境下，它的垃圾清除效率比较高。")]),a._v(" "),v("ul",[v("li",[a._v("Serial")])]),a._v(" "),v("blockquote",[v("p",[a._v("Serial 回收器是最基本的新生代垃圾回收器。采用的是->复制算法")])]),a._v(" "),v("ul",[v("li",[a._v("Serial Old")])]),a._v(" "),v("blockquote",[v("p",[a._v("Serial Old 回收器是Serial回收器的老生代版本。采用的是->标记整理算法")])]),a._v(" "),v("h3",{attrs:{id:"多线程垃圾回收器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#多线程垃圾回收器"}},[a._v("#")]),a._v(" 多线程垃圾回收器")]),a._v(" "),v("ul",[v("li",[a._v("ParNew")])]),a._v(" "),v("blockquote",[v("p",[a._v("属于 Serial 回收器的多线程版本，同样运行在新生代区域。在不同运行环境下，根据CPU核数，开启不同的线程数。采用的是->复制算法")])]),a._v(" "),v("ul",[v("li",[a._v("Parallel Scavenge")])]),a._v(" "),v("blockquote",[v("p",[a._v("Parallel Scavenge 回收器也是运行在新生代区域，属于多线程的回收器。ParNew 回收器是通过控制垃圾回收的线程数来进行参数调整，更关心的是程序运行的吞吐量。采用的是->复制算法")])]),a._v(" "),v("ul",[v("li",[a._v("Parallel Old")])]),a._v(" "),v("blockquote",[v("p",[a._v("Parallel Scavenge 回收器的老生代版本，属于多线程回收器。考虑了 吞吐量优先 这一指标，非常适合那些 注重吞吐量 和 CPU 资源敏感 的场合。采用的是->标记整理算法")])])])}],!1,null,null,null);e.default=t.exports}}]);