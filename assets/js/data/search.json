[

{
"title": "梅花易数起卦",
"url": "/posts/%E6%A2%85%E8%8A%B1%E6%98%93%E6%95%B0%E8%B5%B7%E5%8D%A6/",
"categories": "周易",
"tags": "周易, 占卜",
"date": "2025-06-15 15:01:00 +0800",







"snippet": "  讲一个梅花易数的起卦计算流程，再结合一个实际案例。🌟 一、梅花易数的起卦计算流程（用时间起卦法）我们用【年月日时】的数字来起卦。  准备：记录当前时间比如你现在想起一卦，记录当前时间如下（假设）：          年：2025年      月：6月      日：13日      时辰：13点（午后1点，对应地支“未”，未=8）        计算三个关键数字🔹 数字①（上卦）用：年 ...",
"content": "  讲一个梅花易数的起卦计算流程，再结合一个实际案例。🌟 一、梅花易数的起卦计算流程（用时间起卦法）我们用【年月日时】的数字来起卦。  准备：记录当前时间比如你现在想起一卦，记录当前时间如下（假设）：          年：2025年      月：6月      日：13日      时辰：13点（午后1点，对应地支“未”，未=8）        计算三个关键数字🔹 数字①（上卦）用：年 + 月 + 日= 2025 + 6 + 13 = 2044将2044除以8，取余数：2044 ÷ 8 = 255 余 4👉 上卦 = 第4卦（震卦 ☳）🔹 数字②（下卦）用：月 + 日 + 时辰地支数= 6 + 13 + 8 = 2727 ÷ 8 = 3 余 3👉 下卦 = 第3卦（离卦 ☲）🔹 数字③（动爻）用：年 + 月 + 日 + 时辰= 2025 + 6 + 13 + 8 = 20522052 ÷ 6 = 342 余 0👉 若余0，则动爻为第6爻（从下往上数第6条线动）  得到主卦 + 动爻上卦：震 ☳下卦：离 ☲→ 合成主卦为：火雷噬嗑（卦序21）第6爻动 → 变卦查《易经》得知：          主卦：火雷噬嗑（有咬合、突破、处理纠纷的意思）      第六爻动，爻辞是：“姤其角，吝，无咎。”      变卦：因第六爻动，将火雷噬嗑的第六爻（阳变阴）→ 得到变卦为：火雷噬嗑 变为 火雷大壮      🧩 二、实际案例解析🌟 问题：我现在考虑是否应该换工作，能不能顺利？我们用上面起出来的卦来解：  主卦：火雷噬嗑（象征有问题需要处理、咬合之象）  变卦：火雷大壮（大壮者，大有作为，有行动力）🔍 解卦分析：      卦意：噬嗑卦本义是“咬合”，象征当前你所处的职场有阻力或问题，需要处理。可能有职场冲突、发展受限、内部摩擦等。        动爻在第六爻（顶端）：代表问题已经到了“头”，或者你已经考虑很久了，有强烈行动欲望。但六爻动，也暗示过刚易折，要慎重。        变卦“大壮” ：意味着：若能妥善处理转换过程，有很大机会成功，但要注意方式方法，不可鲁莽，否则会带来压力。  结论：目前换工作的意图已经成熟，问题积累较多；如果你做好了准备，并采取有节制、有策略的行动，换工作是可行并可能成功的。但切忌冲动，要提前规划过渡期、经济、技能匹配。📝 总结步骤内容：记录时间年月日时辰三次取余数得上卦、下卦、动爻查主卦，通过八卦对应关系查得六十四卦解动爻查动爻爻辞，得变卦综合解卦解读主卦 + 动爻 + 变卦来一卦吧"
},

{
"title": "占卜占卜",
"url": "/posts/%E5%8D%A0%E5%8D%9C%E5%8D%A0%E5%8D%9C/",
"categories": "周易",
"tags": "周易, 占卜",
"date": "2025-06-14 10:20:00 +0800",







"snippet": "古人一般什么时候占卜？古代中国占卜的时间和场合多种多样，主要包括：  重大决策之前  比如出征打仗、迁徙定居、建造房屋、结婚、生子等，都会先占卜，看看吉凶。  古代帝王和将军常在战争或国家大事前请卜官占卜。  节令节气时  有些特定节日或节气，祭祀活动多，通常也会占卜，祈求风调雨顺、五谷丰登。  遇到疑难事情或不顺时  遭遇灾难、疾病、家庭矛盾时，民间也会求神问卜，寻找化解办法。  日常小事...",
"content": "古人一般什么时候占卜？古代中国占卜的时间和场合多种多样，主要包括：  重大决策之前  比如出征打仗、迁徙定居、建造房屋、结婚、生子等，都会先占卜，看看吉凶。  古代帝王和将军常在战争或国家大事前请卜官占卜。  节令节气时  有些特定节日或节气，祭祀活动多，通常也会占卜，祈求风调雨顺、五谷丰登。  遇到疑难事情或不顺时  遭遇灾难、疾病、家庭矛盾时，民间也会求神问卜，寻找化解办法。  日常小事  有些人会在平常日子里占卜，比如问问今天是否适合出门、做某件事。占卜方法民间广泛流传各种占卜方法，如：  六爻占卜  梅花易数  奇门遁甲  太乙神数  周易卦象  手相、面相来一卦吧"
},

{
"title": "ES查询时索引延迟或更新导致数据不一致",
"url": "/posts/ES%E6%9F%A5%E8%AF%A2%E6%97%B6%E7%B4%A2%E5%BC%95%E5%BB%B6%E8%BF%9F%E6%88%96%E6%9B%B4%E6%96%B0%E5%AF%BC%E8%87%B4%E6%95%B0%E6%8D%AE%E4%B8%8D%E4%B8%80%E8%87%B4/",
"categories": "常用框架",
"tags": "Elasticsearch, ES",
"date": "2024-05-10 08:34:00 +0800",







"snippet": "ES查询时索引延迟或更新导致数据不一致  当数据更新比较频繁时，我们短时间内使用相同的查询条件，得到的结果和记录数却不同。实际的业务要求查询的结果一致，以下是一些解决办法。问题可能是由于Elasticsearch的索引延迟或更新造成的。可以考虑以下步骤来解决：  检查索引刷新率：确保索引的刷新率设置合理。默认情况下，Elasticsearch每秒刷新一次，但根据需要可能需要调整。  使用se...",
"content": "ES查询时索引延迟或更新导致数据不一致  当数据更新比较频繁时，我们短时间内使用相同的查询条件，得到的结果和记录数却不同。实际的业务要求查询的结果一致，以下是一些解决办法。问题可能是由于Elasticsearch的索引延迟或更新造成的。可以考虑以下步骤来解决：  检查索引刷新率：确保索引的刷新率设置合理。默认情况下，Elasticsearch每秒刷新一次，但根据需要可能需要调整。  使用search_type=dfs_query_then_fetch：这确保查询使用全局词频，有助于提高结果的一致性。  使用时间点（PIT）：为了在查询之间保持结果的一致性，可以使用PIT来保持索引的快照。  检查索引健康：确保没有正在进行的索引操作或问题影响查询结果。本文说下2和3方案    使用 search_type=dfs_query_then_fetch    解释：search_type=dfs_query_then_fetch 是 Elasticsearch 的一种搜索模式，用于提高查询的准确性。在默认的 query_then_fetch 模式中，查询是按分片进行的，每个分片独立计算文档频率，然后将结果合并。但这可能会导致在频繁更新的情况下结果的不一致。dfs_query_then_fetch 模式首先在所有分片上计算全局词频（Document Frequency），然后执行查询和排序。这使得查询和排序基于全局的词频信息，从而提供更一致的查询结果。  使用方法：在查询请求中，你可以添加search_type=dfs_query_then_fetch参数。例如：GET /your_index/_search?search_type=dfs_query_then_fetch{  \"query\": {    \"bool\": {      \"must\": [        {          \"range\": {            \"time\": {              \"from\": \"2024-08-14 08:00:00\",              \"to\": \"2024-08-15 08:00:00\"            }          }        },        {          \"term\": {            \"fileds1\": \"xxx\"          }        },        {          \"term\": {            \"fileds2\": \"xx\"          }        }      ]    }  },  \"size\": 0,  \"aggs\": {    \"xsd_count\": {      \"terms\": {        \"field\": \"fileds1\",  //根据fileds1去重查询top5        \"size\": 5      }    },    \"xsd_total\": {      \"cardinality\": {        \"field\": \"fileds1\" //根据fileds1去重查询总数      }    }  }}使用时间点（PIT）解释：时间点（Point in Time, PIT）是一种在 Elasticsearch 中获取一致查询结果的机制。使用 PIT 可以在一个固定的索引快照上执行多个查询，确保查询结果在整个 PIT 生命周期内的一致性。PIT 的主要优点是它允许在一个固定的时间点快照上进行多次查询，这样即使索引在查询期间发生了变化，查询结果依然会保持一致。(数据快照)使用方法：      创建 PIT首先，你需要创建一个 PIT。发送一个 POST 请求到 _pit 接口以创建 PIT，例如：POST /_pit?keep_alive=1m这将返回一个 PIT ID，你可以在后续查询中使用它。    使用 PIT 执行查询：在查询请求中，添加 pit 参数和 PIT ID，例如：    GET /_search{  \"pit\":{\"id\":\"your_pit_id\",\"keep_alive\":\"1m\"},  \"query\":{ \"bool\":{     \"must\":[{         \"range\":{\"time\":{\"from\":\"2024-08-14 08:00:00\",\"to\":\"2024-08-15 08:00:59\"}}             }]         }  }}        关闭 PIT：查询完成后，你可以关闭 PIT 以释放资源，例如：DELETE /_pit?id=your_pit_id在PIT id错误会返回错误：{    \"error\": {        \"root_cause\": [            {                \"type\": \"illegal_argument_exception\",                \"reason\": \"java.io.EOFException\"            }        ],        \"type\": \"illegal_argument_exception\",        \"reason\": \"java.io.EOFException\",        \"caused_by\": {            \"type\": \"e_o_f_exception\",            \"reason\": null        }    },    \"status\": 400}PIT id超过时间过期后返回错误：{    \"error\": {    \"root_cause\": [        {                \"type\": \"search_context_missing_exception\",                \"reason\": \"No search context found for id [4635252]\"        }],    \"phase\": \"query\",    \"grouped\": true,    \"failed_shards\": [        {            \"shard\": 0,            \"index\": \"index-2022\",            \"node\": \"4sIEuxxxxxxxxxx\",            \"reason\": {                \"type\": \"search_context_missing_exception\",                \"reason\": \"No search context found for id [12345678]\"            }        }],    \"status\": 404    }}"
},

{
"title": "深入浅出 Netty",
"url": "/posts/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-Netty/",
"categories": "常用框架",
"tags": "Netty",
"date": "2024-04-22 16:34:00 +0800",







"snippet": "Netty：Java 高性能网络编程框架1. 引言Netty 是一个基于 Java 的高性能网络编程框架，广泛应用于高并发、大规模的分布式系统中。它提供了异步事件驱动的网络应用框架和工具，简化了网络编程的复杂性。本文将详细介绍 Netty 的核心概念、关键组件和基本使用方法，帮助开发者快速上手并掌握这门技术。2. Netty 的核心概念2.1 ChannelChannel 是 Netty 数...",
"content": "Netty：Java 高性能网络编程框架1. 引言Netty 是一个基于 Java 的高性能网络编程框架，广泛应用于高并发、大规模的分布式系统中。它提供了异步事件驱动的网络应用框架和工具，简化了网络编程的复杂性。本文将详细介绍 Netty 的核心概念、关键组件和基本使用方法，帮助开发者快速上手并掌握这门技术。2. Netty 的核心概念2.1 ChannelChannel 是 Netty 数据传输的基本抽象，它代表一个打开的连接（可以是 TCP 连接、UDP 连接或文件）。它提供了异步的读写操作，并且这些操作都返回 ChannelFuture 对象，用于在操作完成时通知应用程序。2.2 EventLoopEventLoop 是一个处理 I/O 操作的循环。每个 Channel 都会绑定一个 EventLoop，负责处理该 Channel 的所有事件。EventLoop 负责管理一个或多个 Channel 的 I/O 操作。2.3 ChannelHandlerChannelHandler 是处理 I/O 事件或拦截 I/O 操作的核心接口。它包括两类主要实现：  ChannelInboundHandler：处理入站 I/O 事件。  ChannelOutboundHandler：处理出站 I/O 操作。2.4 ChannelPipelineChannelPipeline 是一个 ChannelHandler 链，用于拦截和处理所有的 I/O 事件。每个 Channel 都有一个 ChannelPipeline，它负责管理和调用 ChannelHandler 链中的各个处理器。3. Netty 的关键组件3.1 Bootstrap 和 ServerBootstrap  Bootstrap：用于引导客户端。  ServerBootstrap：用于引导服务器。它们负责配置 Channel 和其他相关参数。3.2 NioEventLoopGroupNioEventLoopGroup 是 EventLoopGroup 的实现，用于处理 I/O 操作。它包含一组 NioEventLoop，每个 NioEventLoop 在独立的线程中运行。4. Netty 的基本使用方法以下是一个简单的 Netty 服务器示例代码：import io.netty.bootstrap.ServerBootstrap;import io.netty.channel.ChannelFuture;import io.netty.channel.ChannelInitializer;import io.netty.channel.ChannelOption;import io.netty.channel.EventLoopGroup;import io.netty.channel.nio.NioEventLoopGroup;import io.netty.channel.socket.SocketChannel;import io.netty.channel.socket.nio.NioServerSocketChannel;import io.netty.handler.codec.string.StringDecoder;import io.netty.handler.codec.string.StringEncoder;import io.netty.handler.logging.LogLevel;import io.netty.handler.logging.LoggingHandler;public class NettyServer {    private final int port;    public NettyServer(int port) {        this.port = port;    }    public void start() throws Exception {        EventLoopGroup bossGroup = new NioEventLoopGroup(1);        EventLoopGroup workerGroup = new NioEventLoopGroup();        try {            ServerBootstrap b = new ServerBootstrap();            b.group(bossGroup, workerGroup)             .channel(NioServerSocketChannel.class)             .option(ChannelOption.SO_BACKLOG, 100)             .handler(new LoggingHandler(LogLevel.INFO))             .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                 @Override                 public void initChannel(SocketChannel ch) {                     ch.pipeline().addLast(new StringDecoder());                     ch.pipeline().addLast(new StringEncoder());                     ch.pipeline().addLast(new SimpleChannelHandler());                 }             });            ChannelFuture f = b.bind(port).sync();            f.channel().closeFuture().sync();        } finally {            bossGroup.shutdownGracefully();            workerGroup.shutdownGracefully();        }    }    public static void main(String[] args) throws Exception {        new NettyServer(8080).start();    }}class SimpleChannelHandler extends io.netty.channel.ChannelInboundHandlerAdapter {    @Override    public void channelRead(io.netty.channel.ChannelHandlerContext ctx, Object msg) {        String message = (String) msg;        System.out.println(\"Received message: \" + message);        ctx.writeAndFlush(\"Echo: \" + message);    }    @Override    public void exceptionCaught(io.netty.channel.ChannelHandlerContext ctx, Throwable cause) {        cause.printStackTrace();        ctx.close();    }}5. 结论Netty 作为一个强大的异步事件驱动的网络框架，简化了 Java 网络编程的复杂性，提高了开发效率。通过理解其核心概念和关键组件，开发者可以构建高性能的网络应用程序。希望本文对您了解和使用 Netty 有所帮助。如果您有任何问题或建议，欢迎在评论区留言讨论。Happy Coding!"
},

{
"title": "Netty 学习与使用",
"url": "/posts/Netty%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/",
"categories": "常用框架",
"tags": "Netty",
"date": "2024-04-19 11:20:00 +0800",







"snippet": "概述  netty是一个高性能的socket框架。源码  https://github.com/netty/netty快速入门    &lt;build&gt;        &lt;plugins&gt;            &lt;!--【必用插件】用于设置项目jdk版本--&gt;            &lt;plugin&gt;                &lt;groupI...",
"content": "概述  netty是一个高性能的socket框架。源码  https://github.com/netty/netty快速入门    &lt;build&gt;        &lt;plugins&gt;            &lt;!--【必用插件】用于设置项目jdk版本--&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;                &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;                &lt;version&gt;3.8.1&lt;/version&gt;                &lt;configuration&gt;                    &lt;source&gt;8&lt;/source&gt;                    &lt;target&gt;8&lt;/target&gt;                    &lt;encoding&gt;UTF-8&lt;/encoding&gt;                &lt;/configuration&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;io.netty&lt;/groupId&gt;            &lt;artifactId&gt;netty-all&lt;/artifactId&gt;            &lt;version&gt;4.1.20.Final&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt;            &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt;            &lt;version&gt;3.2.0&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;客户端    public void connect(String ip, int port) {        NioEventLoopGroup workerGroup = new NioEventLoopGroup();        try {            Bootstrap bootstrap = new Bootstrap();            bootstrap.group(workerGroup)                    .channel(NioSocketChannel.class)                    .option(ChannelOption.SO_KEEPALIVE, true)                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel socketChannel) throws Exception {                            ChannelPipeline pipeline = socketChannel.pipeline();                            pipeline.addLast(\"intDecoder\", new ProtobufVarint32FrameDecoder());                            pipeline.addLast(\"intEncoder\", new ProtobufVarint32LengthFieldPrepender());                            pipeline.addLast(\"protobufDecoder\", new ProtobufDecoder(MessagePOJO.Message.getDefaultInstance()));                            pipeline.addLast(\"protobufEncoder\", new ProtobufEncoder());                            pipeline.addLast(new SimpleClientHandler());                        }                    });            ChannelFuture channelFuture = bootstrap.connect(ip, port).sync();            if (channelFuture.isSuccess()) System.out.println(\"连接成功！！！！\");            else System.out.println(\"连接失败\");            channelFuture.channel().closeFuture().sync();        } catch (Exception e) {            e.printStackTrace();        } finally {            workerGroup.shutdownGracefully();        }    }———-另一种———————–    public void connect(String ip, int port) {        EventLoopGroup group = new NioEventLoopGroup();// 开启工作线程组        try {            Bootstrap bootstrap = new Bootstrap(); //创建一个和服务端相对应的server            bootstrap.group(group) //设置线程组                    .channel(NioSocketChannel.class) //使用NioSocketChannel作为客户端的通道实现                    .handler(new ChannelInitializer&lt;SocketChannel&gt;() {//设置回调函数                        @Override                        protected void initChannel(SocketChannel ch) {                            ch.pipeline().addLast(new NettyClientHandler());                        }                    });            System.out.println(\"netty client start。。\");            ChannelFuture cf = bootstrap.connect(\"127.0.0.1\", 9000).sync();//启动客户端去连接服务器端            //对通道关闭进行监听            cf.channel().closeFuture().sync();        } finally {            group.shutdownGracefully();//关闭线程组        }    }服务端public void startServer() {        NioEventLoopGroup bossGroup = new NioEventLoopGroup();        NioEventLoopGroup workerGroup = new NioEventLoopGroup();        try {            ServerBootstrap serverBootstrap = new ServerBootstrap();            serverBootstrap.group(bossGroup, workerGroup)                    .option(ChannelOption.SO_BACKLOG, 128)                    .childOption(ChannelOption.SO_KEEPALIVE, true)                    .channel(NioServerSocketChannel.class)                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {                        @Override                        protected void initChannel(SocketChannel socketChannel) throws Exception {                            ChannelPipeline pipeline = socketChannel.pipeline();                            pipeline.addLast(\"intDecoder\", new ProtobufVarint32FrameDecoder());                            pipeline.addLast(\"intEncoder\", new ProtobufVarint32LengthFieldPrepender());                            pipeline.addLast(\"protobufDecoder\", new ProtobufDecoder(MessagePOJO.Message.getDefaultInstance()));                            pipeline.addLast(new SimpleServerHandler());                        }                    });            ChannelFuture channelFuture = serverBootstrap.bind(port).sync();            if (channelFuture.isSuccess()) System.out.println(\"服务器开启成功！！！！\");            else System.out.println(\"服务器开启失败\");            channelFuture.channel().closeFuture().sync();        } catch (Exception e) {            e.printStackTrace();        } finally {            workerGroup.shutdownGracefully();            bossGroup.shutdownGracefully();        }    }———-另一种———————–    public void startServer() {        EventLoopGroup bossGroup = new NioEventLoopGroup(1);//新建线程组,用于处理请求        EventLoopGroup workerGroup = new NioEventLoopGroup();//真正工作的线程组        try {            ServerBootstrap bootstrap = new ServerBootstrap();//创建一个server,相当于NIO的server            bootstrap.group(bossGroup, workerGroup) //采用链式编程,将两个线程组加入到server中                    .channel(NioServerSocketChannel.class) //设置一个信道,相当于NIO中的ServerSocketChannel                    .option(ChannelOption.SO_BACKLOG, 1024) //对服务端给予一些设置                    .childHandler(new ChannelInitializer&lt;SocketChannel&gt;() {//给予初始化,并加入回调函数                        @Override                        protected void initChannel(SocketChannel ch) throws Exception {                            ch.pipeline().addLast(new NettyServerHandler());                        }                    });            System.out.println(\"netty server start。。\");            ChannelFuture cf = bootstrap.bind(9000).sync();//绑定端口,sync方法是等待异步操作执行完毕            cf.channel().closeFuture().sync();//对通道关闭进行监听，closeFuture是异步操作，监听通道关闭                                        // 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成        } finally {            bossGroup.shutdownGracefully(); //关闭处理请求的线程组            workerGroup.shutdownGracefully();//关闭真正工作的线程组        }    }回调服务端回调public class NettyServerHandler extends ChannelInboundHandlerAdapter {    //当客户端连接服务器完成就会触发该方法    @Override    public void channelActive(ChannelHandlerContext ctx) throws Exception {        ByteBuf buf = Unpooled.copiedBuffer(\"HelloServer\".getBytes(CharsetUtil.UTF_8));        ctx.writeAndFlush(buf);    }    //当通道有读取事件时会触发，即客户端发送数据给服务端    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {        ByteBuf buf = (ByteBuf) msg;        System.out.println(\"收到客户端的消息:\" + buf.toString(CharsetUtil.UTF_8));        System.out.println(\"客户端的地址： \" + ctx.channel().remoteAddress());    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {        System.out.println(\"我收到了异常\");        cause.printStackTrace();        ctx.close();    }}客户端回调public class NettyClientHandler extends ChannelInboundHandlerAdapter {    /**     * 当客户端连接服务器完成就会触发该方法     *     * @param ctx 设置好的信道,相当于上下文     */    @Override    public void channelActive(ChannelHandlerContext ctx) {        ByteBuf buf = Unpooled.copiedBuffer(\"HelloServer\".getBytes(CharsetUtil.UTF_8));        ctx.writeAndFlush(buf);    }    //当通道有读取事件时会触发，即服务端发送数据给客户端    @Override    public void channelRead(ChannelHandlerContext ctx, Object msg) {        ByteBuf buf = (ByteBuf) msg;        System.out.println(\"收到服务端的消息:\" + buf.toString(CharsetUtil.UTF_8));        System.out.println(\"服务端的地址： \" + ctx.channel().remoteAddress());    }    @Override    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {        cause.printStackTrace();        ctx.close();    }}参考文档  Netty 4.x 用户指南  Netty 聊天室  netty-learning"
},

{
"title": "从vuepress迁移至jekyll",
"url": "/posts/%E4%BB%8Evuepress%E8%BF%81%E7%A7%BB%E8%87%B3jekyll/",
"categories": "博客那些事",
"tags": "博客迁移, vuepress, jekyll",
"date": "2023-12-29 14:00:00 +0800",







"snippet": "从vuepress迁移至jekyll  做过技术开发的都知道，迁移是一件很痛苦的事情，亲身体验过才知道，但是痛苦的过程是有收获的。 起初使用vuepress来写博客，感觉还挺高大上，有目录层级机构。但是后来发现，用他来些博客并不好，写文档比较合适，而且不支持一些功能，比如说评论，而且它的主题也不好看，所以就决定迁移到jekyll。附两张图纪念：  首页  详情页元旦快乐！",
"content": "从vuepress迁移至jekyll  做过技术开发的都知道，迁移是一件很痛苦的事情，亲身体验过才知道，但是痛苦的过程是有收获的。 起初使用vuepress来写博客，感觉还挺高大上，有目录层级机构。但是后来发现，用他来些博客并不好，写文档比较合适，而且不支持一些功能，比如说评论，而且它的主题也不好看，所以就决定迁移到jekyll。附两张图纪念：  首页  详情页元旦快乐！"
},

{
"title": "Spring Security oAuth2应用",
"url": "/posts/Spring-Security-oAuth2%E5%BA%94%E7%94%A8/",
"categories": "常用框架",
"tags": "oAuth2, Spring Security",
"date": "2023-03-12 16:15:00 +0800",







"snippet": "数据表CREATE TABLE `clientdetails` (  `appId` varchar(128) NOT NULL,  `resourceIds` varchar(256) DEFAULT NULL,  `appSecret` varchar(256) DEFAULT NULL,  `scope` varchar(256) DEFAULT NULL,  `grantTypes`...",
"content": "数据表CREATE TABLE `clientdetails` (  `appId` varchar(128) NOT NULL,  `resourceIds` varchar(256) DEFAULT NULL,  `appSecret` varchar(256) DEFAULT NULL,  `scope` varchar(256) DEFAULT NULL,  `grantTypes` varchar(256) DEFAULT NULL,  `redirectUrl` varchar(256) DEFAULT NULL,  `authorities` varchar(256) DEFAULT NULL,  `access_token_validity` int(11) DEFAULT NULL,  `refresh_token_validity` int(11) DEFAULT NULL,  `additionalInformation` varchar(4096) DEFAULT NULL,  `autoApproveScopes` varchar(256) DEFAULT NULL,  PRIMARY KEY (`appId`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_access_token` (  `token_id` varchar(256) DEFAULT NULL,  `token` blob,  `authentication_id` varchar(128) NOT NULL,  `user_name` varchar(256) DEFAULT NULL,  `client_id` varchar(256) DEFAULT NULL,  `authentication` blob,  `refresh_token` varchar(256) DEFAULT NULL,  PRIMARY KEY (`authentication_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_approvals` (  `userId` varchar(256) DEFAULT NULL,  `clientId` varchar(256) DEFAULT NULL,  `scope` varchar(256) DEFAULT NULL,  `status` varchar(10) DEFAULT NULL,  `expiresAt` timestamp NULL DEFAULT NULL,  `lastModifiedAt` timestamp NULL DEFAULT NULL) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_client_details` (  `client_id` varchar(128) NOT NULL,  `resource_ids` varchar(256) DEFAULT NULL,  `client_secret` varchar(256) DEFAULT NULL,  `scope` varchar(256) DEFAULT NULL,  `authorized_grant_types` varchar(256) DEFAULT NULL,  `web_server_redirect_uri` varchar(256) DEFAULT NULL,  `authorities` varchar(256) DEFAULT NULL,  `access_token_validity` int(11) DEFAULT NULL,  `refresh_token_validity` int(11) DEFAULT NULL,  `additional_information` varchar(4096) DEFAULT NULL,  `autoapprove` varchar(256) DEFAULT NULL,  PRIMARY KEY (`client_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_client_token` (  `token_id` varchar(256) DEFAULT NULL,  `token` blob,  `authentication_id` varchar(128) NOT NULL,  `user_name` varchar(256) DEFAULT NULL,  `client_id` varchar(256) DEFAULT NULL,  PRIMARY KEY (`authentication_id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_code` (  `code` varchar(256) DEFAULT NULL,  `authentication` blob) ENGINE=InnoDB DEFAULT CHARSET=utf8;CREATE TABLE `oauth_refresh_token` (  `token_id` varchar(256) DEFAULT NULL,  `token` blob,  `authentication` blob) ENGINE=InnoDB DEFAULT CHARSET=utf8;引入依赖pom.xml&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;    &lt;parent&gt;        &lt;groupId&gt;com.qjdmy&lt;/groupId&gt;        &lt;artifactId&gt;qjdmy-parent&lt;/artifactId&gt;        &lt;version&gt;1.0.0.RELEASE&lt;/version&gt;    &lt;/parent&gt;    &lt;artifactId&gt;qjdmy-oauth&lt;/artifactId&gt;    &lt;version&gt;1.0.1-SNAPSHOT&lt;/version&gt;    &lt;packaging&gt;jar&lt;/packaging&gt;    &lt;url&gt;http://www.qjdmy.com&lt;/url&gt;    &lt;inceptionYear&gt;2020-Now&lt;/inceptionYear&gt;    &lt;description&gt;认证与授权&lt;/description&gt;    &lt;scm&gt;        &lt;connection&gt;scm:git:http://gitlab.tangyuewei.com/qjdmy/qjdmy-oauth.git&lt;/connection&gt;        &lt;developerConnection&gt;scm:git:http://gitlab.tangyuewei.com/qjdmy/qjdmy-oauth.git&lt;/developerConnection&gt;        &lt;url&gt;http://gitlab.tangyuewei.com/qjdmy/qjdmy-oauth&lt;/url&gt;        &lt;tag&gt;HEAD&lt;/tag&gt;    &lt;/scm&gt;    &lt;developers&gt;        &lt;developer&gt;            &lt;id&gt;tangyuewei&lt;/id&gt;            &lt;name&gt;Webster Tang&lt;/name&gt;            &lt;email&gt;472680811@qq.com&lt;/email&gt;        &lt;/developer&gt;    &lt;/developers&gt;    &lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;            &lt;scope&gt;test&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;            &lt;artifactId&gt;spring-cloud-starter-oauth2&lt;/artifactId&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;javax.servlet&lt;/groupId&gt;            &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;            &lt;artifactId&gt;lombok&lt;/artifactId&gt;            &lt;scope&gt;provided&lt;/scope&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;            &lt;artifactId&gt;qfdmy-repository-core&lt;/artifactId&gt;            &lt;version&gt;${project.version}&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;${project.groupId}&lt;/groupId&gt;            &lt;artifactId&gt;qfdmy-commons&lt;/artifactId&gt;            &lt;version&gt;${project.version}&lt;/version&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;    &lt;profiles&gt;        &lt;profile&gt;            &lt;id&gt;microservice&lt;/id&gt;            &lt;build&gt;                &lt;plugins&gt;                    &lt;plugin&gt;                        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                        &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;                        &lt;configuration&gt;                            &lt;mainClass&gt;com.qjdmy.oauth.AuthApplication&lt;/mainClass&gt;                        &lt;/configuration&gt;                    &lt;/plugin&gt;                &lt;/plugins&gt;            &lt;/build&gt;        &lt;/profile&gt;    &lt;/profiles&gt;&lt;/project&gt;application.ymlserver:  port: 9090spring:  application:    name: qjdmy-oauth  main:    allow-bean-definition-overriding: true  datasource:    type: com.zaxxer.hikari.HikariDataSource    driver-class-name: com.mysql.cj.jdbc.Driver    jdbc-url: jdbc:mysql://mysql.tangyuewei.com:3306/qfdmy?serverTimezone=Asia/Shanghai&amp;useLegacyDatetimeCode=false&amp;nullNamePatternMatchesAll=true&amp;zeroDateTimeBehavior=CONVERT_TO_NULL&amp;tinyInt1isBit=false&amp;autoReconnect=true&amp;useSSL=false&amp;pinGlobalTxToPhysicalConnection=true    username: root    password: 123456    hikari:      minimum-idle: 5      idle-timeout: 600000      maximum-pool-size: 10      auto-commit: true      pool-name: MyHikariCP      max-lifetime: 1800000      connection-timeout: 30000      connection-test-query: SELECT 1security:  oauth2:    client:      client-id: dashboard      client-secret: dashboard      access-token-uri: http://localhost:${server.port}/oauth/token      user-authorization-uri: http://localhost:${server.port}/oauth/authorize    resource:      token-info-uri: http://localhost:${server.port}/oauth/check_token    authorization:      check-token-access: http://localhost:${server.port}/oauth/check_tokenApplicationpackage com.qjdmy.oauth;import org.mybatis.spring.annotation.MapperScan;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * 认证与授权 * * @author Webster * @since v1.0.0 */@SpringBootApplication(scanBasePackages = \"com.qjdmy\")@MapperScan(basePackages = \"com.qjdmy.repository.core.mapper\")public class AuthApplication {    public static void main(String[] args) {        SpringApplication.run(AuthApplication.class, args);    }}自定义认证授权实现package com.qjdmy.oauth.service.impl;import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;import com.qjdmy.repository.core.domain.CoreAdmin;import com.qjdmy.repository.core.domain.CoreUser;import com.qjdmy.repository.core.mapper.CoreAdminMapper;import com.qjdmy.repository.core.mapper.CoreUserMapper;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.authority.SimpleGrantedAuthority;import org.springframework.security.core.userdetails.User;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.core.userdetails.UsernameNotFoundException;import javax.annotation.Resource;import java.util.ArrayList;import java.util.List;/** * 自定义认证与授权 * @author Webster * @since v1.0.0 */public class UserDetailsServiceImpl implements UserDetailsService {    @Resource    private CoreAdminMapper coreAdminMapper;    @Resource    private CoreUserMapper coreUserMapper;    @Override    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {        // 管理后台        LambdaQueryWrapper&lt;CoreAdmin&gt; adminWrapper = new LambdaQueryWrapper&lt;&gt;();        adminWrapper.eq(CoreAdmin::getUsername, username);        CoreAdmin coreAdmin = coreAdminMapper.selectOne(adminWrapper);        if (null != coreAdmin) {            // 授权，管理员权限为 ADMIN            List&lt;GrantedAuthority&gt; grantedAuthorities = new ArrayList&lt;&gt;();            grantedAuthorities.add(new SimpleGrantedAuthority(\"ADMIN\"));            // 由框架完成认证工作            return new User(coreAdmin.getUsername(), coreAdmin.getPassword(), grantedAuthorities);        }        // 门户网站        LambdaQueryWrapper&lt;CoreUser&gt; userWrapper = new LambdaQueryWrapper&lt;&gt;();        userWrapper.eq(CoreUser::getUsername, username);        CoreUser coreUser = coreUserMapper.selectOne(userWrapper);        if (null != coreUser) {            List&lt;GrantedAuthority&gt; grantedAuthorities = new ArrayList&lt;&gt;();            grantedAuthorities.add(new SimpleGrantedAuthority(\"USERS\"));            return new User(coreUser.getUsername(), coreUser.getPassword(), grantedAuthorities);        }        return null;    }}认证服务器配置  WebSecurityConfiguration.javapackage com.qjdmy.oauth.configuration;import com.qjdmy.oauth.service.impl.UserDetailsServiceImpl;import org.springframework.context.annotation.Bean;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.WebSecurity;import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;import org.springframework.security.core.userdetails.UserDetailsService;/** * 认证服务器配置 * * @author Webster * @since v1.0.0 */@EnableWebSecurity@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\t@Bean\t@Override\tpublic UserDetailsService userDetailsServiceBean() {\t\treturn new UserDetailsServiceImpl();\t}\t@Bean\t@Override\tpublic AuthenticationManager authenticationManagerBean() throws Exception {\t\treturn super.authenticationManagerBean();\t}\t@Override\tprotected void configure(AuthenticationManagerBuilder auth) throws Exception {\t\tauth.userDetailsService(userDetailsServiceBean());\t}\t@Override\tpublic void configure(WebSecurity web) {\t\t// 忽略的访问路径\t\tweb.ignoring()\t\t\t\t.antMatchers(\"/login/**\")\t\t\t\t.antMatchers(\"/registry/user\")\t\t\t\t.antMatchers(\"/logout/**\");\t}}  AuthorizationServerConfiguration.javapackage com.qjdmy.oauth.configuration;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.boot.jdbc.DataSourceBuilder;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Lazy;import org.springframework.context.annotation.Primary;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.security.oauth2.config.annotation.configurers.ClientDetailsServiceConfigurer;import org.springframework.security.oauth2.config.annotation.web.configuration.AuthorizationServerConfigurerAdapter;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableAuthorizationServer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerEndpointsConfigurer;import org.springframework.security.oauth2.config.annotation.web.configurers.AuthorizationServerSecurityConfigurer;import org.springframework.security.oauth2.provider.ClientDetailsService;import org.springframework.security.oauth2.provider.client.JdbcClientDetailsService;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.security.oauth2.provider.token.store.JdbcTokenStore;import javax.annotation.Resource;import javax.sql.DataSource;/** * 认证服务器配置 * * @author Webster * @since v1.0.0 */@Configuration@EnableAuthorizationServerpublic class AuthorizationServerConfiguration extends AuthorizationServerConfigurerAdapter {\t/**\t * 注入用于支持 password 模式\t */\t@Resource\tprivate AuthenticationManager authenticationManager;\t/**\t * 默认的加密方式\t * @return {@link BCryptPasswordEncoder}\t */\t@Bean\tpublic BCryptPasswordEncoder passwordEncoder() {\t\treturn new BCryptPasswordEncoder();\t}\t/**\t * Refresh Token 时需要自定义实现，否则抛异常 &lt;br&gt;\t * Lazy 注解是为了防止循环注入（is there an unresolvable circular reference?）\t */\t@Lazy\t@Resource(name = \"userDetailsServiceBean\")\tprivate UserDetailsService userDetailsService;\t@Bean\t@Primary\t@ConfigurationProperties(prefix = \"spring.datasource\")\tpublic DataSource dataSource() {\t\t// 配置数据源（注意，我使用的是 HikariCP 连接池），以上注解是指定数据源，否则会有冲突\t\treturn DataSourceBuilder.create().build();\t}\t@Bean\tpublic TokenStore tokenStore() {\t\t// 基于 JDBC 实现，令牌保存到数据库\t\treturn new JdbcTokenStore(dataSource());\t}\t@Bean\tpublic ClientDetailsService jdbcClientDetailsService() {\t\t// 基于 JDBC 实现，需要事先在数据库配置客户端信息\t\treturn new JdbcClientDetailsService(dataSource());\t}\t@Override\tpublic void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception {\t\tendpoints\t\t\t\t// 用于支持密码模式\t\t\t\t.authenticationManager(authenticationManager).tokenStore(tokenStore());\t\t// Refresh Token 时需要自定义实现，否则抛异常\t\t// Handling error: IllegalStateException, UserDetailsService is required.\t\tendpoints.userDetailsService(userDetailsService);\t}\t@Override\tpublic void configure(AuthorizationServerSecurityConfigurer security) throws Exception {\t\tsecurity\t\t\t\t// 允许客户端访问 /oauth/check_token 检查 token\t\t\t\t.checkTokenAccess(\"isAuthenticated()\").allowFormAuthenticationForClients();\t}\t/**\t * 配置客户端\t * @param clients {@link ClientDetailsServiceConfigurer}\t * @throws Exception 全局异常\t */\t@Override\tpublic void configure(ClientDetailsServiceConfigurer clients) throws Exception {\t\t// 客户端配置\t\tclients.withClientDetails(jdbcClientDetailsService());\t}}实现登录功能登录业务接口package com.qjdmy.oauth.service;import java.util.Map;/** * 登录 * @author Webster * @since v1.0.0 */public interface ILoginService {    /**     * 登录成功后仅返回 Token     * @param username {@code String} 账号     * @param password {@code String} 密码     * @return {@code Map&lt;String, String&gt;} key: token     */    Map&lt;String, String&gt; getToken(String username, String password);    /**     * 刷新 Token     * @param accessToken {@code String} 使用旧 Token 换新 Token     * @return {@code Map&lt;String, String&gt;} 新 Token，key: token     */    Map&lt;String, String&gt; refresh(String accessToken);}登录业务实现package com.qjdmy.oauth.service.impl;import cn.hutool.core.util.StrUtil;import cn.hutool.http.HttpUtil;import cn.hutool.json.JSONObject;import cn.hutool.json.JSONUtil;import com.qjdmy.commons.exceptions.BusinessException;import com.qjdmy.commons.response.ResponseCode;import com.qjdmy.oauth.service.ILoginService;import org.springframework.beans.factory.annotation.Value;import org.springframework.security.core.userdetails.UserDetails;import org.springframework.security.core.userdetails.UserDetailsService;import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;import org.springframework.stereotype.Service;import javax.annotation.Resource;import java.util.HashMap;import java.util.Map;/** * 登录 * @author Webster * @since v1.0.0 */@Servicepublic class LoginServiceImpl implements ILoginService {    /**     * TODO 用于临时存放所有 Refresh Token，实际情况应该放在 Redis 中     */    private static Map&lt;String, String&gt; refreshTokenMaps = new HashMap&lt;&gt;();    @Value(\"${security.oauth2.client.access-token-uri}\")    private String accessTokenUri;    @Value(\"${security.oauth2.client.client-id}\")    private String clientId;    @Value(\"${security.oauth2.client.client-secret}\")    private String clientSecret;    @Resource    private BCryptPasswordEncoder passwordEncoder;    @Resource(name = \"userDetailsServiceBean\")    private UserDetailsService userDetailsService;    @Override    public Map&lt;String, String&gt; getToken(String username, String password) {        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();        // 验证密码是否正确        UserDetails userDetails = userDetailsService.loadUserByUsername(username);        if (userDetails == null || !passwordEncoder.matches(password, userDetails.getPassword())) {            throw new BusinessException(ResponseCode.USER_LOGIN_ERROR);        }        // 通过 HTTP 客户端请求登录接口        Map&lt;String, Object&gt; authParam = getAuthParam();        authParam.put(\"username\", username);        authParam.put(\"password\", password);        authParam.put(\"grant_type\", \"password\");        // 获取 access_token        String strJson = HttpUtil.post(accessTokenUri, authParam);        JSONObject jsonObject = JSONUtil.parseObj(strJson);        String token = String.valueOf(jsonObject.get(\"access_token\"));        String refresh = String.valueOf(jsonObject.get(\"refresh_token\"));        if (StrUtil.isNotBlank(token) &amp;&amp; StrUtil.isNotBlank(refresh)) {            // 将 refresh_token 保存在服务端            refreshTokenMaps.put(token, refresh);            // 将 access_token 返回给客户端            result.put(\"token\", token);            return result;        }        return null;    }    @Override    public Map&lt;String, String&gt; refresh(String accessToken) {        Map&lt;String, String&gt; result = new HashMap&lt;&gt;();        // Access Token 不存在直接返回 null        String refreshToken = refreshTokenMaps.get(accessToken);        if (StrUtil.isBlank(refreshToken)) {            throw new BusinessException(ResponseCode.USER_NOT_LOGGED_IN);        }        // 通过 HTTP 客户端请求登录接口        Map&lt;String, Object&gt; authParam = getAuthParam();        authParam.put(\"grant_type\", \"refresh_token\");        authParam.put(\"refresh_token\", refreshToken);        // 获取 access_token        String strJson = HttpUtil.post(accessTokenUri, authParam);        JSONObject jsonObject = JSONUtil.parseObj(strJson);        String token = String.valueOf(jsonObject.get(\"access_token\"));        String refresh = String.valueOf(jsonObject.get(\"refresh_token\"));        if (StrUtil.isNotBlank(token) &amp;&amp; StrUtil.isNotBlank(refresh)) {            // 删除旧 Token            refreshTokenMaps.remove(accessToken);            // 将 refresh_token 保存在服务端            refreshTokenMaps.put(token, refresh);            // 将 access_token 返回给客户端            result.put(\"token\", token);            return result;        }        return null;    }    // 私有方法 ------------------------------------------- Begin    private Map&lt;String, Object&gt; getAuthParam() {        Map&lt;String, Object&gt; param = new HashMap&lt;&gt;();        param.put(\"client_id\", clientId);        param.put(\"client_secret\", clientSecret);        return param;    }}封装工具类package com.qjdmy.commons.web;import cn.hutool.core.util.StrUtil;import com.qjdmy.commons.exceptions.BusinessException;import com.qjdmy.commons.response.ResponseCode;/** * 请求头处理 * @author Webster * @since v1.0.0 */public class Header {    private static final String AUTHORIZATION_BEARER_TOKEN = \"Basic \";    /**     * 获取 Token     * @param header {@code String} request.getHeader(\"Authorization\")     * @return {@code String} token     */    public static String getAuthorization(String header) {        if (StrUtil.isBlank(header) || header.startsWith(AUTHORIZATION_BEARER_TOKEN)) {            throw new BusinessException(ResponseCode.USER_NOT_LOGGED_IN);        }        return header.substring(AUTHORIZATION_BEARER_TOKEN.length() + 1);    }}封装请求参数package com.qjdmy.oauth.controller.param;import lombok.Data;import lombok.EqualsAndHashCode;import lombok.experimental.Accessors;import java.io.Serializable;/** * 登录参数 * @author Webster * @since v1.0.0 */@Data@EqualsAndHashCode(callSuper = false)@Accessors(chain = true)public class LoginParam implements Serializable {    private static final long serialVersionUID = 6227804428105653962L;    /**     * 账号     */    private String username;    /**     * 密码     */    private String password;}请求处理代码package com.qjdmy.oauth.controller;import com.qfdmy.commons.response.ResponseResult;import com.qfdmy.commons.web.Header;import com.qfdmy.oauth.controller.param.LoginParam;import com.qfdmy.oauth.service.ILoginService;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestBody;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;/** * 登录 * @author Webster * @since v1.0.0 */@RestController@RequestMapping(value = \"login\")public class LoginController {    @Resource    private HttpServletRequest request;    @Resource    private ILoginService loginService;    /**     * 管理员登录     * @param loginParam {@code JSON} {@link LoginParam}     * @return {@link ResponseResult}     */    @PostMapping(\"admin\")    public ResponseResult admin(@RequestBody LoginParam loginParam) {        return ResponseResult.success(loginService.getToken(loginParam.getUsername(), loginParam.getPassword()));    }    /**     * 用户登录，登录只是拿 Token     * @param loginParam {@code JSON} {@link LoginParam}     * @return {@link ResponseResult}     */    @PostMapping(\"user\")    public ResponseResult users(@RequestBody LoginParam loginParam) {        return ResponseResult.success(loginService.getToken(loginParam.getUsername(), loginParam.getPassword()));    }    /**     * 刷新令牌     * @return {@link ResponseResult}     */    @PostMapping(\"refresh\")    public ResponseResult refresh() {        String token = Header.getAuthorization(request.getHeader(\"Authorization\"));        return ResponseResult.success(loginService.refresh(token));    }}实现注销功能package com.qjdmy.oauth.controller;import com.qjdmy.commons.response.ResponseCode;import com.qjdmy.commons.response.ResponseResult;import com.qjdmy.commons.web.Header;import org.springframework.security.oauth2.common.OAuth2AccessToken;import org.springframework.security.oauth2.provider.token.TokenStore;import org.springframework.web.bind.annotation.PostMapping;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import javax.annotation.Resource;import javax.servlet.http.HttpServletRequest;/** * 注销 * * @author Webster * @since v1.0.0 */@RestController@RequestMapping(value = \"logout\")public class LogoutController {    @Resource    public TokenStore tokenStore;    @Resource    public HttpServletRequest request;    /**     * 注销管理员     *     * @return {@link ResponseResult}     */    @PostMapping(\"admin\")    public ResponseResult admin() {        return logout();    }    /**     * 注销用户     *     * @return {@link ResponseResult}     */    @PostMapping(\"user\")    public ResponseResult users() {        return logout();    }    // 私有方法 ------------------------------------------- Begin    private ResponseResult logout() {        String token = Header.getAuthorization(request.getHeader(\"Authorization\"));        // 删除 token 以注销        OAuth2AccessToken oAuth2AccessToken = tokenStore.readAccessToken(token);        if (null != oAuth2AccessToken) {            tokenStore.removeAccessToken(oAuth2AccessToken);            return ResponseResult.success();        }        return ResponseResult.failure(ResponseCode.INTERFACE_ADDRESS_INVALID);    }}资源服务器配置package com.qjdmy.all.configuration;import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;import org.springframework.security.config.annotation.web.builders.HttpSecurity;import org.springframework.security.config.annotation.web.configurers.ExpressionUrlAuthorizationConfigurer;import org.springframework.security.config.http.SessionCreationPolicy;import org.springframework.security.oauth2.config.annotation.web.configuration.EnableResourceServer;import org.springframework.security.oauth2.config.annotation.web.configuration.ResourceServerConfigurerAdapter;/** * 资源服务器配置 * * @author Webster * @since v1.0.0 */@EnableResourceServer@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true, jsr250Enabled = true)public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter {    /**     * 管理员角色     */    private static final String ADMIN = \"ADMIN\";    /**     * 用户角色     */    private static final String USERS = \"USERS\";    @Override    public void configure(HttpSecurity http) throws Exception {        // 允许访问全部资源//\t\thttp.exceptionHandling().and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)//\t\t\t\t.and().authorizeRequests().antMatchers(\"/**\").permitAll();        // 管理员授权请求路径        String[] adminPaths = new String[]{                \"/core/**\", \"/qiniu/**\"        };        ExpressionUrlAuthorizationConfigurer&lt;HttpSecurity&gt;.ExpressionInterceptUrlRegistry                expressionInterceptUrlRegistry = http.exceptionHandling()                .and().sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS)                .and().authorizeRequests();        for (String adminPath : adminPaths) {            expressionInterceptUrlRegistry.antMatchers(adminPath).hasAnyAuthority(ADMIN);        }    }}"
},

{
"title": "Spring Security oAuth2简介",
"url": "/posts/Spring-Security-oAuth2%E7%AE%80%E4%BB%8B/",
"categories": "常用框架",
"tags": "oAuth2, Spring Security",
"date": "2023-03-07 19:15:00 +0800",







"snippet": "什么是 oAuthoAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 oAuth的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此oAuth是安全的。什么是 Spring SecuritySpring Security是一个安全框架，前身是Acegi Security，能...",
"content": "什么是 oAuthoAuth协议为用户资源的授权提供了一个安全的、开放而又简易的标准。与以往的授权方式不同之处是 oAuth的授权不会使第三方触及到用户的帐号信息（如用户名与密码），即第三方无需使用用户的用户名与密码就可以申请获得该用户资源的授权，因此oAuth是安全的。什么是 Spring SecuritySpring Security是一个安全框架，前身是Acegi Security，能够为Spring企业应用系统提供声明式的安全访问控制。Spring Security基于Servlet 过滤器、IoC 和 AOP，为 Web 请求和方法调用提供身份确认和授权处理，避免了代码耦合，减少了大量重复代码工作。为什么需要 oAuth2应用场景我们假设你有一个“云笔记”产品，并提供了“云笔记服务”和“云相册服务”，此时用户需要在不同的设备（PC、Android、iPhone、TV、Watch）上去访问这些“资源”（笔记，图片）那么用户如何才能访问属于自己的那部分资源呢？此时传统的做法就是提供自己的账号和密码给我们的“云笔记”，登录成功后就可以获取资源了。但这样的做法会有以下几个问题：“云笔记服务”和“云相册服务”会分别部署，难道我们要分别登录吗？如果有第三方应用程序想要接入我们的“云笔记”，难道需要用户提供账号和密码给第三方应用程序，让他记录后再访问我们的资源吗？用户如何限制第三方应用程序在我们“云笔记”的授权范围和使用期限？难道把所有资料都永久暴露给它吗？如果用户修改了密码收回了权限，那么所有第三方应用程序会全部失效。只要有一个接入的第三方应用程序遭到破解，那么用户的密码就会泄露，后果不堪设想。为了解决如上问题，oAuth应用而生。名词解释  第三方应用程序（Third-party application）： 又称之为客户端（client），比如上节中提到的设备（PC、Android、iPhone、TV、Watch），我们会在这些设备中安装我们自己研发的 APP。又比如我们的产品想要使用 QQ、微信等第三方登录。对我们的产品来说，QQ、微信登录是第三方登录系统。我们又需要第三方登录系统的资源（头像、昵称等）。对于 QQ、微信等系统我们又是第三方应用程序。  HTTP 服务提供商（HTTP service）： 我们的云笔记产品以及 QQ、微信等都可以称之为“服务提供商”。  资源所有者（Resource Owner）： 又称之为用户（user）。用户代理（User Agent）： 比如浏览器，代替用户去访问这些资源。  认证服务器（Authorization server）： 即服务提供商专门用来处理认证的服务器，简单点说就是登录功能（验证用户的账号密码是否正确以及分配相应的权限）  资源服务器（Resource server）： 即服务提供商存放用户生成的资源的服务器。它与认证服务器，可以是同一台服务器，也可以是不同的服务器。简单点说就是资源的访问入口，比如上节中提到的“云笔记服务”和“云相册服务”都可以称之为资源服务器。交互过程oAuth 在 “客户端” 与 “服务提供商” 之间，设置了一个授权层（authorization layer）。”客户端” 不能直接登录 “服务提供商”，只能登录授权层，以此将用户与客户端区分开来。”客户端” 登录授权层所用的令牌（token），与用户的密码不同。用户可以在登录的时候，指定授权层令牌的权限范围和有效期。”客户端” 登录授权层以后，”服务提供商” 根据令牌的权限范围和有效期，向 “客户端” 开放用户储存的资料。开放平台交互模型交互模型涉及三方：  资源拥有者：用户  客户端：APP  服务提供方：包含两个角色1.  认证服务器2.  资源服务器认证服务器认证服务器负责对用户进行认证，并授权给客户端权限。认证很容易实现（验证账号密码即可），问题在于如何授权。比如我们使用第三方登录 “有道云笔记”，你可以看到如使用 QQ 登录的授权页面上有 “有道云笔记将获得以下权限” 的字样以及权限信息认证服务器需要知道请求授权的客户端的身份以及该客户端请求的权限。我们可以为每一个客户端预先分配一个 id，并给每个 id 对应一个名称以及权限信息。这些信息可以写在认证服务器上的配置文件里。然后，客户端每次打开授权页面的时候，把属于自己的 id 传过来，如：http://www.tangyuewei.com/login?client_id=yourClientId随着时间的推移和业务的增长，会发现，修改配置的工作消耗了太多的人力。有没有办法把这个过程自动化起来，把人工从这些繁琐的操作中解放出来？当开始考虑这一步，开放平台的成型也就是水到渠成的事情了。oAuth2 开放平台开放平台是由 oAuth2.0 协议衍生出来的一个产品。它的作用是让客户端自己去这上面进行注册、申请，通过之后系统自动分配client_id，并完成配置的自动更新（通常是写进数据库）。客户端要完成申请，通常需要填写客户端程序的类型（Web、App 等）、企业介绍、执照、想要获取的权限等等信息。这些信息在得到服务提供方的人工审核通过后，开发平台就会自动分配一个client_id给客户端了。到这里，已经实现了登录认证、授权页的信息展示。那么接下来，当用户成功进行授权之后，认证服务器需要把产生的access_token发送给客户端，方案如下：  让客户端在开放平台申请的时候，填写一个 URL，例如：http://www.tangyuewei.com  每次当有用户授权成功之后，认证服务器将页面重定向到这个URL（回调），并带上access_token，例如：http://www.tangyuewei.com?access_token=123456789  客户端接收到了这个access_token，而且认证服务器的授权动作已经完成，刚好可以把程序的控制权转交回客户端，由客户端决定接下来向用户展示什么内容。令牌的访问与刷新Access TokenAccess Token 是客户端访问资源服务器的令牌。拥有这个令牌代表着得到用户的授权。然而，这个授权应该是临时的，有一定有效期。这是因为，Access Token 在使用的过程中可能会泄露。给 Access Token 限定一个 较短的有效期 可以降低因 Access Token 泄露而带来的风险。然而引入了有效期之后，客户端使用起来就不那么方便了。每当 Access Token 过期，客户端就必须重新向用户索要授权。这样用户可能每隔几天，甚至每天都需要进行授权操作。这是一件非常影响用户体验的事情。希望有一种方法，可以避免这种情况。于是oAuth2.0引入了Refresh Token机制Refresh TokenRefresh Token的作用是用来刷新Access Token。认证服务器提供一个刷新接口，例如：http://www.tangyuewei.com/refresh?refresh_token=&amp;client_id=传入refresh_token 和 client_id，认证服务器验证通过后，返回一个新的 Access Token。为了安全，oAuth2.0 引入了两个措施：  oAuth2.0要求，Refresh Token 一定是保存在客户端的服务器上 ，而绝不能存放在狭义的客户端（例如 App、PC 端软件）上。调用 refresh 接口的时候，一定是从服务器到服务器的访问。  oAuth2.0引入了client_secret机制。即每一个client_id都对应一个 client_secret。这个 client_secret 会在客户端申请client_id时，随client_id一起分配给客户端。客户端必须把 client_secret 妥善保管在服务器上，决不能泄露。刷新Access Token时，需要验证这个 client_secret。实际上的刷新接口类似于：    http://www.tangyuewei.com/refresh?refresh_token=&amp;client_id=&amp;client_secret=        以上就是Refresh Token机制。Refresh Token的有效期非常长，会在用户授权时，随Access Token一起重定向到回调URL，传递给客户端。  客户端授权模式概述客户端必须得到用户的授权（authorization grant），才能获得令牌（access token）。oAuth 2.0 定义了四种授权方式。  implicit：简化模式，不推荐使用  authorization code：授权码模式  resource owner password credentials：密码模式  client credentials：客户端模式简化模式简化模式适用于纯静态页面应用。所谓纯静态页面应用，也就是应用没有在服务器上执行代码的权限（通常是把代码托管在别人的服务器上），只有前端 JS 代码的控制权。这种场景下，应用是没有持久化存储的能力的。因此，按照oAuth2.0的规定，这种应用是拿不到Refresh Token的。该模式下，access_token容易泄露且不可刷新授权码模式授权码模式适用于有自己的服务器的应用，它是一个一次性的临时凭证，用来换取access_token和refresh_token。认证服务器提供了一个类似这样的接口：https://www.tangyuewei.com/exchange?code=&amp;client_id=&amp;client_secret=需要传入code、client_id以及client_secret。验证通过后，返回access_token和refresh_token。一旦换取成功，code立即作废，不能再使用第二次。这个code的作用是保护token的安全性。简单模式下，token是不安全的。这是因为在第 4 步当中直接把token返回给应用。而这一步容易被拦截、窃听。引入了code之后，即使攻击者能够窃取到code，但是由于他无法获得应用保存在服务器的client_secret，因此也无法通过code换取token。而第 5 步，为什么不容易被拦截、窃听呢？这是因为，首先，这是一个从服务器到服务器的访问，黑客比较难捕捉到；其次，这个请求通常要求是https的实现。即使能窃听到数据包也无法解析出内容。有了这个code，token 的安全性大大提高。因此，oAuth2.0鼓励使用这种方式进行授权，而简单模式则是在不得已情况下才会使用。密码模式密码模式中，用户向客户端提供自己的用户名和密码。客户端使用这些信息，向 “服务商提供商” 索要授权。在这种模式中，用户必须把自己的密码给客户端，但是客户端不得储存密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分。一个典型的例子是同一个企业内部的不同产品要使用本企业的oAuth2.0体系。在有些情况下，产品希望能够定制化授权页面。由于是同个企业，不需要向用户展示“xxx将获取以下权限”等字样并询问用户的授权意向，而只需进行用户的身份认证即可。这个时候，由具体的产品团队开发定制化的授权界面，接收用户输入账号密码，并直接传递给鉴权服务器进行授权即可。客户端模式如果信任关系再进一步，或者调用者是一个后端的模块，没有用户界面的时候，可以使用客户端模式。鉴权服务器直接对客户端进行身份验证，验证通过后，返回token。"
},

{
"title": "2022与2023",
"url": "/posts/2022%E4%B8%8E2023/",
"categories": "博客那些事",
"tags": "总结",
"date": "2023-01-06 10:00:00 +0800",







"snippet": "2023  光阴似箭，岁月如梭  不禁感叹，时间如此之快  回首这一年，手里的好牌越打越烂，到发现都是烂牌时才想着如何打好  年初时，周而复始，平淡无奇，半年如一日  年中时，才发现自己太过深情，因为往往都是深情至极的人才能上当受骗  年末时，疫情三年，突然的放开，猝不及防，最后一周，🐏了个🐏  2023年了，原本以为前面那几年已慢慢在走出低谷，才发现一直停滞不前  Tomorrow wil...",
"content": "2023  光阴似箭，岁月如梭  不禁感叹，时间如此之快  回首这一年，手里的好牌越打越烂，到发现都是烂牌时才想着如何打好  年初时，周而复始，平淡无奇，半年如一日  年中时，才发现自己太过深情，因为往往都是深情至极的人才能上当受骗  年末时，疫情三年，突然的放开，猝不及防，最后一周，🐏了个🐏  2023年了，原本以为前面那几年已慢慢在走出低谷，才发现一直停滞不前  Tomorrow will be better. Come on T Y W.  接下来的几年里，准备好蓄势待发，读万卷书，行万里路，阅人无数  愿历尽千帆，归来仍是少年  砥砺前行，未来可期，T Y W 🐄 🅱️"
},

{
"title": "springboot升级2.7后，无法设置跨域的问题",
"url": "/posts/spring-cors/",
"categories": "Spring Boot",
"tags": "Spring Boot",
"date": "2022-08-12 14:00:00 +0800",







"snippet": "描述跨域是后端接口必须处理的问题，新搭建的服务使用SpringBoot的版本为2.7.0。使用postman请求接口时不带origin，接口都是可以正常返回的，当加上了origin后，就报错了，报错信息如下：java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot cont...",
"content": "描述跨域是后端接口必须处理的问题，新搭建的服务使用SpringBoot的版本为2.7.0。使用postman请求接口时不带origin，接口都是可以正常返回的，当加上了origin后，就报错了，报错信息如下：java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value \"*\" since that cannot be set on the \"Access-Control-Allow-Origin\" response header. To allow credentials to a set of origins, list them explicitly or consider using \"allowedOriginPatterns\" instead.\tat org.springframework.web.cors.CorsConfiguration.validateAllowCredentials(CorsConfiguration.java:475)\tat org.springframework.web.cors.CorsConfiguration.checkOrigin(CorsConfiguration.java:579)\tat org.springframework.web.cors.DefaultCorsProcessor.checkOrigin(DefaultCorsProcessor.java:174)\tat org.springframework.web.cors.DefaultCorsProcessor.handleInternal(DefaultCorsProcessor.java:116)\tat org.springframework.web.cors.DefaultCorsProcessor.processRequest(DefaultCorsProcessor.java:95)\tat org.springframework.web.filter.CorsFilter.doFilterInternal(CorsFilter.java:87)\tat org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:117)\tat org.apache.catalina.core.ApplicationFilterChain.internalDoFilter(ApplicationFilterChain.java:189)\tat org.apache.catalina.core.ApplicationFilterChain.doFilter(ApplicationFilterChain.java:162)我们初始的跨域设置是这样的@Configuration@EnableWebMvcpublic class CORSConfig implements WebMvcConfigurer {    @Override    public void addCorsMappings(CorsRegistry registry) {        registry.addMapping(\"/**\")                .allowedOrigins(\"*\")                .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")                .allowCredentials(true)                .allowedHeaders(\"*\")                .maxAge(1800L);    }}根据报错的信息提示，我们将allowedOrigins修改为allowedOriginPatterns@Configuration@EnableWebMvcpublic class CORSConfig implements WebMvcConfigurer {    @Override    public void addCorsMappings(CorsRegistry registry) {        registry.addMapping(\"/**\")                .allowedOriginPatterns(\"*\")                .allowedMethods(\"GET\", \"HEAD\", \"POST\", \"PUT\", \"DELETE\", \"OPTIONS\")                .allowCredentials(true)                .allowedHeaders(\"*\")                .maxAge(1800L);    }}正常情况下，启动应用访问，应该就解决了。当还是报相同的错误。我们联系了前端和运维，在js和nginx端都作了处理，依然无济于事。  还发现一个诡异的问题，无论我本地如何上述跨域设置，都报上面相同的错误。  因为线上要使用，被迫用其他解决方案紧急处理掉。后来发现神队友居然在springboot的启动类中又写了个跨域的设置Bean。所以出现如下情况也就不奇怪了，再次提示务必规范编码，不然排查错误都能把人整懵逼。-_-||于是我本地debug设置了断点在CorsConfiguration.java:475的CorsConfiguration.validateAllowCredentials方法。发现一次请求进了两次断点。其中有一次if (this.allowCredentials == Boolean.TRUE &amp;&amp;this.allowedOrigins != null &amp;&amp; this.allowedOrigins.contains(ALL))判断是通过的，显示this.allowedOrigins的值为”*”;所以就抛了这异常java.lang.IllegalArgumentException: When allowCredentials is true, allowedOrigins cannot contain the special value \"*\" since that cannot be set on the \"Access-Control-Allow-Origin\" response header. To allow credentials to a set of origins, list them explicitly or consider using \"allowedOriginPatterns\" instead。/** * Validate that when {@link #setAllowCredentials allowCredentials} is true, * {@link #setAllowedOrigins allowedOrigins} does not contain the special * value {@code \"*\"} since in that case the \"Access-Control-Allow-Origin\" * cannot be set to {@code \"*\"}. * @throws IllegalArgumentException if the validation fails * @since 5.3 */public void validateAllowCredentials() {\t\tif (this.allowCredentials == Boolean.TRUE &amp;&amp;\t\t\t\tthis.allowedOrigins != null &amp;&amp; this.allowedOrigins.contains(ALL)) {\t\t\tthrow new IllegalArgumentException(        \"When allowCredentials is true, allowedOrigins cannot contain the special value \\\"*\\\" \" +          \"since that cannot be set on the \\\"Access-Control-Allow-Origin\\\" response header. \" +          \"To allow credentials to a set of origins, list them explicitly \" +          \"or consider using \\\"allowedOriginPatterns\\\" instead.\");\t\t}}其他解决方案  降级springboot的版本到2.3.x（推荐）          之前我们使用springboot的2.3.12.RELEASE时，设置跨域是不能allowedOriginPatterns的，接口也是正常，可以使用maven管理pom.xml先降级到2.3.x的版本。        将CorsConfiguration.java中CorsConfiguration.validateAllowCredentials方法的抛异常注释掉因为我们目前用的是2.7.0版本，并且使用了多数据源特性，使用maven降级后启动会报错。修改多数据源的代价还是很大的，所以我选择重写validateAllowCredentials方法。          首先在项目中新建org.springframework.web.cors包      在org.springframework.web.cors包中新建CorsConfiguration.java类      将CorsConfiguration.class中的代码复制到本地中，修改validateAllowCredentials方法，注释throw newIllegalArgumentException(When allowCredentials is true, allowedOrigins cannot contain the special value ...)      启动项目访问解决了。                  java加载类采用就近原则，故可以进行覆盖。                    "
},

{
"title": "时间不在于你拥有多少，而在于你怎样使用",
"url": "/posts/%E6%97%B6%E9%97%B4%E4%B8%8D%E5%9C%A8%E4%BA%8E%E4%BD%A0%E6%8B%A5%E6%9C%89%E5%A4%9A%E5%B0%91-%E8%80%8C%E5%9C%A8%E4%BA%8E%E4%BD%A0%E6%80%8E%E6%A0%B7%E4%BD%BF%E7%94%A8/",
"categories": "博客那些事",
"tags": "总结",
"date": "2022-08-05 15:00:00 +0800",







"snippet": "2022年8月5日-星期五，即将迎来一个新的周末。距离上次在博客上写作又过了几个月了。。。前两天发现申请的谷歌广告位审核通过了，现在访问我的网站有谷歌的广告了。当时心中还念想如何运营一下网站，提升访问量。  学习做SEO  学习如何输出高质量文章  引流  …绕了一圈还是一头雾水。我想创业的过程大概也是如此吧，刚开始的时候满腔热血，一鼓作气过段时间后仍没有看到成效，然后就渐渐丧失了激情，直到...",
"content": "2022年8月5日-星期五，即将迎来一个新的周末。距离上次在博客上写作又过了几个月了。。。前两天发现申请的谷歌广告位审核通过了，现在访问我的网站有谷歌的广告了。当时心中还念想如何运营一下网站，提升访问量。  学习做SEO  学习如何输出高质量文章  引流  …绕了一圈还是一头雾水。我想创业的过程大概也是如此吧，刚开始的时候满腔热血，一鼓作气过段时间后仍没有看到成效，然后就渐渐丧失了激情，直到完全放弃。然后再某个偶然的机会，看到当初从事这件事的人取得了成就，然后又想去坚持做一下又一段时间过去了，依然如之前的一样。于是乎，选择放弃，选择另外一个事务，去重复现在的过程…我不知道其他人是不是这样，反正我是这样。后来仔细想了想，是自己心里的预期比较大，也没有作好规划与实施，更没有长期持续的学习与坚持。我们看到的”成功人士”先不说在社会是极少数，更不知道他们背后的心酸历史。能在一个行业作出成绩的，必定有他独特的亮点。成功的路本来就是很少有人走的，如果能复制的话，那就不叫成功，我们也会觉得习以为常。开始认识并接受自己本来就是一个平凡的人，踏踏实实做事，好好地过自己的生活就好了，不要老想要怎样怎样。其实有时候大道理心里都懂，真实行动有时却没有作到。最后，愿我们都能找到自己的归宿，健康快乐的生活"
},

{
"title": "我的拖延症与三分热度",
"url": "/posts/%E6%88%91%E7%9A%84%E6%8B%96%E5%BB%B6%E7%97%87%E4%B8%8E%E4%B8%89%E5%88%86%E7%83%AD%E5%BA%A6/",
"categories": "博客那些事",
"tags": "总结",
"date": "2022-05-13 14:00:00 +0800",







"snippet": "说到拖延症大家都不陌生吧，每次在周末前都提醒自己不要睡懒觉，结果一到周末早上闹钟响起来的时候就摁了继续睡。基本上都睡到快饭点的时候才起来。一时赖床一时爽，一直赖床一直爽…以至于周末的空闲时间都消遣而过了。每当看到别人一直学习，变得越来越优秀的时候，心里又在安慰自己“谁叫你懒呢”除了拖延症我的三分热度也非常突出。想做一件事的时候，心里就迫不及待的要去干。干不了多久就没了当初的热血了…太难了说好...",
"content": "说到拖延症大家都不陌生吧，每次在周末前都提醒自己不要睡懒觉，结果一到周末早上闹钟响起来的时候就摁了继续睡。基本上都睡到快饭点的时候才起来。一时赖床一时爽，一直赖床一直爽…以至于周末的空闲时间都消遣而过了。每当看到别人一直学习，变得越来越优秀的时候，心里又在安慰自己“谁叫你懒呢”除了拖延症我的三分热度也非常突出。想做一件事的时候，心里就迫不及待的要去干。干不了多久就没了当初的热血了…太难了说好坚持写博客这件事，距离上次的发表都快半年了。突然想起还有写博客这事想输出点有质量的东西，感觉像茶壶煮饺子，倒不出来没有行动，怎么立flag都没用。昨天刷抖音还看到“680北京大学，720清华大学，398全身精油spa…”笑话听完，话说回来，flag立的时候最好结合实际情况，自己能做到，最好做到后再给自己一点奖励今天就到这吧"
},

{
"title": "Spring整合Elasticsearch",
"url": "/posts/Spring%E6%95%B4%E5%90%88Elasticsearch/",
"categories": "常用框架",
"tags": "ElasticSearch, 搜索引擎, ES",
"date": "2022-04-12 19:27:00 +0800",







"snippet": "Elasticsearch  Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，可用于实现全文搜索和实时数据统计。Spring整合Elasticsearch在pom.xml中添加相关依赖&lt;!--Elasticsearch相关依赖--&gt;&lt;dependency&gt;    &lt;groupI...",
"content": "Elasticsearch  Elasticsearch 是一个分布式、可扩展、实时的搜索与数据分析引擎。 它能从项目一开始就赋予你的数据以搜索、分析和探索的能力，可用于实现全文搜索和实时数据统计。Spring整合Elasticsearch在pom.xml中添加相关依赖&lt;!--Elasticsearch相关依赖--&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;artifactId&gt;&lt;/dependency&gt;修改SpringBoot配置文件data:  elasticsearch:    repositories:      enabled: true    cluster-nodes: 127.0.0.1:9300 # es的连接地址及端口号    cluster-name: elasticsearch # es集群的名称添加商品文档对象EsProductpackage com.macro.mall.tiny.nosql.elasticsearch.document;import org.springframework.data.annotation.Id;import org.springframework.data.elasticsearch.annotations.Document;import org.springframework.data.elasticsearch.annotations.Field;import org.springframework.data.elasticsearch.annotations.FieldType;import java.io.Serializable;import java.math.BigDecimal;import java.util.List;/** * 搜索中的商品信息 * Created by macro on 2018/6/19. */@Document(indexName = \"pms\", type = \"product\",shards = 1,replicas = 0)public class EsProduct implements Serializable {    private static final long serialVersionUID = -1L;    @Id    private Long id;    @Field(type = FieldType.Keyword)    private String productSn;    private Long brandId;    @Field(type = FieldType.Keyword)    private String brandName;    private Long productCategoryId;    @Field(type = FieldType.Keyword)    private String productCategoryName;    private String pic;    @Field(analyzer = \"ik_max_word\",type = FieldType.Text)    private String name;    @Field(analyzer = \"ik_max_word\",type = FieldType.Text)    private String subTitle;    @Field(analyzer = \"ik_max_word\",type = FieldType.Text)    private String keywords;    private BigDecimal price;    private Integer sale;    private Integer newStatus;    private Integer recommandStatus;    private Integer stock;    private Integer promotionType;    private Integer sort;    @Field(type =FieldType.Nested)    private List&lt;EsProductAttributeValue&gt; attrValueList;    //省略了所有getter和setter方法}添加EsProductRepository接口用于操作Elasticsearchpackage com.macro.mall.tiny.nosql.elasticsearch.repository;import com.macro.mall.tiny.nosql.elasticsearch.document.EsProduct;import org.springframework.data.domain.Page;import org.springframework.data.domain.Pageable;import org.springframework.data.elasticsearch.repository.ElasticsearchRepository;/** * 商品ES操作类 * Created by macro on 2018/6/19. */public interface EsProductRepository extends ElasticsearchRepository&lt;EsProduct, Long&gt; {    /**     * 搜索查询     *     * @param name              商品名称     * @param subTitle          商品标题     * @param keywords          商品关键字     * @param page              分页信息     * @return     */    Page&lt;EsProduct&gt; findByNameOrSubTitleOrKeywords(String name, String subTitle, String keywords, Pageable page);}添加EsProductService接口package com.macro.mall.tiny.service;import com.macro.mall.tiny.nosql.elasticsearch.document.EsProduct;import org.springframework.data.domain.Page;import java.util.List;/** * 商品搜索管理Service * Created by macro on 2018/6/19. */public interface EsProductService {    /**     * 从数据库中导入所有商品到ES     */    int importAll();    /**     * 根据id删除商品     */    void delete(Long id);    /**     * 根据id创建商品     */    EsProduct create(Long id);    /**     * 批量删除商品     */    void delete(List&lt;Long&gt; ids);    /**     * 根据关键字搜索名称或者副标题     */    Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize);}添加EsProductService接口的实现类EsProductServiceImplpackage com.macro.mall.tiny.service.impl;import com.macro.mall.tiny.dao.EsProductDao;import com.macro.mall.tiny.nosql.elasticsearch.document.EsProduct;import com.macro.mall.tiny.nosql.elasticsearch.repository.EsProductRepository;import com.macro.mall.tiny.service.EsProductService;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.domain.Page;import org.springframework.data.domain.PageRequest;import org.springframework.data.domain.Pageable;import org.springframework.stereotype.Service;import org.springframework.util.CollectionUtils;import java.util.ArrayList;import java.util.Iterator;import java.util.List;/** * 商品搜索管理Service实现类 * Created by macro on 2018/6/19. */@Servicepublic class EsProductServiceImpl implements EsProductService {    private static final Logger LOGGER = LoggerFactory.getLogger(EsProductServiceImpl.class);    @Autowired    private EsProductDao productDao;    @Autowired    private EsProductRepository productRepository;    @Override    public int importAll() {        List&lt;EsProduct&gt; esProductList = productDao.getAllEsProductList(null);        Iterable&lt;EsProduct&gt; esProductIterable = productRepository.saveAll(esProductList);        Iterator&lt;EsProduct&gt; iterator = esProductIterable.iterator();        int result = 0;        while (iterator.hasNext()) {            result++;            iterator.next();        }        return result;    }    @Override    public void delete(Long id) {        productRepository.deleteById(id);    }    @Override    public EsProduct create(Long id) {        EsProduct result = null;        List&lt;EsProduct&gt; esProductList = productDao.getAllEsProductList(id);        if (esProductList.size() &gt; 0) {            EsProduct esProduct = esProductList.get(0);            result = productRepository.save(esProduct);        }        return result;    }    @Override    public void delete(List&lt;Long&gt; ids) {        if (!CollectionUtils.isEmpty(ids)) {            List&lt;EsProduct&gt; esProductList = new ArrayList&lt;&gt;();            for (Long id : ids) {                EsProduct esProduct = new EsProduct();                esProduct.setId(id);                esProductList.add(esProduct);            }            productRepository.deleteAll(esProductList);        }    }    @Override    public Page&lt;EsProduct&gt; search(String keyword, Integer pageNum, Integer pageSize) {        Pageable pageable = PageRequest.of(pageNum, pageSize);        return productRepository.findByNameOrSubTitleOrKeywords(keyword, keyword, keyword, pageable);    }}RestHighLevelClient构建搜索引入依赖&lt;dependency&gt;    &lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;    &lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;    &lt;version&gt;7.10.2&lt;/version&gt;&lt;/dependency&gt;ElasticsearchSearchExample.javaimport org.apache.http.HttpHost;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.builder.SearchSourceBuilder;import java.io.IOException;public class ElasticsearchSearchExample {    public static void main(String[] args) {        // 创建 RestHighLevelClient 实例        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(                        new HttpHost(\"localhost\", 9200, \"http\"),                        new HttpHost(\"localhost\", 9201, \"http\")));        try {            // 创建搜索请求对象            SearchRequest searchRequest = new SearchRequest(\"your_index_name\"); // 指定索引名            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();            // 构建查询条件（此处为 match_all 查询）            searchSourceBuilder.query(QueryBuilders.matchAllQuery());            searchRequest.source(searchSourceBuilder);            // 执行搜索请求            SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);            // 处理搜索响应            System.out.println(\"Total Hits: \" + searchResponse.getHits().getTotalHits().value);            for (SearchHit hit : searchResponse.getHits().getHits()) {                System.out.println(hit.getSourceAsString());            }        } catch (IOException e) {            e.printStackTrace();        } finally {            // 关闭客户端            try {                client.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}如果你的Elasticsearch集群配置了基本的用户名和密码认证&lt;dependency&gt;&lt;groupId&gt;org.elasticsearch.client&lt;/groupId&gt;&lt;artifactId&gt;elasticsearch-rest-high-level-client&lt;/artifactId&gt;&lt;version&gt;7.10.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;&lt;artifactId&gt;httpclient&lt;/artifactId&gt;&lt;version&gt;4.5.13&lt;/version&gt;&lt;/dependency&gt;ElasticsearchSearchWithAuthExample.javaimport org.apache.http.HttpHost;import org.apache.http.auth.AuthScope;import org.apache.http.auth.UsernamePasswordCredentials;import org.apache.http.impl.client.BasicCredentialsProvider;import org.apache.http.impl.nio.client.HttpAsyncClientBuilder;import org.apache.http.impl.nio.reactor.IOReactorConfig;import org.apache.http.nio.conn.ssl.SSLIOSessionStrategy;import org.apache.http.ssl.SSLContextBuilder;import org.elasticsearch.action.search.SearchRequest;import org.elasticsearch.action.search.SearchResponse;import org.elasticsearch.client.RequestOptions;import org.elasticsearch.client.RestClient;import org.elasticsearch.client.RestClientBuilder;import org.elasticsearch.client.RestHighLevelClient;import org.elasticsearch.index.query.QueryBuilders;import org.elasticsearch.search.SearchHit;import org.elasticsearch.search.builder.SearchSourceBuilder;import java.io.IOException;public class ElasticsearchSearchWithAuthExample {    public static void main(String[] args) {        final String username = \"your_username\";        final String password = \"your_password\";        final String hostname = \"localhost\";        final int port = 9200;        // 设置认证信息        BasicCredentialsProvider credentialsProvider = new BasicCredentialsProvider();        credentialsProvider.setCredentials(AuthScope.ANY,                new UsernamePasswordCredentials(username, password));        // 创建 RestHighLevelClient 实例        RestHighLevelClient client = new RestHighLevelClient(                RestClient.builder(new HttpHost(hostname, port, \"http\"))                        .setHttpClientConfigCallback(httpClientBuilder -&gt;                                httpClientBuilder.setDefaultCredentialsProvider(credentialsProvider))        );        try {            // 创建搜索请求对象            SearchRequest searchRequest = new SearchRequest(\"your_index_name\"); // 指定索引名            SearchSourceBuilder searchSourceBuilder = new SearchSourceBuilder();            // 构建查询条件（此处为 match_all 查询）            searchSourceBuilder.query(QueryBuilders.matchAllQuery());            searchRequest.source(searchSourceBuilder);            // 执行搜索请求            SearchResponse searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);            // 处理搜索响应            System.out.println(\"Total Hits: \" + searchResponse.getHits().getTotalHits().value);            for (SearchHit hit : searchResponse.getHits().getHits()) {                System.out.println(hit.getSourceAsString());            }        } catch (IOException e) {            e.printStackTrace();        } finally {            // 关闭客户端            try {                client.close();            } catch (IOException e) {                e.printStackTrace();            }        }    }}参考文章  https://www.macrozheng.com/mall/architect/mall_arch_07.html#elasticsearch"
},

{
"title": "ElasticSearch基本应用",
"url": "/posts/ElasticSearch%E5%9F%BA%E6%9C%AC%E5%BA%94%E7%94%A8/",
"categories": "常用框架",
"tags": "ElasticSearch, 搜索引擎, ES",
"date": "2022-04-11 18:11:00 +0800",







"snippet": "概述  开发中，我们经常会要操作ES，一般需要下载工具才能管理ES。如：，本文介绍使用postman操作，  创建索引  ```PUT http://127.0.0.1:9200/shopping### 索引查询查询单个索引GET http://127.0.0.1:9200/shopping查询所有GET http://127.0.0.1:9200/_cat/indices?v### 索引删...",
"content": "概述  开发中，我们经常会要操作ES，一般需要下载工具才能管理ES。如：，本文介绍使用postman操作，  创建索引  ```PUT http://127.0.0.1:9200/shopping### 索引查询查询单个索引GET http://127.0.0.1:9200/shopping查询所有GET http://127.0.0.1:9200/_cat/indices?v### 索引删除DELETE http://127.0.0.1:9200/shopping### 文档创建POST http://127.0.0.1:9200/shopping/_docor   创建指定idhttp://127.0.0.1:9200/shopping/_doc/10086http://127.0.0.1:9200/shopping/_create/1000body raw{ “title”:”小米手机”, “category”:”小米”, “images”:”http://www.gulixueyuan.com/xm.jpg”, “price”:4999.00}### 文档查询主键查询GET http://127.0.0.1:9200/shopping/_doc/10086查询所有GET http://127.0.0.1:9200/shopping/_search    headers    Content-Type  -&gt; application/json### 文档修改全量修改PUT http://127.0.0.1:9200/shopping/_doc/10086body raw{ “title”:”华为手机”, “category”:”华为”, “images”:”http://www.gulixueyuan.com/hw.jpg”, “price”:4999.00}局部修改POST http://127.0.0.1:9200/shopping/_update/10086body raw{    “doc”: {        “title”: “国产手机”    }}### 删除文档DELETE http://127.0.0.1:9200/shopping/_doc/10086### 组合查询单个条件查询带参数GET http://127.0.0.1:9200/shopping/_searchbody raw{    //请求参数拼在地址栏可能会乱码,所以推荐放在请求体中    “query”: {        “match”: {            “category”: “小米”        }    }}条件查询分页GET http://127.0.0.1:9200/shopping/_searchbody raw{    “query”: {        “match_all”: {}    },    “from”: 0, //偏移量,0表示第一页,即页码-1    “size”: 2, //每页的个数    “_source”: [        “title” //查询结果仅显示title字段    ],    “sort”: {        “price”: {            “order”: “asc” //asc升序，desc降序        }    }}多条件查询GET http://127.0.0.1:9200/shopping/_search{    //bool表示条件的意思    “query”: {        “bool”: {            //must表示多个条件必须同时成立,[]表示数组            “must”: [                {                    “match”: {                        “category”: “小米”                    }                },                {                    “match”: {                        “price”: 3999.00                    }                }            ]        }    }}or{    //bool表示条件的意思    “query”: {        “bool”: {            //should表示或者,华为或者小米满足一个就能查出来            //效果不明显的话自行创建/修改数据            “should”: [                {                    “match”: {                        “category”: “小米”                    }                },                {                    “match”: {                        “category”: “华为”                    }                }            ]        }    }}### 范围查询GET http://127.0.0.1:9200/shopping/_searchbody raw{    //bool表示条件的意思    “query”: {        “bool”: {            //should表示或者,华为或者小米满足一个就能查出来            “should”: [                {                    “match”: {                        “category”: “小米”                    }                },                {                    “match”: {                        “category”: “华为”                    }                }            ],            “filter”: {                “range”: {                    “price”: {                        “gt”: 2000                    }                }            }        }    }}### 全文检索GET http://127.0.0.1:9200/shopping/_searchbody raw{    //es会将数据文字进行分词拆解操作，并将拆解后的数据保存到倒排索引中。这样即使只使用文字的一部分也能查到数据。    “query”: {        “match”: {            “category”: “米” //可以查看小米            //”category”: “小华” //小华可以同时查到小米和华为        }    }}### 完全匹配GET http://127.0.0.1:9200/shopping/_searchbody raw{    “query”: {        “match_phrase”: {            “category”: “小华” //匹配不到小米和华为,但是米还是可以匹配到小米            //”category”: “米”        }    }}### 高亮查询GET http://127.0.0.1:9200/shopping/_searchbody raw{    “query”: {        “match_phrase”: {            “category”: “小米”        }    },    “highlight”: {        “fields”: {            “category”: {}        }    }}### 聚合查询GET http://127.0.0.1:9200/shopping/_searchbody raw{    //想要对查询结果进行分组或者统计分析，要修改请求体body    “aggs”: { //聚合操作        “price_group”: { //名称，随意取名            “terms”: { //可选项:分组terms/平均值avg/最大值max/最小值min                “field”: “price” //(分组)字段            }        }    },    “size”: 0 //不显示原始数据，只看分组数据}stats 聚合查询{    //想要对查询结果进行分组或者统计分析，要修改请求体body    “aggs”: { //聚合操作        “stats_age”: { //名称，随意取名            “stats”: { //可选项:分组terms/平均值avg/最大值max/最小值min                “field”: “price” //(分组)字段            }        }    },    “size”: 0 //不显示原始数据，只看分组数据}## `is not null`或字段是否存在GET http://127.0.0.1:9200/shopping/_searchbody raw{    “query”: {        “bool”: {            “must”: [                {                    “bool”: {                        “must”: [                            {                                “exists”: {                                    “field”: “field1”                                }                            }                        ]                    }                },                {                    “bool”: {                        “must”: [                            {                                “exists”: {                                    “field”: “field2”                                }                            }                        ]                    }                }            ]        }    },    “from”: 0,    “size”: 10}or{    “query”: {        “bool”: {            “must”: [                {                    “bool”: {                        “must”: [                            {                                “exists”: {                                    “field”: “field1”                                }                            },                            {                                “exists”: {                                    “field”: “field2”                                }                            }                        ]                    }                }            ]        }    },    “from”: 0,    “size”: 1}## MySQL查询转ES&gt;[在线转换网址](https://printlove.cn/tools/sql2es/)## kibana查询### 查询所有索引GET _mappingGET /_cat/indices?v### 条件查询GET 索引/_search{  “query”:{    “bool”: {       “must”: [            {          “match”: {            “字段”: 字段值      }    },    {      \"match\": {        \"字段\": 字段值      }    }  ]}   } } ``` ### 字段存在但不等于值 ``` GET 索引/_search {  \"query\": {    \"bool\": { \"must_not\": [   {     \"term\": {\"字段\": \"字段值\"}   } ]    }  } } ```参考资料  postman帮助文档"
},

{
"title": "服务注册与发现基于Nacos",
"url": "/posts/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%9F%BA%E4%BA%8ENacos/",
"categories": "分布式系统",
"tags": "分布式系统, 服务注册, Nacos",
"date": "2022-04-04 10:25:00 +0800",







"snippet": "探索服务注册与发现：基于 Nacos 的 Java 实践引言在微服务架构中，服务注册与发现是一个至关重要的环节。Nacos（Dynamic Naming and Configuration Service）是阿里巴巴开源的一个服务发现和配置管理平台。本文将详细介绍 Nacos 的服务注册与发现功能，并通过 Java 代码示例展示如何在实际项目中使用 Nacos。什么是 Nacos？Nacos...",
"content": "探索服务注册与发现：基于 Nacos 的 Java 实践引言在微服务架构中，服务注册与发现是一个至关重要的环节。Nacos（Dynamic Naming and Configuration Service）是阿里巴巴开源的一个服务发现和配置管理平台。本文将详细介绍 Nacos 的服务注册与发现功能，并通过 Java 代码示例展示如何在实际项目中使用 Nacos。什么是 Nacos？Nacos 是一个易于使用的平台，主要提供以下功能：  服务注册与发现：支持基于 DNS 和基于 RPC 的服务发现。  动态配置管理：支持以数据模型来管理应用程序配置。  动态 DNS 服务：支持权重路由、健康检查等。  实时监控：提供服务的健康检查和实时监控。环境准备在开始之前，确保已安装并启动 Nacos 服务器。可以通过 Docker 快速启动一个 Nacos 实例：docker run -d --name nacos-server -p 8848:8848 nacos/nacos-server服务注册与发现1. 引入依赖在使用 Nacos 之前，我们需要在 Maven 项目中添加相关依赖：&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.nacos&lt;/groupId&gt;        &lt;artifactId&gt;nacos-client&lt;/artifactId&gt;        &lt;version&gt;2.2.0&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;2. 服务注册下面是一个将服务注册到 Nacos 的简单示例：import com.alibaba.nacos.api.NacosFactory;import com.alibaba.nacos.api.exception.NacosException;import com.alibaba.nacos.api.naming.NamingService;import com.alibaba.nacos.api.naming.pojo.Instance;public class NacosServiceRegister {    public static void main(String[] args) {        try {            // 创建 NamingService            NamingService namingService = NacosFactory.createNamingService(\"localhost:8848\");            // 注册服务            namingService.registerInstance(\"example-service\", \"127.0.0.1\", 8080);            System.out.println(\"Service registered successfully.\");        } catch (NacosException e) {            e.printStackTrace();        }    }}在上面的代码中，我们通过 NacosFactory.createNamingService 方法创建了一个 NamingService 实例，然后通过 registerInstance 方法将服务注册到 Nacos。3. 服务发现注册服务后，我们可以通过以下代码进行服务发现：import com.alibaba.nacos.api.NacosFactory;import com.alibaba.nacos.api.exception.NacosException;import com.alibaba.nacos.api.naming.NamingService;import com.alibaba.nacos.api.naming.pojo.Instance;import java.util.List;public class NacosServiceDiscovery {    public static void main(String[] args) {        try {            // 创建 NamingService            NamingService namingService = NacosFactory.createNamingService(\"localhost:8848\");            // 获取服务实例            List&lt;Instance&gt; instances = namingService.getAllInstances(\"example-service\");            for (Instance instance : instances) {                System.out.println(\"Service instance: \" + instance.getIp() + \":\" + instance.getPort());            }        } catch (NacosException e) {            e.printStackTrace();        }    }}通过 getAllInstances 方法，我们可以获取指定服务的所有实例信息。使用 Spring Cloud Alibaba 集成 NacosSpring Cloud Alibaba 提供了对 Nacos 的原生支持，使得我们可以更加方便地在 Spring Boot 项目中使用 Nacos。1. 添加依赖在 pom.xml 中添加以下依赖：&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;        &lt;version&gt;2021.1&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;2. 配置 Nacos在 application.yml 中添加 Nacos 配置：spring:  application:    name: example-service  cloud:    nacos:      discovery:        server-addr: 127.0.0.1:88483. 启动类在 Spring Boot 启动类中添加 @EnableDiscoveryClient 注解：import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.client.discovery.EnableDiscoveryClient;@SpringBootApplication@EnableDiscoveryClientpublic class NacosExampleApplication {    public static void main(String[] args) {        SpringApplication.run(NacosExampleApplication.class, args);    }}4. 服务调用通过 RestTemplate 或 Feign Client 调用其他服务：import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RestController;import org.springframework.web.client.RestTemplate;@RestControllerpublic class TestController {    @Autowired    private RestTemplate restTemplate;    @GetMapping(\"/test\")    public String test() {        String result = restTemplate.getForObject(\"http://example-service/hello\", String.class);        return \"Response: \" + result;    }}结论Nacos 作为一个强大的服务注册与发现平台，可以极大简化微服务架构中的服务管理。通过本文的介绍，您应该能够在 Java 项目中使用 Nacos 进行服务注册与发现，并通过 Spring Cloud Alibaba 进行集成和管理。希望本文对您有所帮助，如果有任何问题或建议，欢迎在评论区留言讨论。Happy Coding!"
},

{
"title": "加油2022",
"url": "/posts/%E5%8A%A0%E6%B2%B92022/",
"categories": "博客那些事",
"tags": "总结",
"date": "2021-12-31 14:00:00 +0800",







"snippet": "写给2022  光阴似箭，岁月如梭  不禁感叹，时间如此之快  这一年，明白了生活的不易  这一年，懂得了语言是把无形的刀  这一年，也看到了诸多的不足  愿每一份不被人看见的努力，在将来都会得到加倍补偿  马上就2022年了，希望新的一年一切安好  不仅是篮球需要沉淀、学习需要沉淀、生活也需要沉淀  加油2022，everything will better.  愿你历尽千帆，归来仍是少年...",
"content": "写给2022  光阴似箭，岁月如梭  不禁感叹，时间如此之快  这一年，明白了生活的不易  这一年，懂得了语言是把无形的刀  这一年，也看到了诸多的不足  愿每一份不被人看见的努力，在将来都会得到加倍补偿  马上就2022年了，希望新的一年一切安好  不仅是篮球需要沉淀、学习需要沉淀、生活也需要沉淀  加油2022，everything will better.  愿你历尽千帆，归来仍是少年  未来可期，T Y W 🐄 🅱️"
},

{
"title": "给文章加上了访问统计",
"url": "/posts/%E7%BB%99%E6%96%87%E7%AB%A0%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%AE%BF%E9%97%AE%E7%BB%9F%E8%AE%A1/",
"categories": "博客那些事",
"tags": "文章统计",
"date": "2021-11-24 10:35:00 +0800",







"snippet": "关于  一直想实现博客文章访问统计，虽然我这里没几个人看，功能还是要有的吧。有三种方案：  谷歌统计  leancloud  不蒜子谷歌的方案我这里不再复述了，有兴趣的可以去搜索一下实现方案。我这里推荐使用leancloud和不蒜子。leancloud：  优点：支持查看详细访问记录  缺点：需要写部分代码不蒜子：  优点：引入超级简单  缺点：存在网络波动记录不到、无法查看访问详细记录不蒜...",
"content": "关于  一直想实现博客文章访问统计，虽然我这里没几个人看，功能还是要有的吧。有三种方案：  谷歌统计  leancloud  不蒜子谷歌的方案我这里不再复述了，有兴趣的可以去搜索一下实现方案。我这里推荐使用leancloud和不蒜子。leancloud：  优点：支持查看详细访问记录  缺点：需要写部分代码不蒜子：  优点：引入超级简单  缺点：存在网络波动记录不到、无法查看访问详细记录不蒜子方案&lt;script async src=\"//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\"&gt;&lt;/script&gt;&lt;span id=\"busuanzi_container_site_pv\"&gt;本站总访问量&lt;span id=\"busuanzi_value_site_pv\"&gt;&lt;/span&gt;次&lt;/span&gt;&lt;span id=\"busuanzi_container_site_uv\"&gt;本站总访客数&lt;span id=\"busuanzi_value_site_uv\"&gt;&lt;/span&gt;人&lt;/span&gt;&lt;span id=\"busuanzi_container_page_pv\"&gt;本文总阅读量&lt;span id=\"busuanzi_value_page_pv\"&gt;&lt;/span&gt;次&lt;/span&gt;你没有看错，只需几行全部搞定。  原文leancloud方案  去leancloud注册开发者账号  新建应用（量不大选用开发版本就行了）  新建Class -&gt;visited_times、visitors_record。visited_times: 增加字段post_title、post_url、visited_timesvisitors_record: 增加字段post_url、visitor_ip  在设置-&gt;应用凭证拷贝AppID和AppKey。  在foot.html添加如下代码(注意替换AppID和AppKey)：    &lt;script src=\"https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js\"&gt;&lt;/script&gt;&lt;script&gt;AV.initialize(\"AppID\", \"AppKey\");&lt;/script&gt;&lt;script&gt; //新增访问次数 function addCount(Counter) {   // 页面（博客文章）中的信息：leancloud_visitors   // id为page.url， data-flag-title为page.title   var $visitors = $(\".leancloud_visitors\");   var url = $visitors.attr('id').trim();   var title = $visitors.attr('data-flag-title').trim();   var query = new AV.Query(Counter);   // 只根据文章的url查询LeanCloud服务器中的数据   query.equalTo(\"post_url\", url);   query.find({     success: function(results) {       if (results.length &gt; 0) {//说明LeanCloud中已经记录了这篇文章         var counter = results[0];         counter.fetchWhenSave(true);         counter.increment(\"visited_times\");// 将点击次数加1         counter.save(null, {           success: function(counter) {             var $element = $(document.getElementById(url));             var newTimes = counter.get('visited_times');             $element.find('.leancloud-visitors-count').text(newTimes);           },           error: function(counter, error) {             console.log('Failed to save Visitor num, with error message: ' + error.message);           }         });       } else {         // 执行这里，说明LeanCloud中还没有记录此文章         var newcounter = new Counter();         /* Set ACL */         var acl = new AV.ACL();         acl.setPublicReadAccess(true);         acl.setPublicWriteAccess(true);         newcounter.setACL(acl);         /* End Set ACL */         newcounter.set(\"post_title\", title);// 把文章标题         newcounter.set(\"post_url\", url); // 文章url         newcounter.set(\"visited_times\", 1); // 初始点击次数：1次         newcounter.save(null, { // 上传到LeanCloud服务器中           success: function(newcounter) {             var $element = $(document.getElementById(url));             var newTimes = newcounter.get('visited_times');             $element.find('.leancloud-visitors-count').text(newTimes);           },           error: function(newcounter, error) {             console.log('Failed to create');           }         });       }     },     error: function(error) {       console.log('Error:' + error.code + \" \" + error.message);     }   }); } //仅根据url和title查出当前访问次数，不做+1操作 function showCount(Counter) {   var $visitors = $(\".leancloud_visitors\");   var url = $visitors.attr('id').trim();   var title = $visitors.attr('data-flag-title').trim();   var query = new AV.Query(Counter);   var entries = [];   $visitors.each(function() {     entries.push($(this).attr(\"id\").trim());   });   query.containedIn('post_url', entries);   query.find().done(function(results) {       console.log(results);       var count_container = '.leancloud-visitors-count';       for (var i = 0; i &lt; results.length; i++) {         var item = results[i];         var url = item.get('post_url');         var time = item.get('visited_times');         var element = document.getElementById(url);         $(element).find(count_container).text(time);       }     }).fail(function(object, error) {       console.log(\"Error: \" + error.code + \" \" + error.message);     }); } //调用API获取IP function getVisitorIpAndJudge() {   var ip;   function createCORS(method, url){     var xhr = new XMLHttpRequest();     if('withCredentials' in xhr){       xhr.open(method, url, true);     }else if(typeof XDomainRequest != 'undefined'){       var xhr = new XDomainRequest();       xhr.open(method, url);     }else{       xhr = null;     }     return xhr;   }   var request = createCORS('get', 'https://api.ipify.org/?format=json&amp;callback=?');   if(request){     request.onload = function(response){       console.log(response);       var obj = JSON.parse(response.currentTarget.response);       console.log(obj);       if(obj.ip) {         ip = obj.ip;       }else {         ip = \"127.0.0.1\";       }       judgeVisitor(ip);     };     request.send();   } } //判断访客是否已访问过该文章，及访问时间，符合条件则增加一次访问次数 function judgeVisitor(ip) {   var Counter = AV.Object.extend(\"visited_times\");   var Visitor = AV.Object.extend(\"visitors_record\");   var $postInfo = $(\".leancloud_visitors\");   var post_url = $postInfo.attr('id').trim();   var query = new AV.Query(Visitor);   query.equalTo(\"visitor_ip\", ip);   query.equalTo(\"post_url\", post_url);   query.find({     success: function(results) {       if (results.length &gt; 0) {         console.log('该IP已访问过该文章');         var oldVisitor = results[0];         var lastTime = oldVisitor.updatedAt;         var curTime = new Date();         var timePassed = curTime.getTime() - lastTime.getTime();         if(timePassed &gt; 1 * 60 * 1000) {           console.log('距离该IP上一次访问该文章已超过了1分钟，更新访问记录，并增加访问次数');           addCount(Counter);           oldVisitor.fetchWhenSave(true);           oldVisitor.save(null, {             success: function(oldVisitor) { },             error: function(oldVisitor, error) {               console.log('Failed to save visitor record, with error message: ' + error.message);             }           });         } else {           console.log('这是该IP 1分钟内重复访问该文章，不更新访问记录，不增加访问次数');           showCount(Counter);         }       } else {         console.log('该IP第一次访问该文章，保存新的访问记录，并增加访问次数');         addCount(Counter);         var newVisitor = new Visitor();         /* Set ACL */         var acl = new AV.ACL();         acl.setPublicReadAccess(true);         acl.setPublicWriteAccess(true);         newVisitor.setACL(acl);         newVisitor.set(\"visitor_ip\", ip);         newVisitor.set(\"post_url\", post_url);         newVisitor.save(null, { // 上传到LeanCloud服务器中           success: function(newVisitor) { },           error: function(newVisitor, error) {             console.log('Failed to create visitor record, with error message: ' + error.message);           }         });       }     },     error: function(error) {       console.log('Error:' + error.code + \" \" + error.message);       addCount(Counter);     }   }); } $(function() {   if ($('.leancloud_visitors').length == 1) {     // 文章页面，调用判断方法，对符合条件的访问增加访问次数     getVisitorIpAndJudge();   }else if ($('.leancloud_visitors').length &gt; 1){     console.log(\"leancloud_visitors&gt;1\")     // 文章列表时     var Counter = AV.Object.extend(\"visited_times\");     showCount(Counter)   } });&lt;/script&gt;        在需要展示的地方增加如下：    &lt;span id=\"/posts/%E7%BB%99%E6%96%87%E7%AB%A0%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%AE%BF%E9%97%AE%E7%BB%9F%E8%AE%A1/\" class=\"leancloud_visitors\" data-flag-title=\"给文章加上了访问统计\"&gt;   &lt;i class=\"fa fa-eye\"&gt;&lt;span class=\"leancloud-visitors-count\"&gt;&lt;/span&gt;&lt;/i&gt;&lt;/span&gt;        注：/posts/%E7%BB%99%E6%96%87%E7%AB%A0%E5%8A%A0%E4%B8%8A%E4%BA%86%E8%AE%BF%E9%97%AE%E7%BB%9F%E8%AE%A1/为文章唯一的访问地址，给文章加上了访问统计为文章标题，leancloud-visitors-count值与上一步操作的有关联。  再次部署刷新文章页面去leancloud控制台能看到有访问记录。OK，到此就完成了。  参考文章"
},

{
"title": "与博客的折腾",
"url": "/posts/%E4%B8%8E%E5%8D%9A%E5%AE%A2%E7%9A%84%E6%8A%98%E8%85%BE/",
"categories": "博客那些事",
"tags": "博客那些事",
"date": "2021-10-14 16:32:00 +0800",







"snippet": "写博客这件事，是认真的不知不觉，写着写着就断了…18年开始建设了个人站点,折腾了几个博客系统。hexo、vuepress、jekyll….总感觉写的东西不够好，然后又不知道写啥…但是笔记还是一直都在记着，用的有道云现在换成了chirpy的主题，感觉这个简洁一些。新的主题重新开始吧，好了，先这样吧，待续…",
"content": "写博客这件事，是认真的不知不觉，写着写着就断了…18年开始建设了个人站点,折腾了几个博客系统。hexo、vuepress、jekyll….总感觉写的东西不够好，然后又不知道写啥…但是笔记还是一直都在记着，用的有道云现在换成了chirpy的主题，感觉这个简洁一些。新的主题重新开始吧，好了，先这样吧，待续…"
},

{
"title": "基于RabbitMQ的Java应用",
"url": "/posts/%E5%9F%BA%E4%BA%8ERabbitMQ%E7%9A%84Java%E5%BA%94%E7%94%A8/",
"categories": "分布式系统",
"tags": "消息队列, RabbitMQ",
"date": "2021-02-22 16:12:00 +0800",







"snippet": "基于RabbitMQ的Java应用引言RabbitMQ是一款由Pivotal公司开发的消息队列中间件，基于AMQP（Advanced Message Queuing Protocol）协议。它具有高可扩展性、高可靠性、易用性等特点，广泛应用于互联网、金融、电商等领域。本文将深入浅出地介绍RabbitMQ的基本概念、核心组件及其在Java中的编程实践。RabbitMQ的基本概念在了解如何使用R...",
"content": "基于RabbitMQ的Java应用引言RabbitMQ是一款由Pivotal公司开发的消息队列中间件，基于AMQP（Advanced Message Queuing Protocol）协议。它具有高可扩展性、高可靠性、易用性等特点，广泛应用于互联网、金融、电商等领域。本文将深入浅出地介绍RabbitMQ的基本概念、核心组件及其在Java中的编程实践。RabbitMQ的基本概念在了解如何使用RabbitMQ之前，首先要掌握一些基本概念：  Producer：消息的生产者，负责发送消息到RabbitMQ。  Consumer：消息的消费者，负责从RabbitMQ中接收消息。  Queue：消息队列，存储消息的地方。  Exchange：消息交换机，负责将消息路由到不同的队列。  Binding：绑定，将队列和交换机绑定在一起，并设定路由规则。  Routing Key：路由键，生产者发送消息时指定，用于确定消息的路由路径。RabbitMQ的核心组件RabbitMQ的核心组件包括：  Queue：存储消息的队列，消息在队列中按顺序存放，消费者按顺序接收。  Exchange：接收生产者发送的消息，并根据绑定规则将消息路由到相应的队列。主要有四种类型：          Direct：直接交换机，按照完全匹配的路由键将消息路由到队列。      Topic：主题交换机，按模式匹配路由键将消息路由到队列。      Fanout：扇出交换机，将消息广播到所有绑定的队列。      Headers：头交换机，根据消息头中的属性进行路由。        Binding：将队列和交换机绑定在一起，并设定路由规则。  Connection：客户端和RabbitMQ Broker之间的TCP连接。  Channel：在连接内复用的通道，轻量级的连接。Java编程实践环境准备首先，我们需要在项目中引入RabbitMQ的依赖。假设使用Maven构建项目，在pom.xml中添加以下依赖：&lt;dependency&gt;    &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt;    &lt;artifactId&gt;amqp-client&lt;/artifactId&gt;    &lt;version&gt;5.13.0&lt;/version&gt;&lt;/dependency&gt;生产者（Producer）代码示例生产者负责发送消息到RabbitMQ。以下是一个简单的生产者示例：import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class RabbitMQProducer {    private final static String QUEUE_NAME = \"hello\";    public static void main(String[] argv) throws Exception {        // 创建连接工厂        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(\"localhost\");        // 创建连接        try (Connection connection = factory.newConnection();             Channel channel = connection.createChannel()) {            // 声明队列            channel.queueDeclare(QUEUE_NAME, false, false, false, null);            String message = \"Hello RabbitMQ!\";            // 发送消息            channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes());            System.out.println(\" [x] Sent '\" + message + \"'\");        }    }}消费者（Consumer）代码示例消费者负责从RabbitMQ中接收消息并进行处理。以下是一个简单的消费者示例：import com.rabbitmq.client.*;public class RabbitMQConsumer {    private final static String QUEUE_NAME = \"hello\";    public static void main(String[] argv) throws Exception {        // 创建连接工厂        ConnectionFactory factory = new ConnectionFactory();        factory.setHost(\"localhost\");        // 创建连接        try (Connection connection = factory.newConnection();             Channel channel = connection.createChannel()) {            // 声明队列            channel.queueDeclare(QUEUE_NAME, false, false, false, null);            System.out.println(\" [*] Waiting for messages. To exit press CTRL+C\");            // 创建消费者            DeliverCallback deliverCallback = (consumerTag, delivery) -&gt; {                String message = new String(delivery.getBody(), \"UTF-8\");                System.out.println(\" [x] Received '\" + message + \"'\");            };            // 消费消息            channel.basicConsume(QUEUE_NAME, true, deliverCallback, consumerTag -&gt; { });        }    }}"
},

{
"title": "基于RocketMQ的Java应用",
"url": "/posts/%E5%9F%BA%E4%BA%8ERocketMQ%E7%9A%84Java%E5%BA%94%E7%94%A8/",
"categories": "分布式系统",
"tags": "消息队列, RocketMQ",
"date": "2021-02-16 14:33:00 +0800",







"snippet": "基于RocketMQ的Java应用引言RocketMQ是阿里巴巴开源的一个分布式消息中间件，具有高性能、高可靠性、分布式等特点，广泛应用于金融、电商等领域。本文将深入浅出地介绍RocketMQ的基本概念、核心组件及其在Java中的编程实践。RocketMQ的基本概念在了解如何使用RocketMQ之前，首先要掌握一些基本概念：  Producer：消息的生产者，负责发送消息到RocketMQ。...",
"content": "基于RocketMQ的Java应用引言RocketMQ是阿里巴巴开源的一个分布式消息中间件，具有高性能、高可靠性、分布式等特点，广泛应用于金融、电商等领域。本文将深入浅出地介绍RocketMQ的基本概念、核心组件及其在Java中的编程实践。RocketMQ的基本概念在了解如何使用RocketMQ之前，首先要掌握一些基本概念：  Producer：消息的生产者，负责发送消息到RocketMQ。  Consumer：消息的消费者，负责从RocketMQ中拉取消息进行处理。  Broker：消息的存储和转发节点，负责存储消息并将消息传递给消费者。  NameServer：用于管理Broker和路由信息的服务。RocketMQ的核心组件RocketMQ的核心组件包括：  Message：消息体，包含消息内容和一些附加属性。  Producer：消息发送者，可以是同步发送、异步发送或单向发送。  Consumer：消息接收者，有推模式（Push）和拉模式（Pull）两种。  Broker：消息存储和转发节点，支持主从架构。  NameServer：管理Broker的路由信息，支持动态注册与发现。Java编程实践环境准备首先，我们需要在项目中引入RocketMQ的依赖。假设使用Maven构建项目，在pom.xml中添加以下依赖：&lt;dependency&gt;    &lt;groupId&gt;org.apache.rocketmq&lt;/groupId&gt;    &lt;artifactId&gt;rocketmq-client&lt;/artifactId&gt;    &lt;version&gt;4.9.3&lt;/version&gt;&lt;/dependency&gt;生产者（Producer）代码示例生产者负责发送消息到Broker。以下是一个简单的生产者示例：import org.apache.rocketmq.client.producer.DefaultMQProducer;import org.apache.rocketmq.client.producer.SendResult;import org.apache.rocketmq.common.message.Message;public class RocketMQProducer {    public static void main(String[] args) throws Exception {        // 创建生产者实例，并指定生产者组名        DefaultMQProducer producer = new DefaultMQProducer(\"ProducerGroup\");        // 设置NameServer地址        producer.setNamesrvAddr(\"127.0.0.1:9876\");        // 启动生产者        producer.start();        // 创建一条消息，指定Topic、Tag和消息内容        Message message = new Message(\"TopicTest\", \"TagA\", \"Hello RocketMQ\".getBytes());        // 发送消息并获取发送结果        SendResult sendResult = producer.send(message);        System.out.printf(\"%s%n\", sendResult);        // 关闭生产者        producer.shutdown();    }}消费者（Consumer）代码示例消费者负责从Broker中拉取消息并进行处理。以下是一个简单的消费者示例：import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyContext;import org.apache.rocketmq.client.consumer.listener.ConsumeConcurrentlyStatus;import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;import org.apache.rocketmq.common.message.MessageExt;import java.util.List;public class RocketMQConsumer {    public static void main(String[] args) throws Exception {        // 创建消费者实例，并指定消费者组名        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(\"ConsumerGroup\");        // 设置NameServer地址        consumer.setNamesrvAddr(\"127.0.0.1:9876\");        // 订阅Topic和Tag        consumer.subscribe(\"TopicTest\", \"*\");        // 注册消息监听器        consumer.registerMessageListener(new MessageListenerConcurrently() {            @Override            public ConsumeConcurrentlyStatus consumeMessage(List&lt;MessageExt&gt; msgs, ConsumeConcurrentlyContext context) {                for (MessageExt msg : msgs) {                    System.out.printf(\"%s%n\", new String(msg.getBody()));                }                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;            }        });        // 启动消费者        consumer.start();        System.out.printf(\"Consumer Started.%n\");    }}总结通过以上示例代码，我们可以看出RocketMQ在Java中的使用非常简洁高效。本文介绍了RocketMQ的基本概念和核心组件，并通过代码示例展示了如何实现消息的生产和消费。希望这篇文章能帮助你快速上手RocketMQ，并将其应用到实际项目中。"
},

{
"title": "Jenkins持续集成",
"url": "/posts/Jekins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90/",
"categories": "各种使用指南",
"tags": "持续集成, Jenkins",
"date": "2020-10-13 10:39:06 +0800",







"snippet": "Jenkins持续集成Jenkins概述  Jenkins是一个独立的开源自动化服务器，可用于自动执行与构建，测试，交付或部署软件相关的各种任务。Jenkins可以通过本机系统软件包，Docker安装，甚至可以由安装了Java Runtime Environment（JRE）的任何机器独立运行。下载并运行Jenkins      下载Jenkins。        在下载目录中打开终端。  ...",
"content": "Jenkins持续集成Jenkins概述  Jenkins是一个独立的开源自动化服务器，可用于自动执行与构建，测试，交付或部署软件相关的各种任务。Jenkins可以通过本机系统软件包，Docker安装，甚至可以由安装了Java Runtime Environment（JRE）的任何机器独立运行。下载并运行Jenkins      下载Jenkins。        在下载目录中打开终端。        运行java -jar jenkins.war –httpPort=8080。        浏览到http://localhost:8080。        按照说明完成安装。          修改Jenkins启动的默认端口号方式：              在Jenkins安装目录下打开jenkins.xml        修改属性httpPort=8088          运行环境          macOS，Linux或Windows机器：256 MB的RAM，推荐超过512 MB。Jenkins和Docker镜像和容器的10 GB空间                    部署java应用，还需安装：  docker  git使用Pipelinemaven:pipeline {    agent { docker { image 'maven:3.3.3' } }    stages {        stage('build') {            steps {                sh 'mvn --version'            }        }    }}node:pipeline {    agent { docker { image 'node:6.3' } }    stages {        stage('build') {            steps {                sh 'npm --version'            }        }    }}stage  包含3个阶段，”Build”, “Test” and “Deploy”。  pipeline {  agent any 1  stages {      stage('Build') { //2        steps {        // 3        }      }      stage('Test') { //4        steps {        // 5        }      }      stage('Deploy') { //6        steps {        // 7        }      }    }}    在任何可用的代理上执行此管道或其任何阶段。  定义“Build”阶段。stage块在Scripted Pipeline语法中是可选的。但是，stage在脚本管道中实现块可以更清晰地显示Jenkins UI中每个阶段的任务/步骤子集。  执行与“Build”阶段相关的一些步骤。  定义“Test”阶段。  执行与“Test”阶段相关的一些步骤。  定义“Deploy”阶段。  执行与“Deploy”阶段相关的一些步骤。"
},

{
"title": "Docker Compose安装与使用",
"url": "/posts/Docker-Compose/",
"categories": "分布式系统, docker",
"tags": "分布式系统, docker, docker compose",
"date": "2020-04-14 10:39:06 +0800",







"snippet": "Docker Compose 安装在 Ubuntu 系统中安装 Docker Compose 的说明：curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose或者apt-get ...",
"content": "Docker Compose 安装在 Ubuntu 系统中安装 Docker Compose 的说明：curl -L https://github.com/docker/compose/releases/download/1.17.0/docker-compose-`uname -s`-`uname -m` -o /usr/local/bin/docker-compose或者apt-get install docker-compose给 docker-compose 添加执行的权限：sudo chmod +x /usr/local/bin/docker-compose查看 docker-compose 的版本docker-compose versionDocker Compose 使用创建一个 docker-compose.yml 配置文件：version: '3'services:  webapp:    restart: always    image: training/webapp    container_name: webapp    ports:      - 5000:5000参数说明：  version：指定脚本语法解释器版本  services：要启动的服务列表          webapp：服务名称，可以随便起名，不重复即可                  restart：启动方式，这里的 always 表示总是启动，即使服务器重启了也会立即启动服务          image：镜像的名称，默认从 Docker Hub 下载          container_name：容器名称，可以随便起名，不重复即可          ports：端口映射列列表，左边为宿主机端口，右边为容器端口                    前台运行：webster@UbuntuBase:/usr/local/docker/python$ docker-compose upCreating network \"python_default\" with the default driverCreating webapp ...Creating webapp ... doneAttaching to webappwebapp    |  * Running on http://0.0.0.0:5000/ (Press CTRL+C to quit)后台运行：webster@UbuntuBase:/usr/local/docker/python$ docker-compose up -dDocker Compose常用命令前台运行docker-compose up后台运行docker-compose up -d启动docker-compose start重新启动docker-compose restart停止docker-compose stop停止并移除容器docker-compose downDocker Compose实例Docker Compose 运行 MySQLdocker-compose.yml 配置文件：version: '3.1'services:  mysql:    restart: always    image: mysql:5.7.22    container_name: mysql    ports:      - 3306:3306    environment:      TZ: Asia/Shanghai      MYSQL_ROOT_PASSWORD: 123456    command:      --character-set-server=utf8mb4      --collation-server=utf8mb4_general_ci      --explicit_defaults_for_timestamp=true      --lower_case_table_names=1      --max_allowed_packet=128M      --sql-mode=\"STRICT_TRANS_TABLES,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION,NO_ZERO_DATE,NO_ZERO_IN_DATE,ERROR_FOR_DIVISION_BY_ZERO\"    volumes:      - mysql-data:/var/lib/mysqlvolumes:  mysql-data:Docker Compose 运行 Tomcatdocker-compose.yml 配置文件：version: '3.1'services:  tomcat:    restart: always    image: tomcat    container_name: tomcat    ports:      - 8080:8080    volumes:      - /usr/local/docker/tomcat/webapps/test:/usr/local/tomcat/webapps/test    environment:      TZ: Asia/Shanghai"
},

{
"title": "docker安装与使用",
"url": "/posts/docker%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8/",
"categories": "分布式系统, docker",
"tags": "分布式系统, docker",
"date": "2020-04-14 10:39:06 +0800",







"snippet": "Docker安装# 更新软件源sudo apt-get update# 安装所需依赖sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# 安装 GPG 证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/...",
"content": "Docker安装# 更新软件源sudo apt-get update# 安装所需依赖sudo apt-get -y install apt-transport-https ca-certificates curl software-properties-common# 安装 GPG 证书curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -# 新增软件源信息sudo add-apt-repository \"deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/ubuntu $(lsb_release -cs) stable\"# 再次更新软件源sudo apt-get -y update# 安装 Docker CE 版sudo apt-get -y install docker-ce配置用户组# 建立 docker 用户组sudo groupadd docker# 将当前用户加入 docker 组：sudo usermod -aG docker $USER配置Docker 加速器在 /etc/docker/daemon.json 中写入如下内容（如果文件不存在请新建该文件）#中国{  \"registry-mirrors\": [    \"https://registry.docker-cn.com\"  ]}#阿里云加速sudo mkdir -p /etc/dockersudo tee /etc/docker/daemon.json &lt;&lt;-'EOF'{  \"registry-mirrors\": [\"https://20v9zh9c.mirror.aliyuncs.com\"]}EOFsudo systemctl daemon-reloadsudo systemctl restart docker验证加速器是否配置成功：sudo systemctl restart dockerdocker info...# 出现如下语句即表示配置成功Registry Mirrors: https://registry.docker-cn.com/...DaoCloud 加速器  简介：DaoCloud 加速器 是广受欢迎的 Docker 工具，解决了国内用户访问 Docker Hub 缓慢的问题。DaoCloud 加速器结合国内的 CDN 服务与协议层优化，成倍的提升了下载速度。(DaoCloud 官网)[https://www.daocloud.io/mirror#accelerator-doc]curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://95822026.m.daocloud.ioDocker 常用命令查看日志docker logs -f --tail=100 CONTAINER_ID删除虚悬镜像docker container prune查看 Docker 版本docker version从 Docker 文件构建 Docker 映像docker build -t image-name docker-file-location运行 Docker 映像docker run -d image-name查看可用的 Docker 映像docker images查看最近的运行容器docker ps -l查看所有正在运行的容器docker ps -a停止运行容器docker stop container_id删除一个镜像docker rmi image-name删除所有镜像docker rmi $(docker images -q)强制删除所有镜像docker rmi -r $(docker images -q)删除所有为  的镜像docker rmi $(docker images -q -f dangling=true)删除所有容器docker rm $(docker ps -a -q)进入 Docker 容器docker exec -it container-id /bin/bash查看所有数据卷docker volume ls删除指定数据卷docker volume rm [volume_name]删除所有未关联的数据卷docker volume rm $(docker volume ls -qf dangling=true)从主机复制文件到容器sudo docker cp host_path containerID:container_path从容器复制文件到主机sudo docker cp containerID:container_path host_path"
},

{
"title": "虚拟化容器docker",
"url": "/posts/%E8%99%9A%E6%8B%9F%E5%8C%96%E5%AE%B9%E5%99%A8docker/",
"categories": "分布式系统, docker",
"tags": "分布式系统, docker",
"date": "2020-04-14 10:39:06 +0800",







"snippet": "Docker 概述      一种服务器，它是一种称为守护进程并且长时间运行的程序。    REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。    一个有命令行界面 (CLI) 工具的客户端。  系统架构  镜像（Image）  容器（Container）  仓库（Repository）| Docker | 面向对象 ||——–|——|| 容器     | 对象  ...",
"content": "Docker 概述      一种服务器，它是一种称为守护进程并且长时间运行的程序。    REST API用于指定程序可以用来与守护进程通信的接口，并指示它做什么。    一个有命令行界面 (CLI) 工具的客户端。  系统架构  镜像（Image）  容器（Container）  仓库（Repository）| Docker | 面向对象 ||——–|——|| 容器     | 对象   || 镜像     | 类    |  容器与镜像的关系类似于面向对象编程中的对象与类。            标题      说明                  镜像(Images)      Docker 镜像是用于创建 Docker 容器的模板。              容器(Container)      容器是独立运行的一个或一组应用。              客户端(Client)      Docker 客户端通过命令行或者其他工具使用 Docker API 与 Docker 的守护进程通信。              主机(Host)      一个物理或者虚拟的机器用于执行 Docker 守护进程和容器。              仓库(Registry)      Docker 仓库用来保存镜像，可以理解为代码控制中的代码仓库。Docker Hub 提供了庞大的镜像集合供使用。              Docker Machine      Docker Machine是一个简化Docker安装的命令行工具，通过一个简单的命令行即可在相应的平台上安装Docker，比如VirtualBox、 Digital Ocean、Microsoft Azure。      Docker 镜像获取镜像docker pull ubuntu:16.04从 Docker 镜像仓库获取镜像的命令是 docker pull。其命令格式为：docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]::: tip 帮助文档  具体的选项可以通过 docker pull –help 命令查询帮助。:::交互式运行docker run -it --rm \\    ubuntu:16.04 \\    bash列出镜像docker image lsdocker images镜像体积  docker image ls 列表中的镜像体积总和并非是所有镜像实际硬盘消耗。由于 Docker 镜像是多层存储结构，并且可以继承、复用，因此不同镜像可能会因为使用相同的基础镜像，从而拥有共同的层查看镜像、容器、数据卷所占用的空间。docker system df虚悬镜像  镜像既没有仓库名，也没有标签，均为 none。查询虚悬镜像  docker image ls -f dangling=true    新旧镜像同名，旧镜像名称被取消，从而出现仓库名、标签均为 none 的镜像。这类无标签镜像也被称为 虚悬镜像(dangling image)中间层镜像查询中间层镜像：docker image ls -a  为了加速镜像构建、重复利用资源，Docker 会利用 中间层镜像。::: danger 警告  只要删除那些依赖它们的镜像后，这些依赖的中间层镜像也会被连带删除:::列出部分镜像docker image ls ubuntu删除本地镜像docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]commit 镜像构成新镜像定制一个 nginx 服务器为例子docker run --name nginx -d -p 80:80 nginx直接访问：http://localhost修改欢迎内容docker exec -it nginx bash进入容器后echo '&lt;h1&gt;Hello, Docker!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html然后exit退出容器，再刷新浏览器的话，会发现内容被改变了。docker diff命令看到具体的改动。docker diff nginx将容器保存为新镜像docker commit \\    --author \"Yuewei tang &lt;472680811@qq.com&gt;\" \\    --message \"修改了默认网页\" \\    nginx \\    nginx:v2我们可以在 docker image ls 中看到这个新定制的镜像docker image ls nginx慎用 docker commit  使用 docker commit 命令虽然可以比较直观的帮助理解镜像分层存储的概念，但是实际环境中并不会这样使用。推荐使用Dockerfile 定制镜像Dockerfile 定制镜像官方文档参考  Dockerfie 官方文档  Dockerfile 最佳实践文档  Dockerfie 官方文档在一个空白目录中，建立一个文本文件，并命名为 Dockerfile。mkdir mynginxcd mynginxtouch Dockerfile输入：FROM nginxRUN echo '&lt;h1&gt;Hello, mynginx!&lt;/h1&gt;' &gt; /usr/share/nginx/html/index.html  FROM 指定基础镜像  RUN 执行命令构建镜像在 Dockerfile 文件所在目录执行：    docker build -t nginx:v3 .        ::: tip 提示    docker build [选项] &lt;上下文路径/URL/-&gt;        :::镜像构建上下文（Context）如果在 Dockerfile 中这么写：    COPY ./package.json /app/              这并不是要复制执行docker build命令所在的目录下的package.json，也不是复制 Dockerfile 所在目录下的package.json，而是复制 上下文（context）目录下的package.json。一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来      其它 docker build 的用法  接用 Git repo 进行构建    docker build https://github.com/tangyuewei/gitlab-ce-zh.git#:0.1              这行命令指定了构建所需的Git repo，并且指定默认的 master 分支，构建目录为 /0.1/，然后 Docker 就会自己去 git clone 这个项目、切换到指定分支、并进入到指定目录后开始构建        指定tar压缩包构建    docker build http://server/context.tar.gz        Dockerfile 指令详解    COPY 复制文件          COPY ...       COPY hom* /mydir/COPY hom?.txt /mydir/              ADD 更高级的复制文件    ADD package.tar.gz /usr/src/app/              如果  为一个 tar 压缩文件的话，压缩格式为 gzip, bzip2 以及 xz 的情况下，ADD 指令将会自动解压缩这个压缩文件到  去。最适合使用 ADD 的场合，就是所提及的需要自动解压缩的场合。        CMD 容器启动命令CMD [\"nginx\", \"-g\", \"daemon off;\"]CMD [ \"sh\", \"-c\", \"echo $HOME\" ]  CMD 指令的格式和 RUN 相似  ENTRYPOINT 入口点          当指定了 ENTRYPOINT 后，CMD 的含义就发生了改变，不再是直接的运行其命令，而是将 CMD 的内容作为参数传给 ENTRYPOINT 指令，换句话说实际执行时，将变为：&lt;ENTRYPOINT&gt; \"&lt;CMD&gt;\"        ENV 设置环境变量    ENV VERSION=1.0        VOLUME 定义匿名卷    VOLUME /data        EXPOSE 暴露端口    EXPOSE &lt;端口1&gt; [&lt;端口2&gt;...]        WORKDIR 指定工作目录    WORKDIR &lt;工作目录路径&gt;。#如该目录不存在，WORKDIR 会帮你建立目录        USER 指定当前用户    USER redisRUN [ \"redis-server\" ]        Docker 容器    容器操作    docker run nginx #启动docker container start #已经终止的容器启动运行docker container stop #终止一个运行中的容器docker run -d nginx #后台守护启动docker attach 567c #进入运行中的容器 567c为容器iddocker exec -it 567c bash #进入运行中的容器 567c为容器iddocker container rm  nginx #要删除一个运行中的容器，可以添加 -f 参数docker container prune #清理掉所有处于终止状态的容器docker image prune #清理虚悬镜像      导出、导入容器 docker export 567c &gt; nginx.tar cat nginx.tar | docker import - test/nginx:v1.0 docker import https://example.com/exampleimage.tgz example/imagerepoDocker 仓库Docker Hub注册账号docker login #登录docker logout #退出推送镜像docker tag ubuntu:16.04 username/ubuntu:16.04 #username 为你的 Docker 账号用户名自动创建  创建并登录 Docker Hub，以及目标网站；  在目标网站中连接帐户到 Docker Hub；  在 Docker Hub 中 配置一个自动创建；  选取一个目标网站中的项目（需要含 Dockerfile）和分支；  指定 Dockerfile 的位置，并提交创建。Docker 私有仓库安装运行 docker-registrydocker run -d -p 5000:5000 --restart=always --name registry registrydocker run -d \\    -p 5000:5000 \\    -v /opt/data/registry:/var/lib/registry \\    registry使用 docker tag 将nginx:latest 这个镜像标记为 127.0.0.1:5000/nginx:latestdocker tag nginx:latest 127.0.0.1:5000/nginx:latestdocker push 127.0.0.1:5000/nginx:latest #docker push 上传标记的镜像curl 127.0.0.1:5000/v2/_catalog #用 curl 查看仓库中的镜像docker image rm 127.0.0.1:5000/nginx:latest #先删除已有镜像，再尝试从私有仓库中下载这个镜像docker pull 127.0.0.1:5000/nginx:latest::: warning 注意  Docker 默认不允许非 HTTPS 方式推送镜像。我们可以通过 Docker 的配置选项来取消这个限制，或者查看下一节配置能够通过 HTTPS 访问的私有仓库。:::"
},

{
"title": "消息队列",
"url": "/posts/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/",
"categories": "分布式系统",
"tags": "分布式系统, 消息队列, RocketMQ, Kafka",
"date": "2020-04-11 10:39:06 +0800",







"snippet": "RabbitMQ基于RabbitMQ的Java应用Kafka  github  官方文档  中文文档  下载地址RocketMQ  Apache Alibaba RocketMQ 是一个消息中间件。消息中间件中有两个角色：消息生产者和消息消费者。RocketMQ 里同样有这两个概念，消息生产者负责创建消息并发送到 RocketMQ 服务器，RocketMQ 服务器会将消息持久化到磁盘，消息消...",
"content": "RabbitMQ基于RabbitMQ的Java应用Kafka  github  官方文档  中文文档  下载地址RocketMQ  Apache Alibaba RocketMQ 是一个消息中间件。消息中间件中有两个角色：消息生产者和消息消费者。RocketMQ 里同样有这两个概念，消息生产者负责创建消息并发送到 RocketMQ 服务器，RocketMQ 服务器会将消息持久化到磁盘，消息消费者从 RocketMQ 服务器拉取消息并提交给应用消费。  支持严格的消息顺序  支持 Topic 与 Queue 两种模式  亿级消息堆积能力  比较友好的分布式特性  同时支持 Push 与 Pull 方式消费消息  历经多次天猫双十一海量消息考验RocketMQ 优点  支持事务型消息（消息发送和 DB 操作保持两方的最终一致性，RabbitMQ 和 Kafka 不支持）  支持结合 RocketMQ 的多个系统之间数据最终一致性（多方事务，二方事务是前提）  支持 18 个级别的延迟消息（RabbitMQ 和 Kafka 不支持）  支持指定次数和时间间隔的失败消息重发（Kafka 不支持，RabbitMQ 需要手动确认）  支持 Consumer 端 Tag 过滤，减少不必要的网络传输（RabbitMQ 和 Kafka 不支持）  支持重复消费（RabbitMQ 不支持，Kafka 支持）构建 RocketMQ部署指南  下载打包git clone https://github.com/apache/rocketmq.gitcd rocketmqgit checkout -b store_with_dledger origin/store_with_dledgermvn -Prelease-all -DskipTests clean install -U  快速部署    cd distribution/target/apache-rocketmqsh bin/dledger/fast-try.sh start        基于RocketMQ的Java应用  "
},

{
"title": "服务熔断",
"url": "/posts/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD/",
"categories": "分布式系统",
"tags": "分布式系统, 服务熔断, Sentinel, Hystrix",
"date": "2020-04-03 10:39:06 +0800",







"snippet": "服务熔断概述  服务熔断也被称为服务过载保护。对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源，确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回，不会阻塞。Hystrix  Hystrix是比较稳定的，但是Hystrix停止开发新的版本引入依赖&lt;dependency&gt;    &lt;groupId&gt...",
"content": "服务熔断概述  服务熔断也被称为服务过载保护。对于目标服务的请求和调用大量超时或失败，这时应该熔断该服务的所有调用，并且对于后续调用应直接返回，从而快速释放资源，确保在目标服务不可用的这段时间内，所有对它的调用都是立即返回，不会阻塞。Hystrix  Hystrix是比较稳定的，但是Hystrix停止开发新的版本引入依赖&lt;dependency&gt;    &lt;groupId&gt;com.netflix.hystrix&lt;/groupId&gt;    &lt;artifactId&gt;hystrix-core&lt;/artifactId&gt;    &lt;version&gt;x.y.z&lt;/version&gt;&lt;/dependency&gt;Alibaba Sentinel（推荐）下载并打包# 下载源码git clone https://github.com/alibaba/Sentinel.git# 编译打包mvn clean package启动控制台Sentinel 控制台是一个标准的 SpringBoot 应用，以 SpringBoot 的方式运行 jar 包即可。cd sentinel-dashboard\\targetjava -Dserver.port=8080 -Dcsp.sentinel.dashboard.server=localhost:8080 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard.jar  如若 8080 端口冲突，可使用 -Dserver.port=新端口 进行设置。访问服务  打开浏览器访问：http://localhost:8080/#/dashboard/home配置控制台信息application.yml 配置文件中增加如下配置：spring:  cloud:    sentinel:      transport:        port: 8719        dashboard: localhost:8080  这里的 spring.cloud.sentinel.transport.port 端口配置会在应用对应的机器上启动一个 Http Server，该 Server 会与 Sentinel 控制台做交互。比如 Sentinel 控制台添加了 1 个限流规则，会把规则数据 push 给这个 Http Server 接收，Http Server 再将规则注册到 Sentinel 中。测试 Sentinel使用之前的 Feign 客户端，application.yml 完整配置如下：spring:  application:    name: nacos-consumer-feign  cloud:    nacos:      discovery:        server-addr: localhost:8848    sentinel:      transport:        port: 8720        dashboard: localhost:8080server:  port: 9092feign:  sentinel:    enabled: truemanagement:  endpoints:    web:      exposure:        include: \"*\"::: tip注：由于 8719 端口已被 sentinel-dashboard 占用，故这里修改端口号为 8720；不修改也能注册，会自动帮你在端口号上 + 1；:::打开浏览器访问：http://localhost:8080/#/dashboard/home此时会多一个名为 nacos-consumer-feign 的服务"
},

{
"title": "服务注册基于dubbo",
"url": "/posts/%E6%9C%8D%E5%8A%A1%E6%B3%A8%E5%86%8C%E5%9F%BA%E4%BA%8Edubbo/",
"categories": "分布式系统",
"tags": "服务注册, dubbo",
"date": "2020-03-25 17:23:00 +0800",







"snippet": "基于 Dubbo 的服务注册与发现在微服务架构中，服务注册与发现是一个重要的组件，用于管理服务实例的动态注册和查找。Dubbo 是阿里巴巴开源的一个高性能 RPC 框架，广泛应用于分布式系统中，提供了完备的服务注册与发现功能。本文将介绍如何使用 Dubbo 实现服务注册与发现，包括环境搭建、配置以及基本的代码示例。环境准备  Java 环境：确保已安装 JDK 8 或以上版本。  Maven...",
"content": "基于 Dubbo 的服务注册与发现在微服务架构中，服务注册与发现是一个重要的组件，用于管理服务实例的动态注册和查找。Dubbo 是阿里巴巴开源的一个高性能 RPC 框架，广泛应用于分布式系统中，提供了完备的服务注册与发现功能。本文将介绍如何使用 Dubbo 实现服务注册与发现，包括环境搭建、配置以及基本的代码示例。环境准备  Java 环境：确保已安装 JDK 8 或以上版本。  Maven：用于管理项目依赖。  Zookeeper：作为服务注册中心。可以从 Zookeeper 官方网站 下载并安装。项目结构创建一个基于 Maven 的多模块项目，包含三个模块：  dubbo-api：定义服务接口。  dubbo-provider：服务提供者。  dubbo-consumer：服务消费者。dubbo-demo├── dubbo-api├── dubbo-provider└── dubbo-consumer1. 定义服务接口（dubbo-api）在 dubbo-api 模块中，创建一个简单的服务接口：package com.example.dubbo.api;public interface GreetingService {    String sayHello(String name);}2. 实现服务提供者（dubbo-provider）在 dubbo-provider 模块中，实现 GreetingService 接口，并配置 Dubbo 服务。依赖配置在 pom.xml 中添加必要的依赖：&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.7.8&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;        &lt;version&gt;3.4.14&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.example&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;服务实现创建服务实现类：package com.example.dubbo.provider;import com.example.dubbo.api.GreetingService;import org.apache.dubbo.config.annotation.DubboService;@DubboServicepublic class GreetingServiceImpl implements GreetingService {    @Override    public String sayHello(String name) {        return \"Hello, \" + name;    }}配置文件在 application.yml 中配置 Dubbo 和 Zookeeper：dubbo:  application:    name: dubbo-provider  registry:    address: zookeeper://127.0.0.1:2181  protocol:    name: dubbo    port: 20880启动类创建 Spring Boot 启动类：package com.example.dubbo.provider;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DubboProviderApplication {    public static void main(String[] args) {        SpringApplication.run(DubboProviderApplication.class, args);    }}3. 实现服务消费者（dubbo-consumer）在 dubbo-consumer 模块中调用远程服务。依赖配置在 pom.xml 中添加必要的依赖：&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.dubbo&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-spring-boot-starter&lt;/artifactId&gt;        &lt;version&gt;2.7.8&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.apache.zookeeper&lt;/groupId&gt;        &lt;artifactId&gt;zookeeper&lt;/artifactId&gt;        &lt;version&gt;3.4.14&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;com.example&lt;/groupId&gt;        &lt;artifactId&gt;dubbo-api&lt;/artifactId&gt;        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;调用服务创建一个控制器来调用远程服务：package com.example.dubbo.consumer;import com.example.dubbo.api.GreetingService;import org.apache.dubbo.config.annotation.DubboReference;import org.springframework.web.bind.annotation.GetMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class GreetingController {    @DubboReference    private GreetingService greetingService;    @GetMapping(\"/hello\")    public String sayHello(@RequestParam String name) {        return greetingService.sayHello(name);    }}配置文件在 application.yml 中配置 Dubbo 和 Zookeeper：dubbo:  application:    name: dubbo-consumer  registry:    address: zookeeper://127.0.0.1:2181启动类创建 Spring Boot 启动类：package com.example.dubbo.consumer;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class DubboConsumerApplication {    public static void main(String[] args) {        SpringApplication.run(DubboConsumerApplication.class, args);    }}4. 启动和测试确保 Zookeeper 正常运行，然后分别启动 dubbo-provider 和 dubbo-consumer 应用。在浏览器中访问 http://localhost:8080/hello?name=world，应该能看到返回的 Hello, world 字符串。总结通过上述步骤，我们实现了一个简单的基于 Dubbo 的服务注册与发现示例。Dubbo 提供了强大的服务治理功能，包括负载均衡、熔断、限流等，可以根据实际需求进行扩展和配置。希望这篇文章对你理解 Dubbo 的服务注册与发现有所帮助。"
},

{
"title": "分布式系统协调zookeeper",
"url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%8D%8F%E8%B0%83zookeeper/",
"categories": "分布式系统",
"tags": "分布式系统, 服务注册, zookeeper",
"date": "2020-03-24 10:39:06 +0800",







"snippet": "zookeeperZookeeper 简介  Zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户Zookeeper 设计目标      简单的数据结构，Zookeeper 就是以简单...",
"content": "zookeeperZookeeper 简介  Zookeeper 是一个分布式的，开放源码的分布式应用程序协调服务，是 Google 的 Chubby 一个开源的实现，它是集群的管理者，监视着集群中各个节点的状态根据节点提交的反馈进行下一步合理操作。最终，将简单易用的接口和性能高效、功能稳定的系统提供给用户Zookeeper 设计目标      简单的数据结构，Zookeeper 就是以简单的树形结构来进行协调的（也叫做树形名字空间）。        可以构建集群，一般 Zookeeper 集群通常甶一组机器构成，一般3~5台机器就可以组成一个 Zookeeper 集群了，只要集群中超过一半以上的机器能够正常工作，那么整个集群就能正常对外服务。        顺序访问。对于来自每一个客户端的每一个请求，Zookeeper 都会分配一个全局唯一的递增编号，这个编号反映了所有事物操作的先后顺序，应用程序可以使用 Zookeeper 的这个特性来实现更高层次的同步。        高性能，甶于 Zookeeper 将全量数据存储在内存中，并直接服务于所有的非事务请求，因此尤其 是在读操作为主的场景下，性能非常突出。在 JMeter 压力测试下（100%读请求），其结果大约在 12-13W 的 QPS。  QPS： 每秒查询率 QPS 是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准分布式协调技术  什么是分布式协调技术？分布式协调技术主要用来解决分布式环境当中多个进程之间的同步控制，让他们有序的去访问某种临界资源，防止造成”脏数据”的后果。分布式锁应用场景  在分布式锁服务中，有一种最典型应用场景，就是通过对集群进行 Master 选举，来解决分布式系统中的单点故障。什么是分布式系统中的单点故障：通常分布式系统采用主从模式，就是一个主控机连接多个处理节点。主节点负责分发任务，从节点负责处理任务，当我们的主节点发生故障时，那么整个系统就都瘫痪了，那么我们把这种故障叫作单点故障。  传统解决方案传统方式是采用一个备用节点，这个备用节点定期给当前主节点发送 ping 包，主节点收到 ping 包以后向备用节点发送回复Ack，当备用节点收到回复的时候就会认为当前主节点还活着，让他继续提供服务。当主节点挂了，这时备用节点收不到回复了，备用节点就接替他成为主节点::: tip 提示方式就是有一个隐患，就是网络问题。主节点并没有挂，只是在回复的时候网络发生故障，这样我们的备用节点同样收不到回复，就会认为主节点挂了，然后备用节点将他的Master实例启动起来，这样我们的分布式系统当中就有了两个主节点也就是—双Master， 出现Master以后我们的从节点就会将它所做的事一部分汇报给了主节点，一部分汇报给了从节点，这样服务就全乱了。为了防止出现这种情况，我们引入了 Zookeeper，它虽然不能避免网络故障，但它能够保证每时每刻只有一个 Master。:::  Zookeeper 解决方案在引入了 Zookeeper 以后我们启动了两个主节点，”主节点-A”和”主节点-B”他们启动以后，都向 Zookeeper 去注册一个节点。我们 假设”主节点-A”锁注册的节点是”master-00001”，”主节点-B”注册的节点是”master-00002”，注册完以后进行选举，编号最小的节点将在选举中获胜获得锁成为主节点，也就是我们的”主节点-A”将会获得锁成为主节点，然后”主节点-B”将被阻塞成为一个备用节点。那么，通过这种方式就完成了对两个 Master 进程的调度。如果”主节点-A”挂了，这时候他所注册的节点将被自动删除，Zookeeper 会自动感知节点的变化，然后再次发出选举，这时候”主节点-B”将在选举中获胜，替代”主节点-A”成为主节点。如果主节点恢复了，他会再次向 Zookeeper 注册一个节点，这时候他注册的节点将会是”master-00003”，Zookeeper 会感知节点的变化再次发动选举，这时候”主节点-B”在选举中会再次获胜继续担任”主节点”，”主节点-A”会担任备用节点。  数据发布/订阅  负载均衡  命名服务  分布式协调/通知  集群管理  选举  分布式锁  分布式队列    四种类型的数据节点 Znode    PERSISTENT-持久节点  EPHEMERAL-临时节点  PERSISTENT_SEQUENTIAL-持久顺序节点  EPHEMERAL_SEQUENTIAL-临时顺序节点zookeeper 常用的命令  常用命令：ls get set create delete 等。"
},

{
"title": "分布式系统服务路由",
"url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1%E8%B7%AF%E7%94%B1/",
"categories": "分布式系统",
"tags": "分布式系统, 服务路由, Zuul, Spring Cloud Gateway",
"date": "2020-03-18 10:39:06 +0800",







"snippet": "Spring Cloud GatewaySpring Cloud Gateway功能：      基于Spring Framework 5，Project Reactor和Spring Boot 2.0构建        能够匹配任何请求属性上的路由。        谓词和过滤器特定于路由。        Hystrix断路器集成。        Spring Cloud Discovery...",
"content": "Spring Cloud GatewaySpring Cloud Gateway功能：      基于Spring Framework 5，Project Reactor和Spring Boot 2.0构建        能够匹配任何请求属性上的路由。        谓词和过滤器特定于路由。        Hystrix断路器集成。        Spring Cloud DiscoveryClient集成        易于编写的谓词和过滤器        请求速率限制        路径改写  maven 依赖  pom新增依赖``` xml    org.springframework.cloud    spring-cloud-starter-gateway- yaml相关配置``` yamlspring:  application:    # 应用名称    name: gateway  main:      allow-bean-definition-overriding: true  cloud: # 路由网关配置    gateway:      # 设置与服务注册发现组件结合，这样可以采用服务名的路由策略      discovery:        locator:          enabled: true      # 配置路由规则      routes:        # 采用自定义路由 ID（有固定用法，不同的 id 有不同的功能，详见：https://cloud.spring.io/spring-cloud-gateway/2.0.x/single/spring-cloud-gateway.html#gateway-route-filters）        - id: CONSUMER-OAUTH2          # 采用 LoadBalanceClient 方式请求，以 lb:// 开头，后面的是注册在 Nacos 上的服务名          uri: lb://consumer-oauth2          # Predicate 翻译过来是“谓词”的意思，必须，主要作用是匹配用户的请求，有很多种用法          predicates:            # Method 方法谓词，这里是匹配 GET 和 POST 请求            #- Method=GET,POST            # 路径匹配，以 api 开头，直接配置是不生效的，看 filters 配置            - Path=/api/user/**          filters:            # 前缀过滤，默认配置下，我们的请求路径是 http://localhost:9000/consumer-oauth2/** 这时会路由到指定的服务            # 此处配置去掉 1 个路径前缀，再配置上面的 Path=/api/**，就能按照 http://localhost:9000/api/** 的方式访问了            - StripPrefix=1Zuulmaven 依赖&lt;dependency&gt;    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;    &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;&lt;/dependency&gt;启动类标注注解@EnableZuulProxyyaml相关配置# 构建路由地址zuul:  routes:    # 这里可以自定义    demo2:      # 匹配的路由规则      path: /demo/**      # 路由的目标服务名      serviceId: demo"
},

{
"title": "分布式数据库",
"url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93/",
"categories": "分布式系统",
"tags": "ShardingSphere, 数据库, 分布式系统",
"date": "2020-03-16 10:39:06 +0800",







"snippet": "ShardingSphere概述  定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。  适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。  基...",
"content": "ShardingSphere概述  定位为轻量级Java框架，在Java的JDBC层提供的额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。  适用于任何基于Java的ORM框架，如：JPA, Hibernate, Mybatis, Spring JDBC Template或直接使用JDBC。  基于任何第三方的数据库连接池，如：DBCP, C3P0, BoneCP, Druid, HikariCP等。  支持任意实现JDBC规范的数据库。目前支持MySQL，Oracle，SQLServer和PostgreSQL。ShardingSphere官网功能列表数据分片  分库 &amp; 分表  读写分离  分片策略定制化  无中心化分布式主键分布式事务  标准化事务接口  XA强一致事务  柔性事务数据库治理  配置动态化  编排 &amp; 治理  数据脱敏  可视化链路追踪  弹性伸缩(规划中)读写分离  引入pom依赖``` xml    org.apache.shardingsphere    sharding-jdbc-spring-boot-starter    4.0.0-RC1- 配置properties``` propertiesspring.shardingsphere.datasource.names=master,slave0,slave1spring.shardingsphere.datasource.master.type=com.zaxxer.hikari.HikariDataSourcespring.shardingsphere.datasource.master.driver-class-name=com.mysql.cj.jdbc.Driverspring.shardingsphere.datasource.master.url=jdbc:mysql://localhost:3306/masterspring.shardingsphere.datasource.master.username=rootspring.shardingsphere.datasource.master.password=spring.shardingsphere.datasource.slave0.type=com.zaxxer.hikari.HikariDataSourcespring.shardingsphere.datasource.slave0.driver-class-name=com.mysql.cj.jdbc.Driverspring.shardingsphere.datasource.slave0.url=jdbc:mysql://localhost:3306/slave0spring.shardingsphere.datasource.slave0.username=rootspring.shardingsphere.datasource.slave0.password=spring.shardingsphere.datasource.slave1.type=com.zaxxer.hikari.HikariDataSourcespring.shardingsphere.datasource.slave1.driver-class-name=com.mysql.cj.jdbc.Driverspring.shardingsphere.datasource.slave1.url=jdbc:mysql://localhost:3306/slave1spring.shardingsphere.datasource.slave1.username=rootspring.shardingsphere.datasource.slave1.password=spring.shardingsphere.masterslave.load-balance-algorithm-type=round_robinspring.shardingsphere.masterslave.name=msspring.shardingsphere.masterslave.master-data-source-name=masterspring.shardingsphere.masterslave.slave-data-source-names=slave0,slave1spring.shardingsphere.props.sql.show=true"
},

{
"title": "分布式缓存",
"url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%BC%93%E5%AD%98/",
"categories": "分布式系统",
"tags": "Redis, 分布式系统",
"date": "2020-03-08 10:39:06 +0800",







"snippet": "Redis HADocker 搭建 Redis 集群基于4.0.14版本搭建一主两从环境，docker-compose.yml 配置如下：version: '3.1'services:  master:    image: redis:4.0.14    container_name: redis-master    ports:      - 6379:6379  slave1:    i...",
"content": "Redis HADocker 搭建 Redis 集群基于4.0.14版本搭建一主两从环境，docker-compose.yml 配置如下：version: '3.1'services:  master:    image: redis:4.0.14    container_name: redis-master    ports:      - 6379:6379  slave1:    image: redis:4.0.14    container_name: redis-slave-1    ports:      - 6380:6379    command: redis-server --slaveof redis-master 6379  slave2:    image: redis:4.0.14    container_name: redis-slave-2    ports:      - 6381:6379    command: redis-server --slaveof redis-master 6379Docker 搭建 Redis Sentinel 集群  需要三份 sentinel.conf 配置文件，分别为：sentinel1.conf，sentinel2.conf，sentinel3.conf，配置文件内容相同      port 26379  dir /tmp  # 自定义集群名，其中 127.0.0.1 为 redis-master 的 ip，6379 为 redis-master 的端口，2 为最小投票数（因为有 3 台 Sentinel 所以可以设置成 2）  sentinel monitor mymaster 127.0.0.1 6379 2  sentinel down-after-milliseconds mymaster 30000  sentinel parallel-syncs mymaster 1  sentinel failover-timeout mymaster 180000  sentinel deny-scripts-reconfig yes            基于4.0.14版本，需要创建三个Redis Sentinel 服务，docker-compose.yml 配置如下：      version: '3.1'  services:    sentinel1:      image: redis:4.0.14      container_name: redis-sentinel-1      ports:        - 26379:26379      command: redis-sentinel /usr/local/etc/redis/sentinel.conf      volumes:        - ./sentinel1.conf:/usr/local/etc/redis/sentinel.conf    sentinel2:      image: redis:4.0.14      container_name: redis-sentinel-2      ports:        - 26380:26379      command: redis-sentinel /usr/local/etc/redis/sentinel.conf      volumes:        - ./sentinel2.conf:/usr/local/etc/redis/sentinel.conf    sentinel3:      image: redis:4.0.14      container_name: redis-sentinel-3      ports:        - 26381:26379      command: redis-sentinel /usr/local/etc/redis/sentinel.conf      volumes:        - ./sentinel3.conf:/usr/local/etc/redis/sentinel.conf      检查集群查看集群是否生效,进入 Sentinel 容器docker exec -it redis-sentinel-1 /bin/bashredis-cli -p 26379sentinel master mymastersentinel slaves mymaster"
},

{
"title": "分布式session",
"url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8Fsession/",
"categories": "分布式系统",
"tags": "分布式系统",
"date": "2020-03-06 10:39:06 +0800",







"snippet": "分布式session基于 nfs(net filesystem) 的 Session 共享  将共享服务器目录 mount 各服务器的本地 session 目录，session 读写受共享服务器 io 限制，不能满足高并发。基于关系数据库的 Session 共享  这种方案普遍使用。使用关系数据库存储 session 数据，对于 mysql 数据库，建议使用 heap 引擎。这种方案性能取决...",
"content": "分布式session基于 nfs(net filesystem) 的 Session 共享  将共享服务器目录 mount 各服务器的本地 session 目录，session 读写受共享服务器 io 限制，不能满足高并发。基于关系数据库的 Session 共享  这种方案普遍使用。使用关系数据库存储 session 数据，对于 mysql 数据库，建议使用 heap 引擎。这种方案性能取决于数据库的性能，在高并发下容易造成表锁（虽然可以采用行锁的存储引擎，性能会下降），并且需要自己实现 session 过期淘汰机制。基于 Cookie 的 Session 共享  这种方案也在大型互联网中普遍使用，将用户的 session 加密序列化后以 cookie 的方式保存在网站根域名下（比如 taobao.com），当用户访问所有二级域名站点式，浏览器会传递所有匹配的根域名的 cookie 信息，这样实现了用户 cookie 化 session 的多服务共享。此方案能够节省大量服务器资源，缺点是存储的信息长度受到 http 协议限制；cookie 的信息还需要做加密解密；请求任何资源时都会将 cookie 附加到 http 头上传到服务器，占用了一定带宽。基于 Web 容器的 Session 机制  利用容器机制，通过配置即可实现。基于 Redis/Memcached 的 Session 共享存储  这些 key/value 非关系存储有较高的性能，轻松达到 2000 左右的 qps，内置的过期机制正好满足 session 的自动实效特性。"
},

{
"title": "分布式系统简介",
"url": "/posts/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/",
"categories": "分布式系统",
"tags": "分布式系统",
"date": "2020-03-02 10:39:06 +0800",







"snippet": "分布式系统概述  分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。分布式系统的特性高吞吐、高并发、低延迟和负载均衡。  高吞吐          高吞吐指的是业务系统可以同时承载大量的用户，关注的是整个系统能同时服务的用户数，它们由...",
"content": "分布式系统概述  分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据。分布式系统的特性高吞吐、高并发、低延迟和负载均衡。  高吞吐          高吞吐指的是业务系统可以同时承载大量的用户，关注的是整个系统能同时服务的用户数，它们由多台服务器协作一起完成。        高并发          高并发指的是业务系统在承载海量用户的时候，每台服务器程序都能够尽量多的同时处理多个任务。        低延迟          低延迟指的是业务系统在面对海量用户时仍能够很快的返回计算结果。如果业务系统架构不合理，当有大量用户同时访问系统时很可能造成请求排队，当排队长度过长，还会导致系统内存耗尽、带宽被占满等问题。如果因为排队失败在采取重试的策略，则会进一步增加延迟。一个合理的分布式系统会采用将用户请求进行分拣和分发的做法，尽快的让更多的服务器来处理用户的请求，但如果分发的层次过多又会增加系统的延迟。        负载均衡          互联网业务面向整个互联网的用户，他们位于不同时区，不同地理位置，所使用的网络线路也不一样，考虑到这种情况，分布式系统就需要在不同的地理位置和网络线路中部署服务器。这些不同位置的服务器依然属于一个分布式系统，他们同时处理不同用户相同的业务请求，这即实现了负载均衡。      "
},

{
"title": "微服务架构简介",
"url": "/posts/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84%E7%AE%80%E4%BB%8B/",
"categories": "微服务架构",
"tags": "微服务架构简介, 微服务",
"date": "2019-11-11 10:39:06 +0800",







"snippet": "微服务架构什么是微服务（what）概述  微服务 - 也称为微服务架构 - 是一种架构风格，它将应用程序构建为一组服务      根据业务模块划分服务类别    可以独立部署且互相隔离    可以通过轻量级API调用    高度可维护和可测试  微服务需要解决的问题  多个服务如何访问  多个服务如何治理  服务挂了问题  多个服务间通信什么情况下应该使用微服务（why）优点  支持大型复杂...",
"content": "微服务架构什么是微服务（what）概述  微服务 - 也称为微服务架构 - 是一种架构风格，它将应用程序构建为一组服务      根据业务模块划分服务类别    可以独立部署且互相隔离    可以通过轻量级API调用    高度可维护和可测试  微服务需要解决的问题  多个服务如何访问  多个服务如何治理  服务挂了问题  多个服务间通信什么情况下应该使用微服务（why）优点  支持大型复杂应用程序的持续交付和部署。          改进的可维护性 - 每项服务都相对较小，因此更易于理解和更改      更好的可测试性 - 测试服务更小，速度更快      更好的可部署性 - 可以独立部署服务      它使您能够围绕多个自治团队组织开发工作。每个（所谓的两个披萨）团队拥有并负责一项或多项服务。每个团队都可以独立于所有其他团队开发，测试，部署和扩展他们的服务。        每个微服务都相对较小：          开发人员更容易理解      IDE可以更快地提高开发人员的工作效率      应用程序启动速度更快，这使开发人员的工作效率更高，并加快了部署速度        改善了故障隔离。例如，如果一个服务中存在内存泄漏，则只会影响该服务。其他服务将继续处理请求。相比之下，单片架构中的一个行为不当的组件可能会导致整个系统崩溃。  消除对技术堆栈的任何长期承诺。在开发新服务时，您可以选择新的技术堆栈。同样，在对现有服务进行重大更改时，您可以使用新技术堆栈重写它。    缺点    开发人员必须处理创建分布式系统的额外复杂性：          开发人员必须实现跨服务通信机制并处理部分失败      实现跨多个服务的请求更加困难      测试服务之间的交互更加困难      实现跨多个服务的请求需要团队之间的仔细协调      开发人员工具/ IDE面向构建单一应用程序，并不为开发分布式应用程序提供明确支持。        部署复杂性。在生产中，还存在部署和管理由许多不同服务组成的系统的操作复杂性。  增加内存消耗。微服务架构用NxM服务实例替换N个单片应用程序实例。如果每个服务都在自己的JVM（或等效服务器）中运行，这通常是隔离实例所必需的，那么就会产生M倍运行时M次的开销。此外，如果每个服务都在自己的VM上运行（例如EC2实例），就像Netflix一样，开销甚至更高。    何时使用微服务架构    使用这种方法的一个挑战是决定何时使用它。在开发应用程序的第一个版本时，您通常不会遇到此方法所解决的问题。此外，使用精心设计的分布式架构将减缓开发速度。对于初创公司而言，这可能是一个主要问题，其最大的挑战通常是如何快速发展业务模型和随附的应用程序。使用Y轴拆分可能会使快速迭代变得更加困难。然而，稍后，当挑战是如何扩展并且您需要使用功能分解时，纠结的依赖关系可能使您难以将整体应用程序分解为一组服务。    如何将单体重构为微服务架构（how）    将单体架构重构为微服务架构必须解决的一些问题:    按业务能力分解并定义与业务功能拆分相对应的服务。  通过域驱动设计子域进行分解。  通过动词或用例分解并定义负责特定操作的服务。例如Shipping Service，负责运送完整订单。RESTFUL风格  通过定义一个服务来分解名词或资源，该服务负责对给定类型的实体/资源的所有操作。例如 Account Service，负责管理用户帐户的人。理想情况下，每项服务应该只有一小部分职责。（设计模式中的单一责任原则）"
},

{
"title": "管理思维",
"url": "/posts/%E7%AE%A1%E7%90%86%E6%80%9D%E7%BB%B4/",
"categories": "管理思维",
"tags": "领导梯队, 管理思维, 工作模式, 行为模式, 建设层次, 个人发展阶段",
"date": "2019-10-13 10:39:06 +0800",







"snippet": "管理思维  彼得原理：在一个等级制度中，每个员工趋向于上升到他所不能胜任的地位。工作模式  汇报工作,说结果;  请示工作,说方案;  总结工作,说流程;  布置工作,说标准;行为模式  谨言慎行，扬长避短;  兢兢业业, 临危不惧;前言他山之石可以攻玉  7成岗位锻炼，2成人际学习，1成课堂培训。  建设层次      体系模式              人才理念        战略   ...",
"content": "管理思维  彼得原理：在一个等级制度中，每个员工趋向于上升到他所不能胜任的地位。工作模式  汇报工作,说结果;  请示工作,说方案;  总结工作,说流程;  布置工作,说标准;行为模式  谨言慎行，扬长避短;  兢兢业业, 临危不惧;前言他山之石可以攻玉  7成岗位锻炼，2成人际学习，1成课堂培训。  建设层次      体系模式              人才理念        战略        结构        政策        制度        流程              系统方法（操作手册）              轮岗培养                    从干中学        快速成长      - 岗位锻炼      - 领导反馈      - 自我修正      - 重复实践              实战工具              教练辅导        行动学习有效的提问，而非告诉答案          发展阶段          第一阶段                      从管理自我到管理他人，重点是从自己做事转变为带队伍做事这个工作理念的转变。              工作计划        知人善任        分配工作        激励员工        教练辅导        绩效评估从自己做事==&gt;带团队做事                        个人贡献者      一线经理                  工作技能：1.技术或业务能力 2.团队协作能力 3.为了个人利益和个人成果建立人际关系 4.合理运用公司的工具、流程和规则      领导技能：1.指定计划-项目计划、预算计划和人员计划 2.工作设计 3.人员选拔 4.授权 5.绩效监督 6.教练辅导与反馈 7.绩效评估 8.奖励与激励 9.沟通与营造工作氛围 10.为部门发展建立上下左右的良好关系 11.获取资源              时间管理：1.遵守考勤——按时上下班 2.按时完成任务-通常是短期的时间安排      时间管理：1.年度时间计划——时间安排、项目进度 2.与下属沟通的专门时间-一是自己的需要，二是下属的需要 3.为部门和团队工作设定时间方面的优先次序 4.与其他部门和团队工作设定时间方面的优先次序 5.与其他部门、客户和供应商沟通的时间              工作理念：1.通过个人能力完成任务 2.高质量的技术或专业化工作 3.遵循公司的价值观      工作理念：1.通过他人完成任务 2.下属员工的成功 3.管理性工作和修养 4.部门的成功 5.像一位真正的管理者 6.正直诚实            界定和布置工作，包括与上司、员工沟通，需要他们做什么，以及工作计划、组织结构、人员选拔和授权工作    通过监督、指导、反馈、获取资源、解决问题和交流沟通，提高下属的胜任能力，从而高效开展工作    建立与下属、上司和相关部门坦率交流与相互信任的合作关系  第二阶段  从管理他人到管理经理人员，关键的领导技能是教练选拔人才担任一线经理。          选拔人才担任一线经理      分配管理工作      评估下属经理及教练辅导      考虑全局性战略问题，积极给予支持        第三阶段              从管理经理人员到管理职能部门，需要学会新的沟通技巧以跨越两个层级与员工进行沟通          管理自身专业以外的其他工作      一方面与其他部门团结协作，另一方面基于工作需要与其他部门争夺资源      擅长制定战略，不仅为自己部门，而且统筹整个业务部门的战略规划      会议繁多，适当授权下属经理      制定职能战略，确保业务领先对手，开发创新性产品或开拓新渠道        第四阶段              从管理职能部门到事业部总经理，重点是转变思考方式，从赢利和长远发展的角度评估计划和方案。          管理不同的部门、各方面人员协同合作、高效地与各方面人员沟通、敏锐地意识到各部门利益      平衡近期与长远目标，季度利润、市场目标、产品计划和人员管理目标      指导和激励财务部、人力资源部、法务部和其他支持性部门      获得各部门经理的信任、建议和反馈        第五阶段              从事业部总经理到集团高管，必须擅长评估资金调拨和人员配置的战略规划。          擅长评估资金调拨和人员配置的战略规划              学会正确的提问      有效的分析数据      从公司角度分析战略可行性      - 培养事业部总经理      - 评估业务的投资组合策略      有合适的业务群？      确保盈利需增加什么业务？      削减业务哪项？      调整哪项业务？      - 精于评估自己的核心能力，采取冷静客观的态度，评估手中的资源，基于分析和经验做出判断      - 须有开放、善于学习的思维，做好在这个岗位长期工作的准备        第六阶段              从集团高管到首席执行官，必须具有重视外部关系的视角。          更多的集中在经营理念方面      是远大抱负的思想者，善于建立公司运行机制，推动公司实现各季度业绩目标，确保长期战略目标的实现      适应和掌握权衡取舍，具备重视外部关系的视角      抓大放小，聚焦公司全局性事务      团结重用优秀人才，激励公司全体人员      "
},

{
"title": "Spring Boot 整合 TkMyBatis",
"url": "/posts/Spring-Boot-%E6%95%B4%E5%90%88-TkMyBatis/",
"categories": "Spring Boot",
"tags": "Spring Boot, Spring Boot整合 TkMyBatis, MyBatis",
"date": "2019-10-11 10:39:06 +0800",







"snippet": "Spring Boot 整合 TkMyBatis什么是 TkMyBatis  tk.mybatis 是在 MyBatis 框架的基础上提供了很多工具，让开发更加高效POM在pom.xml文件中引入mapper-spring-boot-starter依赖，该依赖会自动引入MyBaits相关依赖&lt;dependency&gt;    &lt;groupId&gt;tk.mybatis&lt;...",
"content": "Spring Boot 整合 TkMyBatis什么是 TkMyBatis  tk.mybatis 是在 MyBatis 框架的基础上提供了很多工具，让开发更加高效POM在pom.xml文件中引入mapper-spring-boot-starter依赖，该依赖会自动引入MyBaits相关依赖&lt;dependency&gt;    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;    &lt;artifactId&gt;mapper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;2.1.5&lt;/version&gt;&lt;/dependency&gt;application.ymlmybatis:    # 实体类的存放路径    type-aliases-package: com.funtl.hello.spring.boot.domain    mapper-locations: classpath:mapper/*.xml创建通用父级接口主要作用是让DAO层的接口继承该接口，以达到使用tk.mybatis的目的package tk.mybatis.mapper;import tk.mybatis.mapper.common.Mapper;import tk.mybatis.mapper.common.MySqlMapper;/** * 自己的 Mapper * 特别注意，该接口不能被扫描到，否则会出错 * &lt;p&gt;Title: MyMapper&lt;/p&gt; * &lt;p&gt;Description: &lt;/p&gt; * * @author Lusifer * @version 1.0.0 * @date 2018/5/29 0:57 */public interface MyMapper&lt;T&gt; extends Mapper&lt;T&gt;, MySqlMapper&lt;T&gt; {}什么是 PageHelper  PageHelper 是 Mybatis 的分页插件，支持多数据库、多数据源。可以简化数据库的分页查询操作，整合过程也极其简单，只需引入依赖即可。POM&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper-spring-boot-starter&lt;/artifactId&gt;    &lt;version&gt;1.2.12&lt;/version&gt;&lt;/dependency&gt;代码生成插件在 pom.xml 文件中增加 mybatis-generator-maven-plugin 插件&lt;build&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt;            &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt;            &lt;version&gt;1.3.7&lt;/version&gt;            &lt;configuration&gt;                &lt;configurationFile&gt;${basedir}/src/main/resources/generator/generatorConfig.xml&lt;/configurationFile&gt;                &lt;overwrite&gt;true&lt;/overwrite&gt;                &lt;verbose&gt;true&lt;/verbose&gt;            &lt;/configuration&gt;            &lt;dependencies&gt;                &lt;dependency&gt;                    &lt;groupId&gt;mysql&lt;/groupId&gt;                    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                    &lt;version&gt;${mysql.version}&lt;/version&gt;                &lt;/dependency&gt;                &lt;dependency&gt;                    &lt;groupId&gt;tk.mybatis&lt;/groupId&gt;                    &lt;artifactId&gt;mapper&lt;/artifactId&gt;                    &lt;version&gt;4.1.5&lt;/version&gt;                &lt;/dependency&gt;            &lt;/dependencies&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/build&gt;  注意： configurationFile 自动生成所需的配置文件路径自动生成的配置在 src/main/resources/generator/ 目录下创建 generatorConfig.xml 配置文件：&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration        PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\"        \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;generatorConfiguration&gt;    &lt;!-- 引入数据库连接配置 --&gt;    &lt;properties resource=\"jdbc.properties\"/&gt;    &lt;context id=\"Mysql\" targetRuntime=\"MyBatis3Simple\" defaultModelType=\"flat\"&gt;        &lt;property name=\"beginningDelimiter\" value=\"`\"/&gt;        &lt;property name=\"endingDelimiter\" value=\"`\"/&gt;        &lt;!-- 配置 tk.mybatis 插件 --&gt;        &lt;plugin type=\"tk.mybatis.mapper.generator.MapperPlugin\"&gt;            &lt;property name=\"mappers\" value=\"com.funtl.utils.MyMapper\"/&gt;        &lt;/plugin&gt;        &lt;!-- 配置数据库连接 --&gt;        &lt;jdbcConnection                driverClass=\"${jdbc.driverClass}\"                connectionURL=\"${jdbc.connectionURL}\"                userId=\"${jdbc.username}\"                password=\"${jdbc.password}\"&gt;        &lt;/jdbcConnection&gt;        &lt;!-- 配置实体类存放路径 --&gt;        &lt;javaModelGenerator targetPackage=\"com.funtl.hello.spring.boot.domain\" targetProject=\"src/main/java\"/&gt;        &lt;!-- 配置 XML 存放路径 --&gt;        &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\"src/main/resources\"/&gt;        &lt;!-- 配置 DAO 存放路径 --&gt;        &lt;javaClientGenerator                targetPackage=\"com.funtl.hello.spring.boot.mapper\"                targetProject=\"src/main/java\"                type=\"XMLMAPPER\"/&gt;        &lt;!-- 配置需要指定生成的数据库和表，% 代表所有表 --&gt;        &lt;table catalog=\"myshop\" tableName=\"%\"&gt;            &lt;!-- 默认为 false，如果设置为 true，在生成的 SQL 中，table 名字不会加上 catalog 或 schema --&gt;            &lt;property name=\"ignoreQualifiersAtRuntime\" value=\"true\"/&gt;            &lt;!-- mysql 配置 --&gt;            &lt;generatedKey column=\"id\" sqlStatement=\"Mysql\" identity=\"true\"/&gt;        &lt;/table&gt;    &lt;/context&gt;&lt;/generatorConfiguration&gt;配置数据源在 src/main/resources 目录下创建 jdbc.properties 数据源配置：jdbc.driverClass=com.mysql.cj.jdbc.Driverjdbc.connectionURL=jdbc:mysql://192.168.141.130:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456插件自动生成```shell scriptmvn mybatis-generator:generate## 附：扩展阅读### 完整配置案例&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;&lt;!DOCTYPE generatorConfiguration  PUBLIC “-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN”“http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd”&gt;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               ```"
},

{
"title": "Spring Boot 整合 HikariCP",
"url": "/posts/Spring-Boot-%E6%95%B4%E5%90%88-HikariCP/",
"categories": "Spring Boot",
"tags": "Spring Boot, Spring Boot整合 HikariCP",
"date": "2019-10-10 10:39:06 +0800",







"snippet": "Spring Boot 整合 HikariCP什么是 HikariCP  HiKariCP 是数据库连接池的一个后起之秀，号称性能最好，可以完美地 PK 掉其他连接池。是一个高性能的 JDBC 连接池，基于 BoneCP 做了不少的改进和优化。超快，快到连 Spring Boot 2 都宣布支持了。官方 GitHub 地址什么是 BoneCP传说中 BoneCP 在快速这个特点上做到了极致，...",
"content": "Spring Boot 整合 HikariCP什么是 HikariCP  HiKariCP 是数据库连接池的一个后起之秀，号称性能最好，可以完美地 PK 掉其他连接池。是一个高性能的 JDBC 连接池，基于 BoneCP 做了不少的改进和优化。超快，快到连 Spring Boot 2 都宣布支持了。官方 GitHub 地址什么是 BoneCP传说中 BoneCP 在快速这个特点上做到了极致，官方数据是 C3P0 等的 25 倍左右。为什么需要 HikariCP  BoneCP 作者放弃维护，并在 Github 项目主页推荐大家使用 HikariCP，Hikari（ひかり[shi ga li]） 来自日文，是 光 的意思。这个产品的口号是 快速、简单、可靠优化  字节码精简 ： 优化代码，直到编译后的字节码最少，这样，CPU 缓存可以加载更多的程序代码  优化代理和拦截器 ： 减少代码，例如 HikariCP 的 Statement proxy 只有 100 行代码，只有 BoneCP 的十分之一  自定义数组类型（FastStatementList）代替 ArrayList ： 避免每次 get() 调用都要进行 range check，避免调用 remove() 时的从头到尾的扫描  自定义集合类型（ConcurrentBag）： 提高并发读写的效率  其他针对 BoneCP 缺陷的优化： 比如对于耗时超过一个 CPU 时间片的方法调用的研究（但没说具体怎么优化）代码量几个连接池的代码量对比（代码量越少，一般意味着执行效率越高、发生 BUG 的可能性越低）            Pool      Files      Code                  Vibur      34      1927              HikariCP      21      2228              Tomcat      31      6345              BoneCP      49      7293              C3P0      120      15550      可靠性另外，关于可靠性方面，也是有实验和数据支持的。对于数据库连接中断的情况，通过测试 getConnection()，各种 CP 的不相同处理方法如下（所有 CP 都配置了跟 connectionTimeout 类似的参数为 5 秒钟）  HikariCP(A)： 等待 5 秒钟后，如果连接还是没有恢复，则抛出一个 SQLExceptions 异常；后续的 getConnection() 也是一样处理  C3P0(C-)： 完全没有反应，没有提示，也不会在 CheckoutTimeout 配置的时长超时后有任何通知给调用者；然后等待 2 分钟后终于醒来了，返回一个 error  Tomcat(F)： 返回一个 connection，然后调用者如果利用这个无效的 connection 执行 SQL 语句 结果可想而知；大约 55 秒之后终于醒来了，这时候的 getConnection() 终于可以返回一个 error，但没有等待参数配置的 5 秒钟，而是立即返回 error  BoneCP(C)： 跟 Tomcat 的处理方法一样；也是大约 55 秒之后才醒来，有了正常的反应，并且终于会等待 5 秒钟之后返回 error 了整合 HikariCPpom&lt;!-- 主要增加 HikariCP 依赖 --&gt;&lt;dependency&gt;    &lt;groupId&gt;com.zaxxer&lt;/groupId&gt;    &lt;artifactId&gt;HikariCP&lt;/artifactId&gt;    &lt;version&gt;${hikaricp.version}&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;    &lt;exclusions&gt;        &lt;!-- 排除 tomcat-jdbc 以使用 HikariCP --&gt;        &lt;exclusion&gt;            &lt;groupId&gt;org.apache.tomcat&lt;/groupId&gt;            &lt;artifactId&gt;tomcat-jdbc&lt;/artifactId&gt;        &lt;/exclusion&gt;    &lt;/exclusions&gt;&lt;/dependency&gt;&lt;!-- MySQL 驱动 --&gt;&lt;dependency&gt;    &lt;groupId&gt;mysql&lt;/groupId&gt;    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;    &lt;version&gt;${mysql.version}&lt;/version&gt;&lt;/dependency&gt;application.ymlspring:  datasource:    type: com.zaxxer.hikari.HikariDataSource    driver-class-name: com.mysql.cj.jdbc.Driver    url: jdbc:mysql://192.168.141.130:3306/myshop?useUnicode=true&amp;characterEncoding=utf-8&amp;useSSL=false    username: root    password: 123456    hikari:      minimum-idle: 5      idle-timeout: 600000      maximum-pool-size: 10      auto-commit: true      pool-name: MyHikariCP      max-lifetime: 1800000      connection-timeout: 30000      connection-test-query: SELECT 1"
},

{
"title": "Spring Boot 单元测试",
"url": "/posts/Spring-Boot-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
"categories": "Spring Boot",
"tags": "Spring Boot, Spring Boot单元测试",
"date": "2019-10-09 10:39:06 +0800",







"snippet": "Spring Boot 单元测试概述  主要是通过 @RunWith 和 @SpringBootTest 注解来开启单元测试功能创建测试类package com.tangyuewei.hello.spring.boot;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import or...",
"content": "Spring Boot 单元测试概述  主要是通过 @RunWith 和 @SpringBootTest 注解来开启单元测试功能创建测试类package com.tangyuewei.hello.spring.boot;import org.junit.Before;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.test.context.SpringBootTest;import org.springframework.boot.test.web.client.TestRestTemplate;import org.springframework.boot.web.server.LocalServerPort;import org.springframework.http.ResponseEntity;import org.springframework.test.context.junit4.SpringRunner;import java.net.URL;import static org.hamcrest.CoreMatchers.equalTo;import static org.junit.Assert.assertThat;@RunWith(SpringRunner.class)@SpringBootTest(classes = HelloSpringBootApplication.class, webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)public class HelloSpringBootApplicationTests {    @LocalServerPort    private int port;    private URL base;    @Autowired    private TestRestTemplate template;    @Before    public void setUp() throws Exception {        this.base = new URL(\"http://localhost:\" + port + \"/\");    }    @Test    public void contextLoads() {        ResponseEntity&lt;String&gt; response = template.getForEntity(base.toString(), String.class);        assertThat(response.getBody(), equalTo(\"Hello Spring Boot\"));    }}  运行它会先启动 Spring Boot 工程，再启动单元测试"
},

{
"title": "Spring Boot 常用配置",
"url": "/posts/Spring-Boot-%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE/",
"categories": "Spring Boot",
"tags": "Spring Boot, Spring Boot配置",
"date": "2019-10-08 10:39:06 +0800",







"snippet": "Spring Boot 简介概述Spring Boot 可以称之为新一代 JavaEE开发标准；随着动态语言的流行 (Ruby、Groovy、Scala、Node.js)，Java 的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。在上述环境下，Spring Boot 应运而生。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置...",
"content": "Spring Boot 简介概述Spring Boot 可以称之为新一代 JavaEE开发标准；随着动态语言的流行 (Ruby、Groovy、Scala、Node.js)，Java 的开发显得格外的笨重：繁多的配置、低下的开发效率、复杂的部署流程以及第三方技术集成难度大。在上述环境下，Spring Boot 应运而生。它使用“习惯优于配置”（项目中存在大量的配置，此外还内置了一个习惯性的配置，让你无需手动进行配置）的理念让你的项目快速的运行起来。使用 Spring Boot 很容易创建一个独立运行（运行 Jar，内嵌 Servlet 容器）准生产级别的基于 Spring 框架的项目，使用 Spring Boot 你可以不用或者只需很少的 Spring 配置。Spring 简史Spring 1.x 时代在 Spring1.x 时代，都是通过 xml 文件配置 bean，随着项目的不断扩大，需要将 xml 配置分放到不同的配置文件中，需要频繁的在 java 类和 xml 配置文件中切换。Spring 2.x 时代随着 JDK 1.5 带来的注解支持，Spring2.x 可以使用注解对 Bean 进行申明和注入，大大的减少了 xml 配置文件，同时也大大简化了项目的开发。那么，问题来了，究竟是应该使用 xml 还是注解呢？最佳实践：  应用的基本配置用 xml，比如：数据源、资源文件等  业务开发用注解，比如：Service 中注入 bean 等Spring 3.x 时代从 Spring3.x 开始提供了 Java 配置方式，使用 Java 配置方式可以更好的理解你配置的 Bean，现在我们就处于这个时代，并且 Spring4.x 和 Spring boot 都推荐使用 java 配置的方式。Spring 5.x 时代Spring5.x 是 Java 界首个支持响应式的 Web 框架，是 Spring 的一个重要版本，距离 Spring4.x 差不多四年。在此期间，大多数增强都是在 Spring Boot 项目中完成的，其最大的亮点就是提供了完整的端到端响应式编程的支持（新增 Spring WebFlux 模块）。Spring WebFlux 同时支持使用旧的 Spring MVC 注解声明Reactive Controller。和传统的MVC Controller不同，Reactive Controller 操作的是非阻塞的ServerHttpRequest和ServerHttpResponse，而不再是Spring MVC里的HttpServletRequest和HttpServletResponse。至此也代表着 Java 正式迎来了响应式异步编程的时代。Spring Boot 优缺点优点  快速构建项目  对主流开发框架的无配置集成  项目可独立运行，无需外部依赖 Servlet 容器  提供运行时的应用监控  极大地提高了开发、部署效率  与云计算的天然集成缺点  版本迭代速度很快，一些模块改动很大  由于不用自己做配置，报错时很难定位Spring Boot 常用配置概述  本章节主要介绍一下 Spring Boot 中的一些常用配置，比如：自定义 Banner、配置日志、关闭特定的自动配置等。自定义 Banner在 Spring Boot 启动的时候会有一个默认的启动图案  .   ____          _            __ _ _ /\\\\ / ___'_ __ _ _(_)_ __  __ _ \\ \\ \\ \\( ( )\\___ | '_ | '_| | '_ \\/ _` | \\ \\ \\ \\ \\\\/  ___)| |_)| | | | | || (_| |  ) ) ) )  '  |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot ::        (v2.1.6.RELEASE)我们在 src/main/resources 目录下新建一个 banner.txt通过 http://patorjk.com/software/taag 网站生成字符串，将网站生成的字符复制到 banner.txt 中再次运行这个程序常用属性设置：  ${AnsiColor.BRIGHT_RED}：设置控制台中输出内容的颜色  ${application.version}：用来获取 MANIFEST.MF 文件中的版本号  ${application.formatted-version}：格式化后的 ${application.version} 版本信息  ${spring-boot.version}：Spring Boot 的版本号  ${spring-boot.formatted-version}：格式化后的 ${spring-boot.version} 版本信息配置文件Spring Boot 项目使用一个全局的配置文件 application.properties 或者是 application.yml，在 resources 目录下或者类路径下的 /config 下，一般我们放到 resources 下。修改 Tomcat 的端口为 9090，并将默认的访问路径 “/” 修改为 “boot”，可以在 application.properties 中添加：server.port=9090server.context-path=/boot或在 application.yml 中添加：server:  port: 9090  context-path: /boot更多配置Starter POM  Spring Boot 为我们提供了简化企业级开发绝大多数场景的 starter pom ，只要使用了应用场景所需要的 starter pom ，相关的技术配置将会消除，就可以得到 Spring Boot 为我们提供的自动配置的 Bean。更多 Starter POM日志配置Spring Boot 对各种日志框架都做了支持，我们可以通过配置来修改默认的日志的配置默认情况下，Spring Boot 使用 Logback 作为日志框架logging:  file: ../logs/spring-boot-hello.log  level.org.springframework.web: DEBUG关闭特定的自动配置关闭特定的自动配置使用 @SpringBootApplication 注解的 exclude 参数即可，这里以关闭数据源的自动配置为例@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})"
},

{
"title": "适配器设计模式",
"url": "/posts/%E9%80%82%E9%85%8D%E5%99%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
"categories": "设计模式",
"tags": "适配器模式, 设计模式",
"date": "2019-08-12 10:39:06 +0800",







"snippet": "适配器模式概念  将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  应用场景      电源适配器将 220V 转化为 5V    在 LINUX 上运行 WINDOWS 程序    让播放器支持更多的媒体格式播放      实现案例              为媒体播放器和更高级的媒体播放器创建接口          pub...",
"content": "适配器模式概念  将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。  应用场景      电源适配器将 220V 转化为 5V    在 LINUX 上运行 WINDOWS 程序    让播放器支持更多的媒体格式播放      实现案例              为媒体播放器和更高级的媒体播放器创建接口          public interface MediaPlayer {public void play(String audioType, String fileName);}                          AdvancedMediaPlayer接口：          public interface AdvancedMediaPlayer {public void playVlc(String fileName);public void playMp4(String fileName);}                          创建实现了 AdvancedMediaPlayer 接口的实现类。```javapublic class VlcPlayer implements AdvancedMediaPlayer{@Overridepublic void playVlc(String fileName) { System.out.println(“Playing vlc file. Name: “+ fileName);}            @Override   public void playMp4(String fileName) {      //什么也不做   }}- Mp4Player类：``` javapublic class Mp4Player implements AdvancedMediaPlayer{   @Override   public void playVlc(String fileName) {      //什么也不做   }   @Override   public void playMp4(String fileName) {      System.out.println(\"Playing mp4 file. Name: \"+ fileName);   }}  创建实现了 MediaPlayer 接口的适配器类。    public class MediaAdapter implements MediaPlayer { AdvancedMediaPlayer advancedMusicPlayer; public MediaAdapter(String audioType){    if(audioType.equalsIgnoreCase(\"vlc\") ){       advancedMusicPlayer = new VlcPlayer();    } else if (audioType.equalsIgnoreCase(\"mp4\")){       advancedMusicPlayer = new Mp4Player();    } } @Override public void play(String audioType, String fileName) {    if(audioType.equalsIgnoreCase(\"vlc\")){       advancedMusicPlayer.playVlc(fileName);    }else if(audioType.equalsIgnoreCase(\"mp4\")){       advancedMusicPlayer.playMp4(fileName);    } }}        创建实现了 MediaPlayer 接口的实体类。    public class AudioPlayer implements MediaPlayer { MediaAdapter mediaAdapter; @Override public void play(String audioType, String fileName) {    //播放 mp3 音乐文件的内置支持    if(audioType.equalsIgnoreCase(\"mp3\")){       System.out.println(\"Playing mp3 file. Name: \"+ fileName);    }    //mediaAdapter 提供了播放其他文件格式的支持    else if(audioType.equalsIgnoreCase(\"vlc\")       || audioType.equalsIgnoreCase(\"mp4\")){       mediaAdapter = new MediaAdapter(audioType);       mediaAdapter.play(audioType, fileName);    }    else{       System.out.println(\"Invalid media. \"+          audioType + \" format not supported\");    } }}        使用 AudioPlayer 来播放不同类型的音频格式。    public class AdapterPatternDemo { public static void main(String[] args) {    AudioPlayer audioPlayer = new AudioPlayer();    audioPlayer.play(\"mp3\", \"beyond the horizon.mp3\");    audioPlayer.play(\"mp4\", \"alone.mp4\");    audioPlayer.play(\"vlc\", \"far far away.vlc\");    audioPlayer.play(\"avi\", \"mind me.avi\"); }}      "
},

{
"title": "责任链设计模式",
"url": "/posts/%E8%B4%A3%E4%BB%BB%E9%93%BE%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
"categories": "设计模式",
"tags": "责任链模式, 设计模式",
"date": "2019-08-08 10:39:06 +0800",







"snippet": "责任链模式概念  避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。  应用场景      有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定    在不明确指定接收者的情况下，向多个对象中的一个提交一个请求    可动态指定一组对象处理请求      实现案例              创...",
"content": "责任链模式概念  避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。  应用场景      有多个对象可以处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定    在不明确指定接收者的情况下，向多个对象中的一个提交一个请求    可动态指定一组对象处理请求      实现案例              创建抽象的记录器类。``` javapublic abstract class AbstractLogger {public static int INFO = 1;public static int DEBUG = 2;public static int ERROR = 3;            protected int level;//责任链中的下一个元素   protected AbstractLogger nextLogger;public void setNextLogger(AbstractLogger nextLogger){      this.nextLogger = nextLogger;   }public void logMessage(int level, String message){      if(this.level &lt;= level){         write(message);      }      if(nextLogger !=null){         nextLogger.logMessage(level, message);      }   }abstract protected void write(String message);}- 创建扩展了该记录器类的实体类。``` javapublic class ConsoleLogger extends AbstractLogger {   public ConsoleLogger(int level){      this.level = level;   }   @Override   protected void write(String message) {      System.out.println(\"Standard Console::Logger: \" + message);   }}  ErrorLogger类：    public class ErrorLogger extends AbstractLogger { public ErrorLogger(int level){    this.level = level; } @Override protected void write(String message) {    System.out.println(\"Error Console::Logger: \" + message); }}        FileLogger类：    public class FileLogger extends AbstractLogger { public FileLogger(int level){    this.level = level; } @Override protected void write(String message) {    System.out.println(\"File::Logger: \" + message); }}        创建不同类型的记录器。    public class ChainPatternDemo { private static AbstractLogger getChainOfLoggers(){    AbstractLogger errorLogger = new ErrorLogger(AbstractLogger.ERROR);    AbstractLogger fileLogger = new FileLogger(AbstractLogger.DEBUG);    AbstractLogger consoleLogger = new ConsoleLogger(AbstractLogger.INFO);    errorLogger.setNextLogger(fileLogger);    fileLogger.setNextLogger(consoleLogger);    return errorLogger; } public static void main(String[] args) {    AbstractLogger loggerChain = getChainOfLoggers();    loggerChain.logMessage(AbstractLogger.INFO, \"This is an information.\");    loggerChain.logMessage(AbstractLogger.DEBUG,       \"This is a debug level information.\");    loggerChain.logMessage(AbstractLogger.ERROR,       \"This is an error information.\"); }}      "
},

{
"title": "观察者设计模式",
"url": "/posts/%E8%A7%82%E5%AF%9F%E8%80%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
"categories": "设计模式",
"tags": "观察者模式, 设计模式",
"date": "2019-08-02 10:39:06 +0800",







"snippet": "观察者模式概念  定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  应用场景      日志记录器:用户可以选择日志存储到什么地方    数据库访问:用户可以选择数据库    设计一个连接服务器的框架      实现案例              创建 Subject 类。``` javapublic class Subject { ...",
"content": "观察者模式概念  定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。  应用场景      日志记录器:用户可以选择日志存储到什么地方    数据库访问:用户可以选择数据库    设计一个连接服务器的框架      实现案例              创建 Subject 类。``` javapublic class Subject {            private List observers      = new ArrayList();   private int state;public int getState() {      return state;   }public void setState(int state) {      this.state = state;      notifyAllObservers();   }public void attach(Observer observer){      observers.add(observer);   }public void notifyAllObservers(){      for (Observer observer : observers) {         observer.update();      }   }}- 创建 Observer 类。``` javapublic abstract class Observer {   protected Subject subject;   public abstract void update();}  创建实体观察者类。    public class BinaryObserver extends Observer{ public BinaryObserver(Subject subject){    this.subject = subject;    this.subject.attach(this); } @Override public void update() {    System.out.println( \"Binary String: \"    + Integer.toBinaryString( subject.getState() ) ); }}        OctalObserver类：    public class OctalObserver extends Observer{ public OctalObserver(Subject subject){    this.subject = subject;    this.subject.attach(this); } @Override public void update() {   System.out.println( \"Octal String: \"   + Integer.toOctalString( subject.getState() ) ); }}        HexaObserver类：    public class HexaObserver extends Observer{ public HexaObserver(Subject subject){    this.subject = subject;    this.subject.attach(this); } @Override public void update() {    System.out.println( \"Hex String: \"    + Integer.toHexString( subject.getState() ).toUpperCase() ); }}        使用 Subject 和实体观察者对象。    public class ObserverPatternDemo { public static void main(String[] args) {    Subject subject = new Subject();    new HexaObserver(subject);    new OctalObserver(subject);    new BinaryObserver(subject);    System.out.println(\"First state change: 15\");    subject.setState(15);    System.out.println(\"Second state change: 10\");    subject.setState(10); }}      "
},

{
"title": "工厂设计模式",
"url": "/posts/%E5%B7%A5%E5%8E%82%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
"categories": "设计模式",
"tags": "工厂模式, 设计模式",
"date": "2019-07-12 10:39:06 +0800",







"snippet": "工厂模式概念  定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。  应用场景      日志记录器:用户可以选择日志存储到什么地方    数据库访问:用户可以选择数据库    设计一个连接服务器的框架      实现案例        创建一个接口:    public interface Shape { void draw();}      ...",
"content": "工厂模式概念  定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。  应用场景      日志记录器:用户可以选择日志存储到什么地方    数据库访问:用户可以选择数据库    设计一个连接服务器的框架      实现案例        创建一个接口:    public interface Shape { void draw();}        创建接口的实现    public class Rectangle implements Shape { @Override public void draw() {    System.out.println(\"Rectangle method.\"); }}        public class Square implements Shape { @Override public void draw() {    System.out.println(\"Square method.\"); }}        public class Circle implements Shape { @Override public void draw() {    System.out.println(\"Circle method.\"); }}        创建一个工厂，生成基于给定信息的实体类的对象    public class ShapeFactory { //使用 getShape 方法获取形状类型的对象 public Shape getShape(String shapeType){    if(shapeType == null){       return null;    }    if(shapeType.equalsIgnoreCase(\"CIRCLE\")){       return new Circle();    } else if(shapeType.equalsIgnoreCase(\"RECTANGLE\")){       return new Rectangle();    } else if(shapeType.equalsIgnoreCase(\"SQUARE\")){       return new Square();    }    return null; }}        调用该工厂，通过传递类型信息来获取实现。    public class FactoryDemo { public static void main(String[] args) {    ShapeFactory shapeFactory = new ShapeFactory();    //获取 Circle 的对象，并调用它的 draw 方法    Shape shape1 = shapeFactory.getShape(\"CIRCLE\");    //调用 Circle 的 draw 方法    shape1.draw();    //获取 Rectangle 的对象，并调用它的 draw 方法    Shape shape2 = shapeFactory.getShape(\"RECTANGLE\");    //调用 Rectangle 的 draw 方法    shape2.draw();    //获取 Square 的对象，并调用它的 draw 方法    Shape shape3 = shapeFactory.getShape(\"SQUARE\");    //调用 Square 的 draw 方法    shape3.draw(); }}      "
},

{
"title": "单例设计模式",
"url": "/posts/%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
"categories": "设计模式",
"tags": "单例模式, 设计模式",
"date": "2019-06-05 10:39:06 +0800",







"snippet": "单例模式概念  一个类只能有一个实例  由自己创建的唯一实例  给其他对象提供这一实例    应用场景          建立数据库连接      计数器      唯一序列号        实现案例              类加载时初始化,多线程安全     public class Singleton {   private static Singleton instance = ne...",
"content": "单例模式概念  一个类只能有一个实例  由自己创建的唯一实例  给其他对象提供这一实例    应用场景          建立数据库连接      计数器      唯一序列号        实现案例              类加载时初始化,多线程安全     public class Singleton {   private static Singleton instance = new Singleton();   private Singleton (){}   public static Singleton getInstance() {   return instance;   } }        初始化懒加载模式，多线程安全    public class Singleton {  private static class SingletonHolder {  private static final Singleton INSTANCE = new Singleton();  }  private Singleton (){}  public static final Singleton getInstance() {  return SingletonHolder.INSTANCE;  }}        防止反序列化重新创建的枚举类型,多线程安全    public enum Singleton {  INSTANCE;  public void method() {  }}        初始化懒加载，双锁机制，多线程情况下能保持高性能    public class Singleton {  private volatile static Singleton singleton;  private Singleton (){}  public static Singleton getSingleton() {  if (singleton == null) {      synchronized (Singleton.class) {      if (singleton == null) {          singleton = new Singleton();      }      }  }  return singleton;  }}      "
},

{
"title": "代理设计模式",
"url": "/posts/%E4%BB%A3%E7%90%86%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/",
"categories": "设计模式",
"tags": "设计模式",
"date": "2019-05-13 10:39:06 +0800",







"snippet": "代理模式概念  为其他对象提供一种代理以控制对这个对象的访问。  应用场景      Windows 的快捷方式    网上购买电影票    spring aop      实现案例              创建一个接口。          public interface Image {void display();}                          创建实现接口的类。...",
"content": "代理模式概念  为其他对象提供一种代理以控制对这个对象的访问。  应用场景      Windows 的快捷方式    网上购买电影票    spring aop      实现案例              创建一个接口。          public interface Image {void display();}                          创建实现接口的类。```javapublic class RealImage implements Image {            private String fileName;public RealImage(String fileName){      this.fileName = fileName;      loadFromDisk(fileName);   }@Override   public void display() {      System.out.println(“Displaying “ + fileName);   }private void loadFromDisk(String fileName){      System.out.println(“Loading “ + fileName);   }}创建实现了 Image 接口的代理类。``` javapublic class ProxyImage implements Image{   private RealImage realImage;   private String fileName;   public ProxyImage(String fileName){      this.fileName = fileName;   }   @Override   public void display() {      if(realImage == null){         realImage = new RealImage(fileName);      }      realImage.display();   }}  当被请求时，使用 ProxyImage 来获取 RealImage 类的对象。    public class ProxyPatternDemo { public static void main(String[] args) {    Image image = new ProxyImage(\"test_10mb.jpg\");    // 图像将从磁盘加载    image.display();    System.out.println(\"\");    // 图像不需要从磁盘加载    image.display(); }}      "
},

{
"title": "Vue学习与使用",
"url": "/posts/Vue%E5%AD%A6%E4%B9%A0%E4%B8%8E%E4%BD%BF%E7%94%A8/",
"categories": "设计模式",
"tags": "软件设计原则",
"date": "2019-05-12 10:39:06 +0800",







"snippet": "Vue 渐进式 JavaScript 框架Node.js安装Node.js官网linux安装nodejsyum install -y nodejsnpm 缓存清理npm cache clean --force安装 Node.js 淘宝镜像加速器（cnpm）npm install cnpm -g# 或使用如下语句解决 npm 速度慢的问题npm install --registry=https...",
"content": "Vue 渐进式 JavaScript 框架Node.js安装Node.js官网linux安装nodejsyum install -y nodejsnpm 缓存清理npm cache clean --force安装 Node.js 淘宝镜像加速器（cnpm）npm install cnpm -g# 或使用如下语句解决 npm 速度慢的问题npm install --registry=https://registry.npm.taobao.org::: tip 提示尽可能使用npm install安装插件，使用cnpm install有可能下载的插件出现问题:::nodejs版本升级  首先，你得用npm全局安装一个管理node版本的管理模板n，关于n。安装命令npm i -g n::: tip  提示如果上述命令报错，则执行npm i -g n --force:::  升级到指定的版本n 版本号 如 n 10.0.0  安装最新的版本n latest  安装最近的稳定版本n stable  n模块是不支持window系统的，window系统升级node就只有到node官网下载window安装包来覆盖之前的node。Vue概述  Vue 是一套用于构建用户界面的渐进式框架，发布于 2014 年 2 月。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库（如：vue-router，vue-resource，vuex）或既有项目整合。MVVM 模式的实现者  Model：模型层，在这里表示 JavaScript 对象  View：视图层，在这里表示 DOM（HTML 操作的元素）  ViewModel：连接视图和数据的中间件，Vue.js 就是 MVVM 中的 ViewModel 层的实现者Vue.js优点与核心要素优点：  轻量级，体积小是一个重要指标。Vue.js 压缩后有只有 20多kb （Angular 压缩后 56kb+，React 压缩后 44kb+）  移动优先。更适合移动端，比如移动端的 Touch 事件  易上手，学习曲线平稳，文档齐全  吸取了 Angular（模块化）和 React（虚拟 DOM）的长处，并拥有自己独特的功能，如：计算属性  开源，社区活跃度高核心要素  数据驱动  每个组件实例都有相应的 watcher 实例对象，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的 setter 被调用时，会通知 watcher 重新计算，从而致使它关联的组件得以更新。  组件化  页面上每个独立的可交互的区域视为一个组件  每个组件对应一个工程目录，组件所需的各种资源在这个目录下就近维护  页面不过是组件的容器，组件可以嵌套自由组合（复用）形成完整的页面Vue 语法v-if,v-else-if,v-else&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;v-if&lt;/title&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;h1 v-if=\"ok === 'a'\"&gt;if&lt;/h1&gt;    &lt;h1 v-else-if=\"ok === 'b'\"&gt;else-if&lt;/h1&gt;    &lt;h1 v-else&gt;else&lt;/h1&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    let vm = new Vue({        el: '#app',        data: {            ok: 'a'        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;v-for&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;v-for&lt;/title&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;li v-for=\"item in items\"&gt;            &lt;/li&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    let vm = new Vue({        el: '#app',        data: {            items: [                {message: 'hello'},                {message: 'world'}            ]        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue 事件v-on&lt;!DOCTYPE html&gt;&lt;html xmlns:v-on=\"\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;事件 v-on&lt;/title&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;button v-on:click=\"say\"&gt;点击事件&lt;/button&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    let vm = new Vue({        el: '#app',        data: {            message: 'Hello World'        },        // 在 `methods` 对象中定义方法        methods: {            say: function (event) {                // `this` 在方法里指向当前 Vue 实例                alert(this.message);            }        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue 网络  使用 Axios 实现异步通信Axios 优点:  从浏览器中创建 XMLHttpRequests  从 node.js 创建 http 请求  支持 Promise API  拦截请求和响应  转换请求数据和响应数据  取消请求  自动转换 JSON 数据  客户端支持防御 XSRF（跨站请求伪造）  创建一个名为 data.json 的文件并填入内容{  \"name\": \"唐悦玮\",  \"url\": \"https://www.18xm.cn\",  \"address\": {    \"street\": \"华强北\",    \"city\": \"广东深圳\",    \"country\": \"中国\"  },  \"links\": [    {      \"name\": \"Google\",      \"url\": \"http://www.google.com\"    },    {      \"name\": \"Baidu\",      \"url\": \"http://www.baidu.com\"    }  ]}  创建 HTML&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;网络 Axios&lt;/title&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt;    &lt;script src=\"https://unpkg.com/axios/dist/axios.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    &lt;div&gt;名称：&lt;/div&gt;    &lt;div&gt;地址：--&lt;/div&gt;    &lt;div&gt;链接：&lt;a v-bind:href=\"info.url\" target=\"_blank\"&gt;&lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    let vm = new Vue({        el: '#app',        data() {            return {                info: {                    name: null,                    address: {                        country: null,                        city: null,                        street: null                    },                    url: null                }            }        },        mounted() {            axios                .get('data.json')                .then(response =&gt; (this.info = response.data));        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;Vue 布局表单表单中使用双向数据绑定:  用 v-model 指令在表单 &lt;input&gt;、&lt;textarea&gt; 及 &lt;select&gt; 元素上创建双向数据绑定。::: tip 提示v-model 会忽略所有表单元素的 value、checked、selected 特性的初始值而总是将 Vue 实例的数据作为数据来源。你应该通过 JavaScript 在组件的 data 选项中声明初始值。:::  单行文本``` html&lt;!DOCTYPE html&gt;        单行文本         单行文本：&nbsp;&nbsp;单行文本是：+ 多行文本``` html&lt;div id=\"app\"&gt;    多行文本：&lt;textarea v-model=\"message\"&gt;&lt;/textarea&gt;&amp;nbsp;&amp;nbsp;多行文本是：&lt;/div&gt;  单复选框&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;单复选框&lt;/title&gt;    &lt;script src=\"https://cdn.jsdelivr.net/npm/vue@2.5.21/dist/vue.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;div id=\"app\"&gt;    单复选框：&lt;input type=\"checkbox\" id=\"checkbox\" v-model=\"checked\"&gt;&amp;nbsp;&amp;nbsp;&lt;label for=\"checkbox\"&gt;&lt;/label&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    let vm = new Vue({        el: '#app',        data: {            checked: false        }    });&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;  多复选框&lt;div id=\"app\"&gt;    多复选框：    &lt;input type=\"checkbox\" id=\"jack\" value=\"Jack\" v-model=\"checkedNames\"&gt;    &lt;label for=\"jack\"&gt;Jack&lt;/label&gt;    &lt;input type=\"checkbox\" id=\"john\" value=\"John\" v-model=\"checkedNames\"&gt;    &lt;label for=\"john\"&gt;John&lt;/label&gt;    &lt;input type=\"checkbox\" id=\"mike\" value=\"Mike\" v-model=\"checkedNames\"&gt;    &lt;label for=\"mike\"&gt;Mike&lt;/label&gt;    &lt;span&gt;选中的值: &lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    let vm = new Vue({        el: '#app',        data: {            checkedNames: []        }    });&lt;/script&gt;  单选按钮&lt;div id=\"app\"&gt;    单选按钮：    &lt;input type=\"radio\" id=\"one\" value=\"One\" v-model=\"picked\"&gt;    &lt;label for=\"one\"&gt;One&lt;/label&gt;    &lt;input type=\"radio\" id=\"two\" value=\"Two\" v-model=\"picked\"&gt;    &lt;label for=\"two\"&gt;Two&lt;/label&gt;    &lt;span&gt;选中的值: &lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    let vm = new Vue({        el: '#app',        data: {            picked: ''        }    });&lt;/script&gt;  下拉框&lt;div id=\"app\"&gt;    下拉框：    &lt;select v-model=\"selected\"&gt;        &lt;option disabled value=\"\"&gt;请选择&lt;/option&gt;        &lt;option&gt;A&lt;/option&gt;        &lt;option&gt;B&lt;/option&gt;        &lt;option&gt;C&lt;/option&gt;    &lt;/select&gt;    &lt;span&gt;选中的值: &lt;/span&gt;&lt;/div&gt;&lt;script type=\"text/javascript\"&gt;    var vm = new Vue({        el: '#app',        data: {            selected: ''        }    });&lt;/script&gt;::: warning 提示如果 v-model 表达式的初始值未能匹配任何选项，&lt;select&gt; 元素将被渲染为“未选中”状态。在 iOS 中，这会使用户无法选择第一个选项。因为这样的情况下，iOS 不会触发 change 事件。因此，推荐像上面提供一个值为空的禁用选项。:::组件  组件是可复用的 Vue 实例，就是一组可以重复使用的模板实际开发中采用 vue-cli 创建 .vue 模板文件的方式开发  使用 Vue.component() 方法注册组件  使用 props 属性传递参数``` html                ## vue-cli### 什么是 vue-cli&gt; `vue-cli` 官方提供的一个脚手架（预先定义好的目录结构及基础代码，咱们在创建 Maven 项目时可以选择创建一个骨架项目，这个骨架项目就是脚手架；可以参考我以前写的 LeeSite 项目骨架生成工具），用于快速生成一个 vue 的项目模板+ 安装 vue-cli。`npm install vue-cli -g`+ 测试是否安装成功。`vue list`### vue-cli主要功能+ 统一的目录结构+ 本地调试+ 热部署+ 单元测试+ 集成打包上线### vue-cli初始化应用程序1. 创建一个基于 webpack 模板的 vue 应用程序：myvue 是项目名称，可自定义名称vue init webpack myvue2. 初始化说明：  + `project name`：项目名称，默认 回车 即可  + `project description`：项目描述，默认 回车 即可  + `author`：项目作者，默认 回车 即可  + `install vue-router`：是否安装 vue-router，选择 n 不安装（后期需要再手动添加）  + `use eslint to lint your code`：是否使用 `eslint` 做代码检查，选择 n 不安装（后期需要再手动添加）  + `set up unit tests`：单元测试相关，选择 n 不安装（后期需要再手动添加）  + `setup e2e tests with nightwatch`：单元测试相关，选择 n 不安装（后期需要再手动添加）  + `should we run npm install for you after the project has been created`：创建完成后直接初始化，选择 n，我们手动执行3. 运行程序cd myvuenpm installnpm run dev4. 安装并运行成功后在浏览器访问：http://localhost:8080## Webpack### Webpack 简介&gt; Webpack 是当下最热门的前端资源模块化管理和打包工具，它可以将许多松散耦合的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分离，等到实际需要时再异步加载。通过 loader 转换，任何形式的资源都可以当做模块，比如 CommonsJS、AMD、ES6、CSS、JSON、CoffeeScript、LESS 等；### Webpack 安装- 安装npm install webpack -gnpm install webpack-cli -g- 配置  创建 webpack.config.js 配置文件  + `entry`：入口文件，指定 WebPack 用哪个文件作为项目的入口  + `output`：输出，指定 WebPack 把处理完成的文件放置到指定路径  + `module`：模块，用于处理各种类型的文件  + `plugins`：插件，如：热更新、代码重用等  + `resolve`：设置路径指向  + `watch`：监听，用于设置文件改动后直接打包```javascriptmodule.exports = {    entry: \"\",    output: {        path: \"\",        filename: \"\"    },    module: {        loaders: [            {test: /\\.js$/, loader: \"\"}        ]    },    plugins: {},    resolve: {},    watch: true}  运行直接运行 webpack 命令打包vue-router 路由vue-router 概述Vue Router 是 Vue.js 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。包含的功能有：  嵌套的路由/视图表  模块化的、基于组件的路由配置  路由参数、查询、通配符  基于 Vue.js 过渡系统的视图过渡效果  细粒度的导航控制  带有自动激活的 CSS class 的链接  HTML5 历史模式或 hash 模式，在 IE9 中自动降级  自定义的滚动条行为    vue-router 安装    打开命令行工具，进入你的项目目录，输入下面命令。npm install vue-router --save-dev  "
},

{
"title": "软件设计原则",
"url": "/posts/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/",
"categories": "设计模式",
"tags": "软件设计原则",
"date": "2019-05-12 10:39:06 +0800",







"snippet": "七大原则开、口、合、里、最、单、依单一职责原则（Single Responsibility Principle）每一个类应该专注于做一件事情。里氏替换原则（Liskov Substitution Principle）超类存在的地方，子类是可以替换的。依赖倒置原则（Dependence Inversion Principle）实现尽量依赖抽象，不依赖具体实现。接口隔离原则（Interface ...",
"content": "七大原则开、口、合、里、最、单、依单一职责原则（Single Responsibility Principle）每一个类应该专注于做一件事情。里氏替换原则（Liskov Substitution Principle）超类存在的地方，子类是可以替换的。依赖倒置原则（Dependence Inversion Principle）实现尽量依赖抽象，不依赖具体实现。接口隔离原则（Interface Segregation Principle）应当为客户端提供尽可能小的单独的接口，而不是提供大的总的接口。迪米特法则（Law Of Demeter）又叫最少知识原则，一个软件实体应当尽可能少的与其他实体发生相互作用。开闭原则（Open Close Principle）面向扩展开放，面向修改关闭。组合/聚合复用原则（Composite/Aggregate Reuse Principle CARP）尽量使用合成/聚合达到复用，尽量少用继承。原则： 一个类中有另一个类的对象。"
},

{
"title": "Java类的加载机制与垃圾回收",
"url": "/posts/Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/",
"categories": "java",
"tags": "java, Java垃圾回收",
"date": "2019-03-02 10:39:06 +0800",







"snippet": "类的加载机制  加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载，7个阶段。其中验证、准备、解析3个部分统称为连接。加载  通过一个类的全限定名来获取类的二进制字节流。  将这个字节流所代表的静态储存结构转化为方法区的运行时数据结构。  内存中生成java.lang.Class对象（HotSpot中存于方法区），作为方法区这个类的各种数据的访问入口。...",
"content": "类的加载机制  加载-&gt;验证-&gt;准备-&gt;解析-&gt;初始化-&gt;使用-&gt;卸载，7个阶段。其中验证、准备、解析3个部分统称为连接。加载  通过一个类的全限定名来获取类的二进制字节流。  将这个字节流所代表的静态储存结构转化为方法区的运行时数据结构。  内存中生成java.lang.Class对象（HotSpot中存于方法区），作为方法区这个类的各种数据的访问入口。验证  这一阶段的目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全准备  为类的静态变量分配内存，并将其初始化为默认值。基本数据类型初始值为0,引用数据类型初始值为null解析  将类的二进制数据中的符号引用全部替换为直接引用。初始化  为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化      声明类变量是指定初始值    使用静态代码块为类变量指定初始值  GC（垃圾回收）回收算法标记清除算法  标记-清除算法（Mark-Sweep）是一种常见的基础垃圾收集算法,它将垃圾收集分为两个阶段:1.标记阶段 2.清除阶段效率低、回收的频率高复制算法  它把内存空间划为两个相等的区域，每次只使用其中一个区域。垃圾收集时，遍历当前使用的区域，把存活对象复制到另外一个区域中，最后将当前使用的区域的可回收的对象进行回收运行高效但可用的内存大小缩小了一半标记整理算法  标记可回收的对象后将所有存活的对象压缩到内存的一端，使他们紧凑的排列在一起，然后对端边界以外的内存进行回收。回收后，已用和未用的内存都各自一边比标记-清除算法运行效率高分代收集算法  根据对象的存活周期将内存划分为:年轻代、老年代 和 永久代  新生代（Young generation）          新生代中存在一个Eden区和两个Survivor区。新对象会首先分配在Eden中（如果新对象过大，会直接分配在老年代中）。在GC中，Eden中的对象会被移动到Survivor中，直至对象满足一定的年纪（定义为熬过GC的次数），会被移动到老年代        老年代（Old generation）          占用的空间要比新生代多,正由于其相对较大的空间，发生在老年代上的GC要比新生代要少得多。对象从老年代中消失的过程，可以称之为major GC（或者full GC）。        永久代（permanent generation）          几乎都是静态的并且很少被卸载和回收      垃圾回收器  垃圾收集器就是内存回收的具体实现  新生代回收器：Serial、ParNew、Parallel Scavenge  老年代回收器：Serial Old、Parallel Old、CMS  整堆回收器：G1###单线程垃圾回收器单CPU的环境下，它的垃圾清除效率比较高。  Serial          Serial 回收器是最基本的新生代垃圾回收器。采用的是-&gt;复制算法        Serial Old          Serial Old 回收器是Serial回收器的老生代版本。采用的是-&gt;标记整理算法      多线程垃圾回收器  ParNew          属于 Serial 回收器的多线程版本，同样运行在新生代区域。在不同运行环境下，根据CPU核数，开启不同的线程数。采用的是-&gt;复制算法        Parallel Scavenge          Parallel Scavenge 回收器也是运行在新生代区域，属于多线程的回收器。ParNew 回收器是通过控制垃圾回收的线程数来进行参数调整，更关心的是程序运行的吞吐量。采用的是-&gt;复制算法        Parallel Old          Parallel Scavenge 回收器的老生代版本，属于多线程回收器。考虑了 吞吐量优先 这一指标，非常适合那些 注重吞吐量 和 CPU 资源敏感 的场合。采用的是-&gt;标记整理算法      线程查看辅助工具jstack  jstack是java虚拟机自带的一种堆栈跟踪工具。jstack用于打印出给定的java进程ID或core file或远程调试服务的Java堆栈信息，如果是在64位机器上，需要指定选项”-J-d64”，Windows的jstack使用方式只支持以下的这种方式：jstack -l pid线程状态  NEW          线程刚刚被创建,但是还没有调用start()方法，jstack命令不会列出处于此状态的线程信息        RUNNABLE          线程是可运行的        BLOCKED          线程处于阻塞状态        WAITING          线程处于等待状态        TIMED_WAITING          线程等待指定的时间        TERMINATED          线程终止      jmap查看Java 堆（heap）使用情况jmap -heap pid将内存使用的详细情况输出到文件 jmap - dump  pidjconsole  Jconsole （Java Monitoring and Management Console），一种基于JMX的可视化监视、管理工具  点击JDK/bin 目录下面的jconsole.exe 即可启动  然后会自动自动搜索本机运行的所有虚拟机进程。  选择其中一个进程可开始进行监控"
},

{
"title": "JVM配置",
"url": "/posts/JVM%E9%85%8D%E7%BD%AE/",
"categories": "java",
"tags": "java, jvm",
"date": "2019-03-01 10:39:06 +0800",







"snippet": "Java内存模型概念  Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java内存模型的实现  在Java中提供了一些并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java...",
"content": "Java内存模型概念  Java内存模型即Java Memory Model，简称JMM。JMM定义了Java 虚拟机(JVM)在计算机内存(RAM)中的工作方式。JVM是整个计算机虚拟模型，所以JMM是隶属于JVM的。Java内存模型的实现  在Java中提供了一些并发处理相关的关键字，比如volatile、synchronized、final、concurren包等。其实这些就是Java内存模型封装了底层的实现后提供使用的一些关键字。JVM配置java.lang.OutOfMemoryError: Java heap space分析：这是最典型的内存泄漏方式，简单说就是所有堆空间都被无法回收的垃圾对象占满，虚拟机无法再在分配新空间  解决：这种方式解决起来也比较容易，一般就是根据垃圾回收前后情况对比，同时根据对象引用情况（常见的集合对象引用）分析，基本都可以找到泄漏点。java.lang.OutOfMemoryError: PermGen space-XX:PermSize=N //方法区 (永久代) 初始大小-XX:MaxPermSize=N //方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen分析：Perm空间被占满。无法为新的class分配存储空间而引发的异常。  解决：1. -XX:MaxPermSize=128m 2. 换用JDK。比如JRocket。java.lang.StackOverflowError分析：一般就是递归没返回，或者循环调用造成线程堆栈满  找到相关代码处理Fatal: Stack size too small分析：java中一个线程的空间大小是有限制的。  解决：增加线程栈大小。-Xss2m。但这个配置无法解决根本问题，还要看代码部分是否有造成泄漏的部分java.lang.OutOfMemoryError: unable to create new native thread分析：由于操作系统没有足够的资源来产生这个线程造成的。  解决：1. 重新设计系统减少线程数量。2. 线程数量不能减少的情况下，通过-Xss减小单个线程大小。以便能生产更多的线程。三种类型垃圾收集器  串行收集器Serial：Serial、Serial Old。单线程，适用于内存小的嵌入式设备。    -XX:+UseSerialGC -XX:+UseSerialOldGC        并行收集器Parallel：Paralel Scavenge、Parallel Old，吞吐量优先。    -XX:+UseParallelGC  -XX:+UseParallelOldGC        并发收集器Concurrent：CMS、G1，停顿时间优先。    CMS: XX:+UseConcMarkSweepGC -XX:UseParNewGCG1: -XX:UseG1GC                      优先调整堆的大小，让JVM自己来选择；        如果内存小于100M，使用串行收集器；        如果是单核，并没有停顿时间的要求，串行或JVM自己选；        如果允许停顿时间超过1秒，选择并行或JVM自己选；        如果响应时间非常重要，并且不能超过1秒，使用并发收集器；            推荐的jvm模版-Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxTenuringThreshold=15 JAVA_OPTS=\"$JAVA_OPTS -server -Xms3G -Xmx3G -Xss256k -XX:PermSize=64m -XX:MaxPermSize=128m -XX:+UseParallelOldGC -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/usr/aaa/dump -XX:+PrintGCDetails -XX:+PrintGCTimeStamps -Xloggc:/usr/aaa/dump/heap_trace.txt -XX:NewSize=512m -XX:MaxNewSize=1G\"jdk1.7 6V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=68 -verbose:gc -XX:+PrintGCDetails -Xloggc:{CATALINA_BASE}/logs/gc.log -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath={CATALINA_BASE}/logs 前台jdk1.7 8V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=68 -verbose:gc -XX:+PrintGCDetails -Xloggc:{CATALINA_BASE}/logs/gc.log -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath={CATALINA_BASE}/logs 前台jdk1.7 4V8G -server -Xms4g -Xmx4g -Xmn2g -Xss768k -XX:PermSize=512m -XX:MaxPermSize=512m -XX:+UseConcMarkSweepGC -XX:+UseParNewGC -XX:+CMSClassUnloadingEnabled -XX:+DisableExplicitGC -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=68 -verbose:gc -XX:+PrintGCDetails -Xloggc:{CATALINA_BASE}/logs/gc.log -XX:+PrintGCDateStamps -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath={CATALINA_BASE}/logs 前台jdk1.7 6V8G -server -Xms4g -Xmx4g -XX:MaxPermSize=512m \\-verbose:gc -XX:+PrintGCDetails -Xloggc{CATALINA_BASE}/logs/gc.log -XX:+PrintGCTimeStamps \\ 后台      -Xmx4g：堆内存最大值为4GB。默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到-Xms的最小限制。    -Xms4g：初始化堆内存大小为4GB。默认为物理内存的1/64(小于1GB)。    -Xmn1200m：设置年轻代大小为1200MB。增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。    -Xss512k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1MB，以前每个线程堆栈大小为256K。应根据应用线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。    -XX:NewRatio=4：设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5    -XX:SurvivorRatio=8：设置年轻代中Eden区与Survivor区的大小比值。设置为8，则两个Survivor区与一个Eden区的比值为2:8，一个Survivor区占整个年轻代的1/10    -XX:PermSize=100m：初始化永久代大小为100MB。    -XX:MaxTenuringThreshold=15：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。  参考链接  https://blog.csdn.net/wangshuminjava/article/details/107041189https://www.liaoxuefeng.com/article/1336345083510818https://snailclimb.gitee.io/javaguide-interview/#/./docs/b-4jvm"
},

{
"title": "第一个 Thymeleaf 页面",
"url": "/posts/Thymeleaf%E9%A1%B5%E9%9D%A2/",
"categories": "前端",
"tags": "前端, Thymeleaf",
"date": "2019-01-03 10:39:06 +0800",







"snippet": "第一个 Thymeleaf 页面引入依赖主要增加spring-boot-starter-thymeleaf和nekohtml这两个依赖  spring-boot-starter-thymeleaf：Thymeleaf 自动配置  nekohtml：允许使用非严格的 HTML 语法完整的pom.xml如下：``` xml&lt;?xml version=”1.0” encoding=”UTF-...",
"content": "第一个 Thymeleaf 页面引入依赖主要增加spring-boot-starter-thymeleaf和nekohtml这两个依赖  spring-boot-starter-thymeleaf：Thymeleaf 自动配置  nekohtml：允许使用非严格的 HTML 语法完整的pom.xml如下：``` xml&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;    4.0.0    com.tangyuewei    hello-spring-boot    0.0.1-SNAPSHOT    jar    hello-spring-boot                org.springframework.boot        spring-boot-starter-parent        2.1.6.RELEASE                         UTF-8        UTF-8        1.8                            org.springframework.boot            spring-boot-starter-web                            org.springframework.boot            spring-boot-starter-tomcat                            org.springframework.boot            spring-boot-starter-thymeleaf                            org.springframework.boot            spring-boot-starter-actuator                            org.springframework.boot            spring-boot-starter-test            test                            net.sourceforge.nekohtml            nekohtml            1.9.22                                                    org.springframework.boot                spring-boot-maven-plugin                                    com.tangyuewei.hello.spring.boot.HelloSpringBootApplication                                        ## 配置 Thymeleaf在`application.yml`配置 Thymeleaf``` yamlspring:  thymeleaf:    cache: false # 开发时关闭缓存,不然没法看到实时页面    mode: HTML # 用非严格的 HTML    encoding: UTF-8    servlet:      content-type: text/html创建测试用 JavaBean创建一个测试效果的 JavaBean，简单封装一下即可package com.tangyuewei.hello.spring.boot.entity;import java.io.Serializable;public class PersonBean implements Serializable {    private String name;    private Integer age;    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public Integer getAge() {        return age;    }    public void setAge(Integer age) {        this.age = age;    }}创建测试用 Controller创建一个Controller，造一些测试数据并设置跳转package com.tangyuewei.hello.spring.boot.controller;import com.tangyuewei.hello.spring.boot.entity.PersonBean;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import java.util.ArrayList;import java.util.List;@Controller@RequestMapping(value = \"thymeleaf\")public class IndexController {    @RequestMapping(value = \"index\", method = RequestMethod.GET)    public String index(Model model) {        PersonBean person = new PersonBean();        person.setName(\"张三\");        person.setAge(22);        List&lt;PersonBean&gt; people = new ArrayList&lt;&gt;();        PersonBean p1 = new PersonBean();        p1.setName(\"李四\");        p1.setAge(23);        people.add(p1);        PersonBean p2 = new PersonBean();        p2.setName(\"王五\");        p2.setAge(24);        people.add(p2);        PersonBean p3 = new PersonBean();        p3.setName(\"赵六\");        p3.setAge(25);        people.add(p3);        model.addAttribute(\"person\", person);        model.addAttribute(\"people\", people);        return \"index\";    }}创建测试页面在templates目录下创建index.html文件，代码如下：&lt;!DOCTYPE html SYSTEM \"http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-spring4-4.dtd\"&gt;&lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt;    &lt;meta charset=\"UTF-8\"&gt;    &lt;title&gt;Hello Thymeleaf&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;div&gt;        &lt;span&gt;访问 Model：&lt;/span&gt;&lt;span th:text=\"${person.name}\"&gt;&lt;/span&gt;    &lt;/div&gt;    &lt;div&gt;        &lt;span&gt;访问列表&lt;/span&gt;        &lt;table&gt;            &lt;thead&gt;                &lt;tr&gt;                    &lt;th&gt;姓名&lt;/th&gt;                    &lt;th&gt;年龄&lt;/th&gt;                &lt;/tr&gt;            &lt;/thead&gt;            &lt;tbody&gt;                &lt;tr th:each=\"human : ${people}\"&gt;                    &lt;td th:text=\"${human.name}\"&gt;&lt;/td&gt;                    &lt;td th:text=\"${human.age}\"&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/tbody&gt;        &lt;/table&gt;    &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;测试访问启动成功后，访问：http://localhost:9090/thymeleaf/index 即可看到效果"
},

{
"title": "Thymeleaf 简介",
"url": "/posts/Thymeleaf-%E7%AE%80%E4%BB%8B/",
"categories": "前端",
"tags": "前端, Thymeleaf",
"date": "2019-01-02 10:39:06 +0800",







"snippet": "Thymeleaf 简介什么是 Thymeleaf  Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点  Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，...",
"content": "Thymeleaf 简介什么是 Thymeleaf  Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点  Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板 + 数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。  Thymeleaf 开箱即用的特性。它提供标准和 Spring 标准两种方言，可以直接套用模板实现 JSTL、 OGNL 表达式效果，避免每天套模板、改 JSTL、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。  Thymeleaf 提供 Spring 标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。为什么需要 Thymeleaf  如果希望以 Jar 形式发布模块则尽量不要使用 JSP 相关知识，这是因为 JSP 在内嵌的 Servlet 容器上运行有一些问题 (内嵌 Tomcat、 Jetty 不支持 Jar 形式运行 JSP，Undertow 不支持 JSP)。Spring Boot 中推荐使用 Thymeleaf 作为模板引擎，因为 Thymeleaf 提供了完美的 Spring MVC 支持，Spring Boot 提供了大量模板引擎，包括：  FreeMarker  Groovy  Mustache  Thymeleaf  Velocity  Beetl"
},

{
"title": "Spring Boot应用程序",
"url": "/posts/Spring-Boot%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F/",
"categories": "Spring Boot",
"tags": "Spring Boot, Spring Boot案例",
"date": "2019-01-01 10:39:06 +0800",







"snippet": "Spring Boot应用程序概述  Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。      创建...",
"content": "Spring Boot应用程序概述  Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。      创建独立的Spring应用程序        直接嵌入Tomcat，Jetty或Undertow（无需部署WAR文件）        提供自以为是的“入门”依赖项以简化构建配置        尽可能自动配置Spring和第三方库        提供生产就绪功能，例如指标，运行状况检查和外部化配置    绝对没有代码生成，也不需要XML配置    构建第一个Spring Boot应用    新建一个文件夹spring-boot-sample`  创建目录结构    └── src  └── main      └── java          └── hello        新建pom.xml文件          ``` xml&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;          4.0.0    org.springframework    gs-rest-service    0.1.0            org.springframework.boot        spring-boot-starter-parent        2.0.5.RELEASE                            org.springframework.boot            spring-boot-starter-web                            org.springframework.boot            spring-boot-starter-test            test                            com.jayway.jsonpath            json-path            test                        1.8                                            org.springframework.boot                spring-boot-maven-plugin                        - 在```src/main/java/hello/```新建```HelloController.java`````` javapackage hello;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.RestController;@RestControllerpublic class HelloController {    @RequestMapping(\"/hello\")    public String hello(@RequestParam(value=\"name\", defaultValue=\"World\") String name) {        return \"Hello \" + name;    }}  在src/main/java/hello/新建Application.java``` javapackage hello;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class Application {public static void main(String[] args) {    SpringApplication.run(Application.class, args);} } ``` - 访问```http://localhost:8080/hello```返回```Hello World```"
},

{
"title": "Redis笔记",
"url": "/posts/Redis%E7%AC%94%E8%AE%B0/",
"categories": "数据库",
"tags": "数据库, Redis, 缓存",
"date": "2018-10-13 10:39:06 +0800",







"snippet": "Redis简介在线redis命令测试  Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial...",
"content": "Redis简介在线redis命令测试  Redis 是一个开源（BSD许可）的，内存中的数据结构存储系统，它可以用作数据库、缓存和消息中间件。 支持多种类型的数据结构，如 字符串（strings）， 散列（hashes）， 列表（lists）， 集合（sets）， 有序集合（sorted sets） 与范围查询， bitmaps， hyperloglogs 和 地理空间（geospatial） 索引半径查询。 Redis 内置了 复制（replication），LUA脚本（Lua scripting）， LRU驱动事件（LRU eviction），事务（transactions） 和不同级别的 磁盘持久化（persistence）， 并通过 Redis哨兵（Sentinel）和自动 分区（Cluster）提供高可用性（high availability）。数据类型字符串（strings）&gt; set mykey somevalueOK&gt; get mykey\"somevalue\"  当key存在时SET会失败，当key不存在时它只会成功。    &gt; set mykey newval nx(nil)        当key不存在时会失败，当key存在时它会成功并更新值。    &gt; set mykey newval xxOK        原子递增：返回递增后的值::: tip 提示key不存在会创建key，如果key存在，但不是integer类型则会报错即使多个客户端对同一个key发出INCR命令，也决不会导致竞争的情况。:::&gt; set counter 100OK&gt; incr counter(integer) 101&gt; incr counter(integer) 102&gt; incrby counter 50(integer) 152  原子递减：返回递减后的值    &gt; decr counter(integer) 151&gt; decrby counter 50(integer) 101        GETSET命令，行如其名：他为key设置新值并且返回原值。时间复杂度：O(1)    redis&gt; INCR mycounter(integer) 1redis&gt; GETSET mycounter \"0\"\"1\"redis&gt; GET mycounter\"0\"redis&gt;        一次存储或获取多个key对应的值&gt; mset a 10 b 20 c 30OK&gt; mget a b c1) \"10\"2) \"20\"3) \"30\"  TYPE命令可以返回key对应的值的存储类型,使用EXISTS命令返回1或0标识给定key的值是否存在```          set mykey xOKtype mykeystringdel mykey(integer) 1type mykeynoneexists mykey(integer) 0      + Redis超时:数据在限定时间内存活,TTL命令用来查看key对应的值剩余存活时间。  set key somevalueOKexpire key 5(integer) 1  set key 100 ex 10OKttl key(integer) 9### 散列（hashes）Hash 便于表示 objects, HMSET 指令设置 hash 中的多个域，而 HGET 取回单个域。HMGET 和 HGET 类似，返回多列值  hmset user:1000 username tyw birthyear 2020 verified 1OKhget user:1000 username“tyw”hget user:1000 birthyear“2020”hgetall user:10001) “username”2) “tyw”3) “birthyear”4) “2020”5) “verified”6) “1”  hmget user:1000 username birthyear no-such-field1) “tyw”2) “2020”3) (nil)+ HINCRBY&gt; 小的 hash 被用特殊方式编码，非常节约内存  hincrby user:1000 birthyear 10(integer) 2030hdecrby user:1000 birthyear 10(integer) 2020```列表（lists）  rpush mylist A 右边插入,或者rpush mylist A B C 1 'dd'  lpush mylist first 左边插入  lrange mylist 0 -1 列出元素  rpop mylist 右边删除元素，返回删除的值，左边删除lpop mylist::: tip 提示-1表示最后一个元素，-2表示list中的倒数第二个元素，以此类推。          应用场景： 1.聊天系统2.不同进程间传递消息的队列例如在评级系统中，比如社会化新闻网站 reddit.com，你可以把每个新提交的链接添加到一个list，用LRANGE可简单的对结果分页。在博客引擎实现中，你可为每篇日志设置一个list，在该list中推入博客评论，等等。:::      集合（sets）  Redis Set 是 String 的无序排列。SADD 指令把新的元素添加到 set 中。对 set 也可做一些其他的操作，比如测试一个给定的元素是否存在，对不同 set 取交集，并集或差，等等。&gt; sadd myset 1 2 3(integer) 3&gt; smembers myset1. 32. 13. 2      Redis 有检测成员的指令sismember myset 3        Sets 适合用于表示对象间的关系。假设我们想要给新闻打上标签sadd news:1000:tags 1 2 5 66        SINTER 命令获取不同 set 的交集sinter tag:1:news tag:2:news tag:10:news tag:27:news        返回集合中的所有成员smembers key        获取集合的成员数scard key        返回给定所有集合的差集sdiff key1 key2        返回给定所有集合的差集并存储在 dest 中sdiffstore dest key1 key2        返回给定所有集合的交集sinter key1 key2        返回给定所有集合的交集并存储在 dest 中sinterstore dest key1 key2        将 member 元素从 source 集合移动到 dest 集合smove source dest member        移除并返回集合中的一个随机元素spop key        返回集合中一个或多个随机数srandmember key count        移除集合中一个或多个成员srem key member1 member2        返回所有给定集合的并集sunion key1 key2        所有给定集合的并集存储在 dest 集合中sunionstore dest key1 key2        迭代集合中的元素sscan key cursor [match pattern] [count count]  有序集合（sorted sets）  集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是O(1)。 集合中最大的成员数为 2的32次方 -1 (4294967295,40多亿个)      向有序集合添加一个或多个成员，或者更新已存在成员的分数zadd key score1 member1 score2 member2        获取有序集合的成员数zcard key        计算在有序集合中指定区间分数的成员数zcount key min max        有序集合中对指定成员的分数加上增量 incrementzincrby key increment member        计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中zinterstore destination numkeys key key1 ...        返回有序集中，成员的分数值zscore key member        返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序zrevrank key member  持久化  持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。RDB  RDB：Redis DataBase缩写,是Redis默认的持久化方式。按照一定的时间将内存的数据以快照的形式保存到硬盘中，对应产生的数据文件为dump.rdb。通过配置文件中的save参数来定义快照的周期。优点：  只有一个文件 dump.rdb，方便持久化。  容灾性好，一个文件可以保存到安全的磁盘。  性能最大化，fork 子进程来完成写操作，让主进程继续处理命令，所以是 IO 最大化，保证了 redis 的高性能。  相对于数据集大时，启动效率比 AOF 的更高。缺点：数据安全性较低，适合数据要求不是很严谨的情况下使用AOF  AOF即Append Only File持久化，则是将Redis执行的每次写命令记录到单独的日志文件中，当重启Redis会重新将持久化的日志中文件恢复数据。当两种方式同时开启时，数据恢复Redis会优先选择AOF恢复。优点：  数据安全，aof 持久化可以配置 appendfsync 属性，有 always，每进行一次 命令操作就记录到 aof 文件中一次。  通过 append 模式写文件，即使中途服务器宕机，可以通过 redis-check-aof 工具解决数据一致性问题。  AOF 机制的 rewrite 模式。AOF 文件没被 rewrite 之前（文件过大时会对命令 进行合并重写），可以删除其中的某些命令（比如误操作的 flushall）缺点：  AOF 文件比 RDB 文件大，且恢复速度慢  数据集大的时候，启动效率比 rdb 低集群方案哨兵模式  sentinel用于实现 redis 集群的高可用，本身也是分布式的，作为一个哨兵集群去运行，互相协同工作。核心：  哨兵至少需要 3 个实例。  哨兵 + redis 主从的部署架构，是不保证数据零丢失的，只能保证 redis 集群的高可用性。官方 Redis Cluster 方案(推荐)  Redis Cluster采用slot(槽)的概念，一共分成16384个槽。将请求发送到任意节点，接收到请求的节点会将查询请求发送到正确的节点上执行优点：  无中心架构，支持动态扩容，对业务透明  具备Sentinel的监控和自动Failover(故障转移)能力  客户端不需要连接集群所有节点，连接集群中任何一个可用节点即可  高性能，客户端直连redis服务，省去了proxy代理的损耗缺点：  运维很复杂，数据迁移需要人工干预  只能使用0号数据库  不支持批量操作(pipeline管道操作)  分布式逻辑和存储模块耦合等缓存雪崩  缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。  一般并发量不是特别多的时候，使用最多的解决方案是加锁排队。  给每一个缓存数据增加相应的缓存标记，记录缓存的是否失效，如果缓存标记失效，则更新数据缓存。缓存穿透  设置热点数据永远不过期。  加互斥锁缓存与数据库双写时的数据不一致性  先更新数据库，然后再删除缓存"
},

{
"title": "Mysql笔记",
"url": "/posts/Mysql%E7%AC%94%E8%AE%B0/",
"categories": "数据库",
"tags": "数据库, Mysql",
"date": "2018-10-13 10:39:06 +0800",







"snippet": "mysql下载安装下载地址: https://www.mysql.com/downloads/创建和使用数据库  登录数据库：    mysql -uroot -proot        显示数据库 show databases;  创建数据库 create database test;  访问数据库 mysql&gt; use test;  显示表 show tables;  创建表   ...",
"content": "mysql下载安装下载地址: https://www.mysql.com/downloads/创建和使用数据库  登录数据库：    mysql -uroot -proot        显示数据库 show databases;  创建数据库 create database test;  访问数据库 mysql&gt; use test;  显示表 show tables;  创建表    create table `user` (  `id` int(11) not null auto_increment comment '主键',  `username` varchar(48) default null comment '用户名',  `password` varchar(48) default null comment '密码',  `create_time` timestamp not null default current_timestamp comment '创建时间',  `update_time` timestamp not null comment '修改时间',  `state` int not null comment '状态',  primary key (`id`))engine=innodb default charset=utf8 comment='用户表';            查看表结构:describe user;或者desc user;    插入数据          将文本文件加载pet.txt到 pet表中，使用以下语句：load data local infile '/path/user.txt' into table user;      普通脚本插入：        insert into `user` values (1,'tyw','123','','',0);                      更新数据    update `user` set username = 'tboss' where id = 1;        查询数据    select * from `表名`;      索引  查看表索引show index from `表名`;show keys from `表名`;  创建索引-- 普通索引create index index_username on `表名` (username);-- 全文索引create fulltext index index_username on `表名` (username);-- 主键索引alter table `表名` add primary key (id);-- 外键索引alter table `表名` add unique (id);  删除索引drop index index_username on user;alter table user drop index index_username;-- 删除主键索引alter table user drop primary key;-- 删除外键索引alter table user drop unique;索引查询注意  like时“%aa%”不会使用索引，而like “aa%”会使用索引  where子句中使用了索引的话，order by中的列不会使用索引字段操作  添加字段:    alter table user add column extend varchar(10) after id;        修改字段:    alter table user modify column extend varchar(11) not null comment '字段备注';alter table user change column extend extend1 varchar(11) default null comment '字段备注';        删除表字段:    alter table 表名 drop column 字段名;create table 新表名 select 字段1, 字段2 from 原表名;      数据操纵语句(DML)  指定名称插入:insert into user (name,credate,sal,deptno) values ('zhangsan','2018-01-01','2000',1)  不指定名称插入:insert into user values ('zhangsan','2018-01-01','2000',1)  批量插入数据:insert into user values(1,'dept1'),(2,'dept2')  修改记录:update user set sal='4000',deptno=2 where ename='zhangsan'  删除记录:delete from user where ename='zhangsan'查询  查询所有记录：select * from user  查询不重复的记录：select distinct deptno from user  条件查询：select * from user where deptno=1 and sal&lt;3000  排序和限制：select * from user order by deptno desc limit 2  分页查询(查询从第0条记录开始10条)：select * from user order by deptno desc limit 0,10  聚合(查询部门人数大于1的部门编号)：select deptno,count(1) from user group by deptno having count(1) &gt; 1  连接查询：select * from user e left join user2 d on e.deptno=d.deptno  子查询：select * from user where deptno in (select deptno from user2)  记录联合：select deptno from user union select deptno from user2数据控制语句(DCL)权限相关  授予操作权限(将test数据库中所有表的select和insert权限授予test用户)：grant select,insert on test.* to 'test'@'localhost' identified by '123'  查看账号权限：show grants for 'test'@'localhost'  收回操作权限：revoke insert on test.* from 'test'@'localhost'  授予所有数据库的所有权限：grant all privileges on *.* to 'test'@'localhost'  授予所有数据库的所有权限(包括grant)：grant all privileges on *.* to 'test'@'localhost' with grant option  授予SUPER PROCESS FILE权限（系统权限不能指定数据库）：grant super,process,file on *.* to 'test'@'localhost'  只授予登录权限：grant usage on *.* to 'test'@'localhost'帐号相关  删除账号：drop user 'test'@'localhost'  修改自己的密码：set password = password('123')  管理员修改他人密码：set password for 'test'@'localhost' = password('123')其他字符集相关  查看字符集：show variables like 'character%'  创建数据库时指定字符集：create database test2 character set utf8时区相关  查看当前时区（UTC为世界统一时间，中国为UTC+8）：show variables like \"%time_zone%\"  修改mysql全局时区为北京时间，即我们所在的东8区：set global time_zone = '+8:00';  修改当前会话时区：set time_zone = '+8:00'  立即生效：flush privileges连接数(默认151 最大可以达到16384 设置在80% 13000左右比较合适)  MySQL: ERROR 1040: Too many connections设置较大的 max_connections 值时，可能会导致数据库因接受了太多的连接而性能下降，甚至因为资源耗尽而无法响应的风险查看最大连接数设置show variables like '%max_connections%';查看当前实际最大使用连接数show global status like 'Max_used_connections';设置最大连接数# 立即生效，重启后失效set GLOBAL max_connections=1000;# 修改mysql安装目录配置文件my.ini，“max_connections”的值，默认最大连接数是100重启后生效查看当前进程show processlist;优化  表关联查询时务必遵循 小表驱动大表 原则；  使用查询语句 where 条件时，不允许出现 函数，否则索引会失效；  使用单表查询时，相同字段尽量不要用 OR，因为可能导致索引失效，比如：SELECT * FROM table WHERE name = ‘zhangsan’ OR name = ‘lisi’，可以使用 UNION 替代；  LIKE 语句不允许使用 % 开头，否则索引会失效；  组合索引一定要遵循 从左到右 原则，否则索引会失效；比如：SELECT * FROM table WHERE name = ‘张三’ AND age = 18，那么该组合索引必须是 name,age 形式；  索引不宜过多，根据实际情况决定，尽量不要超过 10 个；  每张表都必须有 主键，达到加快查询效率的目的；  分表，可根据业务字段尾数中的个位或十位或百位（以此类推）做表名达到分表的目的；  分库，可根据业务字段尾数中的个位或十位或百位（以此类推）做库名达到分库的目的；  表分区，类似于硬盘分区，可以将某个时间段的数据放在分区里，加快查询速度，可以配合 分表 + 表分区 结合使用；删除冗余和重复索引//反例KEY `idx_userId` (`userId`)KEY `idx_userId_age` (`userId`,`age`)//正例，删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引 KEY `idx_userId_age` (`userId`,`age`)  索引不宜太多，一般5个以内where子句中考虑使用默认值代替null//反例select * from user where age is not null;//正例，设置0为默认值select * from user where age&gt;0;避免在where子句中使用or来连接条件//使用union allselect * from user where userid=1unionallselect * from use rwhere age = 18//或者分开两条sql写：select * from user where userid=1select * from user where age = 18优化like语句  把%放关键字后面  select userId，namefrom user where userId like'123%';  避免死锁  理的设计索引，区分度高的列放到组合索引前面，使业务 SQL 尽可能通过索引定位更少的行，减少锁竞争。  调整业务逻辑 SQL 执行顺序， 避免 update/delete 长时间持有锁的 SQL 在事务前面。  避免大事务，尽量将大事务拆成多个小事务来处理，小事务发生锁冲突的几率也更小。  以固定的顺序访问表和行。比如两个更新数据的事务，事务 A 更新数据的顺序为 1，2;事务 B 更新数据的顺序为2，1。这样更可能会造成死锁。  在并发比较高的系统中，不要显式加锁，特别是是在事务里显式加锁。如 select … for update 语句，如果是在事务里（运行了 start transaction 或设置了autocommit 等于0）,那么就会锁定所查找到的记录。  尽量按主键/索引去查找记录，范围查找增加了锁冲突的可能性，也不要利用数据库做一些额外额度计算工作。比如有的程序会用到 “select … where … order by rand();”这样的语句，由于类似这样的语句用不到索引，因此将导致整个表的数据都被锁住。  优化 SQL 和表设计，减少同时占用太多资源的情况。比如说，减少连接的表，将复杂 SQL 分解为多个简单的 SQL。::: danger 警告在使用 MySQL 或 MariaDB，不要用“utf8”编码，改用“utf8mb4”。这里（https://mathiasbynens.be/notes/mysql-utf8mb4#utf8-to-utf8mb4）提供了一个指南用于将现有数据库的字符编码从“utf8”转成“utf8mb4”。MySQL 的“utf8mb4”是真正的“UTF-8”。MySQL 的“utf8”是一种“专属的编码”，它能够编码的 Unicode 字符并不多。:::缓存清理查看是否生效select @@query_cache_type;  1.在 query_cache_type 打开的情况下，如果你不想使用缓存，需要指明select sql_no_cache id,name from tableName;2.当sql中用到mysql函数，也不会缓存查看缓存的状态show status like '%Qcache%';            名称      备注                  Qcache_free_blocks      目前还处于空闲状态的 Query Cache 中内存 Block 数目              Qcache_free_memory      目前还处于空闲状态的 Query Cache 内存总量              Qcache_hits      Query Cache 命中次数              Qcache_inserts      向 Query Cache 中插入新的 Query Cache 的次数，也就是没有命中的次数              Qcache_lowmem_prunes      当 Query Cache 内存容量不够，需要从中删除老的 Query Cache 以给新的 Cache 对象使用的次数              Qcache_not_cached      没有被 Cache 的 SQL 数，包括无法被 Cache 的 SQL 以及由于 query_cache_type 设置的不会被 Cache 的 SQL              Qcache_queries_in_cache      目前在 Query Cache 中的 SQL 数量              Qcache_total_blocks      Query Cache 中总的 Block 数量      禁用/开启查询缓存set session query_cache_type=off;set session query_cache_type=on;缓存清理FLUSH QUERY CACHE; -- 清理查询缓存内存碎片。RESET QUERY CACHE; -- 从查询缓存中移出所有查询。FLUSH TABLES; -- 关闭所有打开的表，同时该操作将会清空查询缓存中的内容。  参考资料"
},

{
"title": "MongoDB笔记",
"url": "/posts/MongoDB%E7%AC%94%E8%AE%B0/",
"categories": "数据库",
"tags": "数据库, MongoDB",
"date": "2018-10-13 10:39:06 +0800",







"snippet": "MongoDB概述官网手册  MongoDB 是一个基于分布式文件存储的数据库。是由字段和值对组成的数据结构。MongoDB文档类似于JSON对象。字段的值可以包括其他文档，数组和文档数组。特点高性能MongoDB提供高性能数据持久性。  对嵌入式数据模型的支持减少了数据库系统的I / O活动。  索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。高可用性MongoDB的复制工具称为...",
"content": "MongoDB概述官网手册  MongoDB 是一个基于分布式文件存储的数据库。是由字段和值对组成的数据结构。MongoDB文档类似于JSON对象。字段的值可以包括其他文档，数组和文档数组。特点高性能MongoDB提供高性能数据持久性。  对嵌入式数据模型的支持减少了数据库系统的I / O活动。  索引支持更快的查询，并且可以包含来自嵌入式文档和数组的键。高可用性MongoDB的复制工具称为副本集，它提供：  自动故障转移和  数据冗余。MongoDB CRUD操作  插入：    db.collection.insertOne() 版本3.2中的新功能db.collection.insertMany() 版本3.2中的新功能        ::: tip 提示db.users.insertOne({name: “tboss”,age: 30}):::    查询：    db.collection.find()        ::: tip 提示db.users.find({age: { $gt: 18 } },{name: “tboss” }).limit(20):::    更新    db.collection.updateOne() 版本3.2中的新功能db.collection.updateMany() 版本3.2中的新功能db.collection.replaceOne() 版本3.2中的新功能        ::: tip 提示db.users.updateMany({age: { $gt: 18 } },{$set: { name: “tyw” } }):::    删除    db.collection.deleteOne() 版本3.2中的新功能db.collection.deleteMany() 版本3.2中的新功能        ::: tip 提示db.users.deleteMany({age: { $gt: 18 } }):::  聚合db.collection.aggregate([    { $match: { status: 0 } },  //精确匹配    { $group: { _id: \"$cust_id\",total: { $sum: \"amount\" } } }   //精确匹配]);索引  单个索引          对于单字段索引和排序操作，索引键的排序顺序（即升序或降序）无关紧要，因为MongoDB可以在任一方向上遍历索引。      db.collection.createIndex( { name: 1 } )    //单个索引              复合索引          对于复合索引和排序操作，索引键的排序顺序（即升序或降序）可以确定索引是否可以支持排序操作。      db.collection.createIndex({name: 1, age: -1}, {background: true})   //复合索引              多键索引          如果索引包含数组值的字段，MongoDB会为数组的每个元素创建单独的索引条目。这些多键索引允许查询通过匹配数组的元素或元素来选择包含数组的文档。如果索引字段包含数组值，MongoDB会自动确定是否创建多键索引; 您不需要显式指定多键类型。      db.collection.createIndex({\"stock.size\": 1 })   //多键索引            json:      {_id: 3,item: \"ijk\",stock: [  { size: \"M\", color: \"blue\", quantity: 15 },  { size: \"L\", color: \"blue\", quantity: 100 },  { size: \"L\", color: \"red\", quantity: 25 }]}              文字索引          支持在集合中搜索字符串内容。      db.collection.createIndex( { name: \"text\" } )  //文字索引db.collection.createIndex( { name: \"text\", desc: \"text\" } )  //文字复合索引db.collection.createIndex( { \"$**\": \"text\" } )  //通配符文字索引--为包含集合中每个文档的字符串数据的每个字段编制索引              散列索引          索引在其范围内具有更随机的值分布，但仅支持相等匹配且不支持基于范围的查询。      db.collection.createIndex( { _id: \"hashed\" } )  //散列索引--不支持多键              唯一索引          索引的唯一属性会导致MongoDB拒绝索引字段的重复值。除了唯一约束之外，唯一索引在功能上可与其他MongoDB索引互换。        部分索引(版本3.2中的新功能。)          部分索引仅索引符合指定过滤器表达式的集合中的文档。通过索引集合中的文档子集，部分索引具有较低的存储要求，并降低了索引创建和维护的性能成本。      db.collection.createIndex(   { cuisine: 1, name: 1 },   { partialFilterExpression: { rating: { $gt: 5 } } })  稀疏索引          索引的稀疏属性可确保索引仅包含具有索引字段的文档的条目。索引会跳过没有索引字段的文档。您可以将稀疏索引选项与唯一索引选项组合，以拒绝具有字段重复值的文档，但忽略没有索引键的文档。      db.scores.createIndex( { score: 1 } , { sparse: true } )            如果某些文档中不包含score字段，则直接跳过        TTL索引  TTL索引是MongoDB可用于在一定时间后自动从集合中删除文档的特殊索引。::: tip 提示语法中 name 值为你要创建的索引字段，1 为指定按升序创建索引，如果你想按降序来创建索引指定为 -1 即可。:::            参数      类型      描述                  background      Boolean      建索引过程会阻塞其它数据库操作，background可指定以后台方式创建索引，即增加 “background” 可选参数。 “background” 默认值为false。              unique      Boolean      建立的索引是否唯一。指定为true创建唯一索引。默认值为false.              name      string      索引的名称。如果未指定，MongoDB的通过连接索引的字段名和排序顺序生成一个索引名称。              dropDups      Boolean      3.0+版本已废弃。在建立唯一索引时是否删除重复记录,指定 true 创建唯一索引。默认值为 false.              sparse      Boolean      对文档中不存在的字段数据不启用索引；这个参数需要特别注意，如果设置为true的话，在索引字段中不会查询出不包含对应字段的文档.。默认值为 false.              expireAfterSeconds      integer      指定一个以秒为单位的数值，完成 TTL设定，设定集合的生存时间。              v      index version      索引的版本号。默认的索引版本取决于mongod创建索引时运行的版本。              weights      document      索引权重值，数值在 1 到 99,999 之间，表示该索引相对于其他索引字段的得分权重。              default_language      string      对于文本索引，该参数决定了停用词及词干和词器的规则的列表。 默认为英语              language_override      string      对于文本索引，该参数指定了包含在文档中的字段名，语言覆盖默认的language，默认值为 language.      索引管理  列出索引    db.collection.getIndexes()        db.getCollectionNames().forEach(function(collection) { indexes = db[collection].getIndexes(); print(\"Indexes for \" + collection + \":\"); printjson(indexes);});//列出所有索引        删除索引    db.collection.dropIndex( { \"name\": 1 } );   //删除指定索引db.collection.dropIndexes();    //删除所有索引        修改索引          要修改现有索引，需要删除并重新创建索引。例外是 TTL索引，可以通过collMod命令与index集合标志一起 修改。      MongoDB 提供了多种查询和统计命令，用于对数据进行检索、分析和处理。以下是一些常见的 MongoDB 查询及统计命令示例：1. 基本查询命令查询所有文档db.collection.find();查询匹配特定条件的文档db.collection.find({ field: value });查询单个文档db.collection.findOne({ field: value });查询指定字段的文档（返回指定字段）db.collection.find({ field: value }, { field1: 1, field2: 1, _id: 0 });查询字段大于或小于某个值的文档db.collection.find({ age: { $gt: 18 } });  // 大于18岁db.collection.find({ age: { $lt: 18 } });  // 小于18岁使用逻辑运算符进行查询db.collection.find({ $and: [{ age: { $gt: 18 } }, { status: \"active\" }] });  // AND操作db.collection.find({ $or: [{ age: { $gt: 18 } }, { status: \"active\" }] });   // OR操作2. 统计命令统计文档总数db.collection.count({ field: value });统计并分组db.collection.aggregate([    { $match: { status: \"active\" } }, // 筛选条件    { $group: { _id: \"$status\", total: { $sum: 1 } } }  // 分组统计]);计算字段的平均值db.collection.aggregate([    { $group: { _id: null, avgValue: { $avg: \"$field\" } } }]);计算字段的总和db.collection.aggregate([    { $group: { _id: null, totalValue: { $sum: \"$field\" } } }]);计算字段的最大值和最小值db.collection.aggregate([    { $group: { _id: null, maxValue: { $max: \"$field\" }, minValue: { $min: \"$field\" } } }]);3. 排序和分页对查询结果排序db.collection.find().sort({ field: 1 });  // 按字段升序排序db.collection.find().sort({ field: -1 }); // 按字段降序排序限制查询返回的文档数db.collection.find().limit(10); // 只返回前10条记录跳过前n条文档db.collection.find().skip(10);  // 跳过前10条记录分页查询db.collection.find().skip(20).limit(10); // 跳过前20条，返回接下来的10条记录4. 索引操作创建索引db.collection.createIndex({ field: 1 });  // 为字段创建升序索引查看当前索引db.collection.getIndexes();删除索引db.collection.dropIndex({ field: 1 });5. 集合和数据库操作创建新集合db.createCollection(\"new_collection\");删除集合db.collection.drop();查看所有集合db.getCollectionNames();删除数据库db.dropDatabase();6. 聚合操作聚合管道查询db.collection.aggregate([    { $match: { status: \"active\" } },           // 筛选条件    { $group: { _id: \"$category\", total: { $sum: \"$amount\" } } }, // 分组并统计总数    { $sort: { total: -1 } }                    // 按总数降序排列]);使用 $lookup 进行联表查询db.collection1.aggregate([    {        $lookup: {            from: \"collection2\",         // 目标集合            localField: \"field1\",        // 本集合中的字段            foreignField: \"field2\",      // 目标集合中的字段            as: \"result\"                 // 输出数组字段        }    }]);7. 文本搜索创建文本索引db.collection.createIndex({ content: \"text\" });执行文本搜索db.collection.find({ $text: { $search: \"keyword\" } });这些查询和统计命令可以帮助你在 MongoDB 中更高效地管理和分析数据。根据你的需求，可以组合使用这些命令实现更复杂的数据操作。"
},

{
"title": "MemCached笔记",
"url": "/posts/MemCached%E7%AC%94%E8%AE%B0/",
"categories": "数据库",
"tags": "数据库, MemCached",
"date": "2018-10-13 10:39:06 +0800",







"snippet": "MemCached概述  MemCache是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统，用于动态Web应用以减轻数据库的负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高了网站访问的速度。MemCaChe是一个存储键值对的HashMap，在内存中对任意的数据（比如字符串、对象等）所使用的key-value存储，数据可以来自数据库调用、API调用，或者页面渲染的...",
"content": "MemCached概述  MemCache是一个自由、源码开放、高性能、分布式的分布式内存对象缓存系统，用于动态Web应用以减轻数据库的负载。它通过在内存中缓存数据和对象来减少读取数据库的次数，从而提高了网站访问的速度。MemCaChe是一个存储键值对的HashMap，在内存中对任意的数据（比如字符串、对象等）所使用的key-value存储，数据可以来自数据库调用、API调用，或者页面渲染的结果。MemCache设计理念就是小而强大，它简单的设计促进了快速部署、易于开发并解决面对大规模的数据缓存的许多难题，而所开放的API使得MemCache能用于Java、C/C++/C#、Perl、Python、PHP、Ruby等大部分流行的程序语言。MemCache的官方网站特点  协议简单  基于libevent的事件处理  内置内存存储方式  memcached不互相通信的分布式Memcached 存储命令  set 命令:将 value 存储在指定的 key 中。set key flags exptime bytes [noreply] value 如果set的key已经存在，该命令可以更新该key所对应的原来的数据，也就是实现更新的作用。  key：键值 key-value 结构中的 key，用于查找缓存值。  flags：可以包括键值对的整型参数，客户机使用它存储关于键值对的额外信息 。  exptime：在缓存中保存键值对的时间长度（以秒为单位，0 表示永远）  bytes：在缓存中存储的字节数  noreply（可选）： 该参数告知服务器不需要返回数据  value：存储的值（始终位于第二行）（可直接理解为key-value结构中的value）``` sqlset hello 0 900 9memcachedSTOREDget helloVALUE hello 0 9memcachedEND+ add 命令:将 value 存储在指定的 key 中。`add key flags exptime bytes [noreply] value`如果 add 的 key 已经存在，则不会更新数据(过期的 key 会更新)，之前的值将仍然保持相同，并且您将获得响应 NOT_STORED。+ replace 命令:替换已存在的 key 的 value。`replace key flags exptime bytes [noreply] value`如果 key 不存在，则替换失败，并且您将获得响应 NOT_STORED。+ append 命令:已存在 key 的 value 后面追加数据 。`append key flags exptime bytes [noreply] value`+ prepend 命令:向已存在 key 的 value 前面追加数据。`prepend key flags exptime bytes [noreply] value`+ CAS 命令:用于执行一个\"检查并设置\"的操作它仅在当前客户端最后一次取值后，该key 对应的值没有被其他客户端修改的情况下， 才能够将值写入。检查是通过cas_token参数进行的， 这个参数是Memcach指定给已经存在的元素的一个唯一的64位值。`cas key flags exptime bytes unique_cas_token [noreply] value`输出信息说明：- STORED：保存成功。- ERROR：保存失败。- NOT_STORED：该键在 Memcached 上不存在。- CLIENT_ERROR：执行错误。- EXISTS：在最后一次取值后另外一个用户也在更新该数据。- NOT_FOUND：Memcached 服务上不存在该键值。## Memcached 查找命令+ get 命令:获取存储在 key 中的 value ，如果 key 不存在，则返回空。`get key` 或者 `get key1 key2 key3`+ gets 命令:获取带有 CAS 令牌存 的 value ，如果 key 不存在，则返回空。``` sqlset runoob 0 900 9memcachedSTOREDgets runoobVALUE runoob 0 9 1memcachedENDgets 命令的输出结果中，在最后一列的数字 1 代表了 key 为 runoob 的 CAS 令牌。  delete 命令:删除已存在的 key。delete key [noreply]  incr 与 decr 命令:已存在的 key 的数字值进行自增或自减操作。incr key incr_valueMemcached 统计命令  stats 命令:返回统计信息例如 PID(进程号)、版本号、连接数等。stats  stats items 命令:显示各个 slab 中 item 的数目和存储时长(最后一次访问距离现在的秒数)。stats items  stats slabs 命令:显示各个slab的信息，包括chunk的大小、数目、使用情况等。stats slabs  stats sizes 命令:显示所有item的大小和个数。stats sizes  flush_all 命令:清理缓存中的所有 key=&gt;value对。flush_all [time] [noreply]可选参数time，用于在指定的时间后执行清理缓存操作。"
},

{
"title": "git版本控制",
"url": "/posts/git%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/",
"categories": "版本控制",
"tags": "Git, SVN",
"date": "2018-06-19 10:39:06 +0800",







"snippet": "版本控制GitGit 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 与 SVN 区别      Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。        Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文...",
"content": "版本控制GitGit 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 与 SVN 区别      Git 是分布式的，SVN 不是：这是 Git 和其它非分布式的版本控制系统，例如 SVN，CVS 等，最核心的区别。        Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。        Git 分支和 SVN 的分支不同：分支在 SVN 中一点都不特别，其实它就是版本库中的另外一个目录。        Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。        Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。  git安装https://git-scm.com/downloadsGit  配置  用户配置          配置个人的用户名称和电子邮件地址：        $ git config --global user.name \"runoob\"$ git config --global user.email test@runoob.com              查看配置信息      $ git config --list    git生成ssh密钥          生成ssh key。          $ ssh-keygen -t rsa -C \"youremail@example.com\"                  后面的邮箱改成自己的，之后会要求确认路径和输入密码，使用默认的一路回车就行。成功的话会在 ~/ 下生成 .ssh 文件夹，进去，打开 id_rsa.pub，复制里面的 key。回到 git服务器上，进入账户配置添加ssh key。                      验证ssh key     $ ssh -T git@github.com  获取与创建项目命令git init用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。git initgit clone使用 git clone 拷贝一个 Git 仓库到本地，让自己能够查看该项目，或者进行修改。git clone [url]基本快照git addgit add 命令可将该文件添加到缓存git add &lt;filename&gt;git add .git statusgit status 以查看在你上次提交之后是否有修改。git statusgit status -sgit diff执行 git diff 来查看执行 git status 的结果的详细信息。git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。  尚未缓存的改动：git diff  查看已缓存的改动： git diff –cached  查看已缓存的与未缓存的所有改动：git diff HEAD  显示摘要而非整个 diff：git diff –statgit commit使用 git add 命令将想要快照的内容写入缓存区， 而执行 git commit 将缓存区内容添加到仓库中。Git 为你的每一个提交都记录你的名字与电子邮箱地址，所以第一步需要配置用户名和邮箱地址。git config --global user.name 'yourname'git config --global user.email youremail将文件写入缓存区并提供提交注释git commit -m 'update'git commit -m 'add files'git commit -m 'delete files'git reset HEADgit reset HEAD 命令用于取消已缓存的内容。git reset HEAD -- &lt;filename&gt;//上一个版本就是 HEAD^，上上一个版本就是 HEAD^^ 或者 HEAD~2，HEAD~100git reset --hard HEAD^git reset --hard 1094a//git reflog用来记录你的每一次命令git reflog拉取(更新代码)与推送git pullgit pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式稍稍有点复杂。git pullgit pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相似。git pushgit push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;分支管理创建与合并分支git checkout -b dev//相当于以下两条命令git branch devgit checkout dev//查看当前分支git branch//切换回master分支git checkout master//把dev分支的工作成果合并到master分支git merge dev//删除dev分支git branch -d dev切换分支这个动作，用switch更科学//创建并切换到新的dev分支git switch -c dev//切换到已有的master分支git switch master解决冲突git merge feature1//合并git add readme.txt//提交合并git commit -m \"conflict fixed\"//删除feature1分支git branch -d feature1bug分支//当前工作现场“储藏”起来git stash//假定在master分支上修复,就从master创建临时分支git checkout mastergit checkout -b issue-123//提交git add readme.txtgit commit -m \"fix bug 123\"//切换到master分支，并完成合并，最后删除issue-123分支git switch mastergit merge --no-ff -m \"merged bug fix 123\" issue-123//回到dev分支git switch dev//工作现场git stash list//恢复工作现场git stash apply stash@{0}git stash apply 恢复后，stash内容并不删除，你需要用git stash drop来删除git stash pop 恢复的同时把stash内容也删了（推荐）//bug提交的修改“复制”到当前分支，如：git cherry-pick 4c805e2git cherry-pick &lt;commit&gt;Feature分支//创建分支git switch -c feature-shop//开发完毕git add shop.javagit statusgit commit -m \"add feature shop\"//切回dev，准备合并git switch dev//此时，因各种原因新功能必须取消！强行删除git branch -D feature-shop多人协作//查看远程库的信息git remote -v//拉取git pull//拉取失败，设置dev和origin/dev的链接git branch --set-upstream-to=origin/dev dev//再次拉取git pull//推送分支git push origin mastergit push origin devSvn配合TortoiseSVN使用参考  一份很好的 Git 入门教程  git官方  Git分支管理策略"
},

{
"title": "算法与数据结构简介",
"url": "/posts/%E7%AE%97%E6%B3%95%E4%B8%8E%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%AE%80%E4%BB%8B/",
"categories": "算法与数据结构",
"tags": "算法与数据结构",
"date": "2018-06-06 10:39:06 +0800",







"snippet": "算法      插入排序（直接插入排序、希尔排序）        交换排序（冒泡排序、快速排序）        选择排序（直接选择排序、堆排序）        归并排序        分配排序（基数排序）        所需辅助空间最多：归并排序        所需辅助空间最少：堆排序        平均速度最快：快速排序        不稳定：快速排序，希尔排序，堆排序。  数据结构线性结...",
"content": "算法      插入排序（直接插入排序、希尔排序）        交换排序（冒泡排序、快速排序）        选择排序（直接选择排序、堆排序）        归并排序        分配排序（基数排序）        所需辅助空间最多：归并排序        所需辅助空间最少：堆排序        平均速度最快：快速排序        不稳定：快速排序，希尔排序，堆排序。  数据结构线性结构  数据结构中线性结构指的是数据元素之间存在着“一对一”的线性关系的数据结构；线性结构包括：数组，链表，队列，栈；  数组使用场景：频繁查询，很少增加和删除的情况。          特点：数组中的元素在内存中连续存储的，可以根据是下标快速访问元素，查询速度很快，然而插入和删除时，需要对元素移动空间，比较慢。        链表使用场景：少查询，需要频繁的插入或删除情况          特点：元素可以不连续内存中，是以索引将数据联系起来的，当查询元素的时候需要从头开始查询，所以效率比较低，然而添加和删除的只需要修改索引就可以了        队列使用场景：多线程阻塞队列管理非常有用          特点：先进先出        栈使用场景：实现递归以及表示式          特点：先进后出，类似于箱子      ::: tip 数组与链表的区别- 数组连续，链表不连续（从数据存储形式来说）- 数组内存静态分配，链表动态分配- 数组查询复杂度0（1），链表查询复杂度O(n)- 数组添加或删除，复杂度o（n）,链表添加删除，复杂度O（1）- 数组从栈中分配内存。链表从堆中分配内存。 :::非线性结构  非线性结构包括：树，图，表；"
},

{
"title": "服务器简介",
"url": "/posts/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AE%80%E4%BB%8B/",
"categories": "服务器",
"tags": "服务器, Tomcat, Nginx",
"date": "2018-06-05 10:39:06 +0800",







"snippet": "服务器简介TomcatTomcat是什么  Tomcat是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。官网修改Tomcat的缺省端口  到Tomcat目录下的conf文件夹  进入conf文件夹里面找到server.xml文件  打开server.xml文件  在server.xml文件里面找到下列信息  把Connector标签的80...",
"content": "服务器简介TomcatTomcat是什么  Tomcat是一个运行JAVA的网络服务器，底层是Socket的一个程序，它也是JSP和Serlvet的一个容器。官网修改Tomcat的缺省端口  到Tomcat目录下的conf文件夹  进入conf文件夹里面找到server.xml文件  打开server.xml文件  在server.xml文件里面找到下列信息  把Connector标签的8080端口改成你想要的端口&lt;Service name=\"Catalina\"&gt;&lt;Connector port=\"8080\" protocol=\"HTTP/1.1\" connectionTimeout=\"20000\" redirectPort=\"8443\" /&gt;tomcat 运行模式及优化  BIO:同步并阻塞一个线程处理一个请求-&gt;并发量高时，线程数较多，比较浪费资源          Tomcat7或以下，在Linux系统中默认使用这种方式。配制项为：protocol=”HTTP/1.1”        NIO:同步非阻塞IO-&gt;利用Java的异步IO处理，可以通过少量的线程处理大量的请求，可以复用同一个线程处理多个connection(多路复用)          Tomcat8在Linux系统中默认使用这种方式。配制项：protocol=”org.apache.coyote.http11.Http11NioProtocol”        APR:异步非阻塞IO-&gt;需在本地服务器安装APR库          配制项：protocol=”org.apache.coyote.http11.Http11AprProtocol”      NginxNginx概述  Nginx (engine x) 是一个高性能的HTTP和反向代理web服务器，同时也提供了IMAP/POP3/SMTP服务。Nginx是由伊戈尔·赛索耶夫为俄罗斯访问量第二的Rambler.ru站点（俄文：Рамблер）开发的，第一个公开版本0.1.0发布于2004年10月4日。      作为 Web 服务器：相比 Apache，Nginx 使用更少的资源，支持更多的并发连接，体现更高的效率，这点使 Nginx 尤其受到虚拟主机提供商的欢迎。能够支持高达 50,000 个并发连接数的响应，感谢 Nginx 为我们选择了 epoll and kqueue 作为开发模型.        作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP，也可以支持作为 HTTP代理服务器 对外进行服务。Nginx 用 C 编写, 不论是系统资源开销还是 CPU 使用效率都比 Perlbal 要好的多。        作为邮件代理服务器: Nginx 同时也是一个非常优秀的邮件代理服务器（最早开发这个产品的目的之一也是作为邮件代理服务器），Last.fm 描述了成功并且美妙的使用经验。        Nginx 安装非常的简单，配置文件 非常简洁（还能够支持perl语法），Bugs非常少的服务器: Nginx 启动特别容易，并且几乎可以做到7*24不间断运行，即使运行数个月也不需要重新启动。你还能够在 不间断服务的情况下进行软件版本的升级。  linux安装nginx官网Nginx中文文档yum install ngixNginx 配置创建 Nginx 运行使用的用户 tyw：[root@tyw conf]# /usr/sbin/groupadd tyw[root@tyw conf]# /usr/sbin/useradd -g tyw tyw修改user nginx;为user tyw tyw;配置nginx.confvi /etc/nginx/nginx.conf  如需配置自动跳转，则在nginx.conf文件里server节点增加此配置  rewrite ^(.*) https://$host$1 permanent;  Nginx 常用命令nginx -t    #检查配置nginx.conf是否正确nginx   #启动nginx服务nginx -s reload #重新载入配置文件nginx -s stop   #停止nginx服务nginx -s reopen #重启Nginx"
},

{
"title": "计算机基础",
"url": "/posts/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/",
"categories": "计算机基础",
"tags": "互联网协议, TCP/IP, HTTP2.0, HTTPS, OAuth 2.0, REST",
"date": "2018-05-18 10:39:06 +0800",







"snippet": "计算机本质  输入 -&gt; 处理 -&gt; 输出操作系统分类  根据工作方式分为          批处理操作系统      分时操作系统      实时操作系统      网络操作系统      分布式操作系统      计算机网络主要网络局域网什么是局域网单位、或者家庭中使用的网络  我们常见的“LAN”就是指局域网  局域网的特点  连接范围窄、用户数较少、配置容易、连接速率高、...",
"content": "计算机本质  输入 -&gt; 处理 -&gt; 输出操作系统分类  根据工作方式分为          批处理操作系统      分时操作系统      实时操作系统      网络操作系统      分布式操作系统      计算机网络主要网络局域网什么是局域网单位、或者家庭中使用的网络  我们常见的“LAN”就是指局域网  局域网的特点  连接范围窄、用户数较少、配置容易、连接速率高、不存在寻径问题  限制  一般来说几米至10公里以内城域网什么是城域网简称“MAN”，一个城市，但不在同一地理小区范围内的计算机互联，一个MAN网络通常连接着多个LAN限制距离可以在10-100公里广域网什么是广域网简称“WAN”,也称为远程网,覆盖的范围比城域网（MAN）更广无线网特点易于安装和使用互联网协议 TCP/IP模型建立连接客户端与服务器建立一个 TCP 连接时需要总共发送三个包以确认连接的建立。  客户端将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给服务器端，客户端进入SYN_SENT状态，等待服务器端确认。  服务器端收到数据包后由标志位SYN=1知道客户端请求建立连接，服务器端将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端以确认连接请求，服务器端进入SYN_RCVD状态。  客户端收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务器端，服务器端检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端和服务器端进入ESTABLISHED状态，然后客户端与服务器端之间就可以开始传输数据了。断开连接客户端与服务器断开连接时需要总共发送四个包以确认连接的断开。  客户端发送一个FIN=M，用来关闭客户端到服务器端的数据传送，客户端进入FIN_WAIT_1状态。此时可以继续发送数据。  服务器端收到FIN后，向客户端发送ack=M+1。客户端进入FIN_WAIT_2 状态，继续等待服务器端的FIN报文。  服务器端确定数据已发送完成，则向客户端发送FIN=N报文。服务器准备关闭连接了，服务器端进入LAST_ACK状态。  客户端收到FIN=N报文后，发送ack=N+1后进入TIME_WAIT状态，如果Server端没有收到ACK则可以重传。服务器端收到ACK后，就知道可以断开连接了。（客户端等待了2MSL后依然没有收到回复，说明服务器端已关闭，客户端也可以关闭连接了）HTTP2.0HTTP概述  HTTP历史：HTTP 建立之初，主要是为了将超文本标记语言(HTML)文档从Web服务器传送到客户端的浏览器。  HTTP的优化：带宽和延迟。          带宽：拨号上网的阶段，带宽可能会成为一个比较严重影响请求的问题，现在网络基础建设已经使得带宽得到极大的提升，不用再担心带宽影响网速了。      延迟：                  浏览器阻塞（HOL blocking）：浏览器会因为某些原因阻塞请求。浏览器对于同一个域名，同时只能有 4 个连接（根据浏览器内核不同可能会有所差异），超过浏览器最大连接数限制，后续请求就会被阻塞。          DNS 查询（DNS Lookup）：浏览器需要知道目标服务器的 IP 才能建立连接。将域名解析为 IP 的这个系统就是 DNS。通常可以利用DNS缓存结果来减少这个时间。          建立连接（Initial connection）：HTTP 是基于 TCP 协议的，浏览器最快也要在第三次握手时才能建立连接，连接无法复用会导致每次请求都经历三次握手和慢启动。三次握手在高延迟的场景下影响较明显，慢启动则对文件类的大请求影响较大。                          互联网专家们将新一代加密协议称为“HTTP 2.0”。                                          HTTP2.0特点  二进制传输http2.0采用二进制传输，相较于文本传输的http1.0来说更加安全可靠。  多路复用http1.0一个连接只能提交一个请求，而http2.0可以同时处理多个请求，可以降低连接的占用数量，提升网络的速度。  头部压缩http2.0使用HPACK算法对头部进行压缩，既避免了重复header的传输，又减小了需要传输数据的大小。  服务端推送服务端可以主动推送资源给客户端，避免客户端花过多的时间逐个请求资源，降低整个请求的响应时间。HTTPSHTTPS概述HTTPS是HTTP的安全版，HTTPS的安全基础是SSL，HTTPS是让HTTP先和SSL（Secure Sockets Layer）通信，再由SSL和TCP通信。即HTTPS使用了隧道进行通信。HTTPS = HTTP+SSL/TLS。::: tip通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）:::  由于HTTP报文的不安全性，网景在1994年就创建了HTTPS，并用在浏览器中。最初HTTPS是和SSL一起使用，然后演化为TLS。SSL／TLS在OSI模型中都是表示层的协议。SSL使 用40 位关键字作为RC4流加密算法，这对于商业信息的加密是合适的。HTTP升级HTTPS  CA证书，大部分证书都是需要收费的，当然，自己在服务器上用openssl也可以，不过浏览器会提示当前私密连接不安全这个警告，普通人看到这种信息是不会继续浏览的，所以，想使用HTTPS，可以使用Let’s Encrypt，由谷歌等公司推行。  HTTPS性能优化，SSL握手，HTTPS 对速度会有一定程度的降低，但是只要经过合理优化和部署，HTTPS 对速度的影响完全可以接受。  CPU计算压力，HTTPS中大量的秘钥算法计算，对CPU会有一定的压力。  http和https使用的是完全不同的连接方式，http端口是80，https端口是443。::: tipHTTPS下的网站，所有子链都要使用HTTPS。:::OAuth 2.0概述  OAuth 2.0是行业标准的授权协议。OAuth 2.0取代了2006年创建的原始OAuth协议所做的工作.OAuth 2.0专注于客户端开发人员的简单性，同时为Web应用程序，桌面应用程序，移动电话和客厅设备提供特定的授权流程。该规范及其扩展正在IETF OAuth工作组内开发。OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。授权方式  授权码（authorization-code）          申请一个授权码      用授权码获取令牌      ::: tip安全性高:::  隐藏式（implicit）          直接向前端颁发令牌      ::: tip安全性低（只能用于安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间（session）有效，浏览器关掉，令牌就失效了。）:::  密码式（password）          用户名和密码，直接告诉该应用      ::: tip用户高度信任的应用（暴露了用户名和密码）:::  客户端凭证（client credentials）          在命令行下请求令牌      ::: tip一般针对第三方应用，而不是针对用户的，即有可能多个用户共享同一个令牌。:::更新令牌令牌到期前，用户使用 refresh token 发一个请求，去更新令牌。REST概述一种软件架构风格，REST的架构风格是针对Web应用设计和开发的，它使得HTTP协议的原本面貌得以被了解。使用REST可以降低开发的复杂性，提高系统的可伸缩性。如今，REST架构已经成为主流技术。REST的设计标准  网络上的所有事物都被抽象为资源（resource）。  每个资源对应一个唯一的资源标识符（resource identifier）。  通过通用的连接器接口（generic connector interface）对资源进行操作。  对资源的各种操作不会改变资源标识符。  所有的操作都是无状态的（stateless）。"
},

{
"title": "JUnit 单元测试",
"url": "/posts/JUnit-%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/",
"categories": "单元测试",
"tags": "单元测试, JUnit",
"date": "2018-04-13 10:39:06 +0800",







"snippet": "JUnit 单元测试概述  JUnit 是用于编写和运行可重复的自动化测试的开源测试框架，这样可以保证我们的代码按预期工作。JUnit 可广泛用于工业和作为支架(从命令行)或IDE(如 IDEA)内单独的 Java 程序。  断言测试预期结果。  测试功能共享通用的测试数据。  测试套件轻松地组织和运行测试。  图形和文本测试运行。特点  JUnit 是用于编写和运行测试的开源框架。  提供...",
"content": "JUnit 单元测试概述  JUnit 是用于编写和运行可重复的自动化测试的开源测试框架，这样可以保证我们的代码按预期工作。JUnit 可广泛用于工业和作为支架(从命令行)或IDE(如 IDEA)内单独的 Java 程序。  断言测试预期结果。  测试功能共享通用的测试数据。  测试套件轻松地组织和运行测试。  图形和文本测试运行。特点  JUnit 是用于编写和运行测试的开源框架。  提供了注释，以确定测试方法。  提供断言测试预期结果。  提供了测试运行的运行测试。  JUnit 测试让您可以更快地编写代码，提高质量  JUnit 是优雅简洁。它是不那么复杂以及不需要花费太多的时间。  JUnit 测试可以自动运行，检查自己的结果，并提供即时反馈。没有必要通过测试结果报告来手动梳理。  JUnit 测试可以组织成测试套件包含测试案例，甚至其他测试套件。  Junit 显示测试进度的，如果测试是没有问题条形是绿色的，测试失败则会变成红色。使用Junit引入依赖&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;4.3.17.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;        &lt;scope&gt;test&lt;/scope&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;创建测试类在测试包下 src/main/test 创建一个名为 MyTest 的测试类，代码如下：import org.junit.After;import org.junit.Before;import org.junit.Test;public class MyTest {    /**     * 执行测试方法前执行     */    @Before    public void before() {        System.out.println(\"执行 before\");    }    /**     * 执行测试方法后执行     */    @After    public void after() {        System.out.println(\"执行 after\");    }    @Test    public void testSayHi() {        System.out.println(\"Hi\");    }    @Test    public void testSayHello() {        System.out.println(\"Hello\");    }}JUnit 注解      @Test 一个测试用例        @Before 该方法必须在类中的每个测试之前执行        @BeforeClass 一般在静态方法上必须执行一次并在类的所有测试之前。一般是公共配置方法(如连接到数据库)。        @After 测试方法运行后执行        @AfterClass 与@BeforeClass类似，在测试用例类后执行。(如从数据库如断开连接)。        @Ignore 注解为 @Ignore 的方法将不被执行。  "
},

{
"title": "Linux使用指南",
"url": "/posts/Linux%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",
"categories": "各种使用指南",
"tags": "Linux, Linux使用指南",
"date": "2018-04-09 10:39:06 +0800",







"snippet": "常用命令Linux 开关机命令重启  reboot  shutdown -r now    关机    shutdown -h now    系统管理命令    |      命令\t |                      说明 ||———:|————————:||    stat\t | 显示指定文件的相关信息,比ls命令显示内容更多 ||     who\t |            ...",
"content": "常用命令Linux 开关机命令重启  reboot  shutdown -r now    关机    shutdown -h now    系统管理命令    |      命令\t |                      说明 ||———:|————————:||    stat\t | 显示指定文件的相关信息,比ls命令显示内容更多 ||     who\t |                显示在线登录用户 || hostname |                 \t显示主机名称 ||   uname\t |                  显示系统信息 ||     top\t |        显示当前系统中耗费资源最多的进程 ||      ps\t |               显示瞬间的进程状态 ||      du\t |  显示指定的文件（目录）已使用的磁盘空间的总量 ||      df\t |         显示文件系统磁盘空间的使用情况 ||     free |       \t显示当前内存和交换空间的使用情况 || ifconfig |               \t显示网络接口信息 ||    ping\t |                测试网络的连通性 ||  netstat |               \t显示网络状态信息 ||   clear\t |                      清屏 ||    kill\t |                  杀死一个进程 |    基本操作常用        | 命令    |                说明 |                                           \t语法 |    参数 | \t参数说明             ||——-|——————:|———————————————-:|——:|——————-|| ls\t   |        显示文件和目录列表\t |                         ls [-alrtAFR] [name…] |       |                   || \t     |                   |                                               |    -l | 列出文件的详细信息         || \t     |                   |                                               |    -a | 列出当前目录所有文件，包含隐藏文件 || mkdir |              创建目录 |                            mkdir [-p] dirName |       |                   ||       |                   |                                             \t |   -p\t | 父目录不存在情况下先生成父目录   || cd    |              切换目录 |                                  cd [dirName] |       |                   || touch |           生成一个空文件 |                                               |       |                   || echo  |         生成一个带内容文件 |          echo abcd &gt; 1.txt，echo 1234 » 1.txt |       |                   || cat   |          显示文本文件内容 | cat [-AbeEnstTuv] [–help] [–version] fileName |       |                   || cp    |           复制文件或目录 |                      cp [options] source dest |       |                   || rm    |              删除文件 |                            rm [options] name… |       |                   ||       |                   |                                               |    -f | 强制删除文件或目录         ||       |                   |                                               |    -r | 同时删除该目录下的所有文件     || mv    |           移动文件或目录 |                      mv [options] source dest |       |                   || find  |     在文件系统中查找指定的文件 |                                               |       |                   ||       |                   |                                               | -name | 文件名               || grep  | 在指定的文本文件中查找指定的字符串 |                                               |       |                   || tree  |     用于以树状图列出目录的内容 |                                               |       |                   || pwd   |          显示当前工作目录 |                                               |       |                   || ln    |             建立软链接 |                                               |       |                   || more  |        分页显示文本文件内容 |                                               |       |                   || head  |          显示文件开头内容 |                                               |       |                   || tail  |          显示文件结尾内容 |                                               |       |                   ||       |                   |                                               |    -f | 跟踪输出              |  后台守护运行nohup java -jar -Xms512m -Xmx512m -Xmn128m -Dspring.config.location=./application.yml /usr/local/webapp/webapp-0.0.1-SNAPSHOT.jar &gt;./start.log &amp;查看进程ps -ef|grep name检查端口是否被占用lsof -i:8080查看日志tail -f log.out设置 Root 账户密码sudo passwd root设置允许远程登录 Rootvi /etc/ssh/sshd_config# Authentication:LoginGraceTime 120#PermitRootLogin without-password     //注释此行PermitRootLogin yes                             //加入此行StrictModes yes重启服务service ssh restart修改 Hostname# 使用 hostnamectl 命令修改，其中 tboss 为新的主机名hostnamectl set-hostname tboss关闭交换空间sudo swapoff -a避免开机启动交换空间：#注释 /etc/fstab 中的 swap关闭防火墙ufw disable编辑数据源vi /etc/apt/sources.list//删除全部内容并修改为deb http://mirrors.aliyun.com/ubuntu/ xenial main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ xenial-backports main restricted universe multiverseLinux 编辑器vim运行模式编辑模式：等待编辑命令输入插入模式：编辑模式下，输入 i 进入插入模式，插入文本信息命令模式：在编辑模式下，输入 : 进行命令模式命令:q 直接退出vi:wq 保存后退出vi ，并可以新建文件:q! 强制退出:w file 将当前内容保存成某个文件:set number 在编辑文件显示行号:set nonumber\t在编辑文件不显示行号nanonano 是一个字符终端的文本编辑器，有点像 DOS 下的 editor 程序。它比 vi/vim 要简单得多，比较适合 Linux 初学者使用。某些 Linux 发行版的默认编辑器就是 nano。命令  保存：ctrl + o  搜索：ctrl + w  上一页：ctrl + y  下一页：ctrl + v  退出：ctrl + xlinux命令快捷查询      https://www.macrozheng.com/mall/reference/linux_command.html#%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%AE%89%E8%A3%85%E4%B8%8E%E7%AE%A1%E7%90%86    https://wangchujiang.com/linux-command/  Linux防火墙Firewall和Iptables的使用  https://www.macrozheng.com/mall/reference/linux_firewall.html#firewall"
},

{
"title": "压测工具JMeter简介与使用",
"url": "/posts/%E5%8E%8B%E6%B5%8B%E5%B7%A5%E5%85%B7JMeter%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/",
"categories": "各种使用指南",
"tags": "JMeter, 压力测试",
"date": "2018-04-08 10:39:06 +0800",







"snippet": "下载安装使用JMeter之前，先安装JAVA环境。  https://jmeter.apache.org解压运行解压下载的安装包，到bin目录下运行ApacheJMeter.jar。切换语言：【Options】-&gt;【Choose Language】变更为简体中文测试  右击测试计划&gt;添加&gt;线程用户Threads（Users）&gt;线程组。  线程数：这里就是指虚拟用户数，...",
"content": "下载安装使用JMeter之前，先安装JAVA环境。  https://jmeter.apache.org解压运行解压下载的安装包，到bin目录下运行ApacheJMeter.jar。切换语言：【Options】-&gt;【Choose Language】变更为简体中文测试  右击测试计划&gt;添加&gt;线程用户Threads（Users）&gt;线程组。  线程数：这里就是指虚拟用户数，默认的输入是1，则表明模拟一个虚拟用户访问被测系统，如果想模拟100个用户，则此处输入100。  Ramp-Up Period (in seconds): 虚拟用户增长时长。不明白别着急，xmeter君给你举个栗子：比如你测试的是一个考勤系统，那么实际用户登录使用考勤系统的时候并不是大家喊1、2、3 - 走起，然后一起登录。实际使用场景可能是9点钟上班，那么从8:30开始，考勤系统会陆陆续续有人开始登录，直到9:10左右，那么如果完全按照用户的使用场景，设计该测试的时候此处应输入40（分钟）* 60（秒）= 2400。但是实际测试一般不会设置如此长的Ramp-Up时间，原因嘛，难道你做一次测试要先等上40分钟做登录操作？一般情况下，可以估计出登录频率最高的时间长度，比如此处可能从8:55到9:00登录的人最多，那这里设置成300秒，如果“线程数”输入为100，则意味着在5分钟内100用户登录完毕。  循环次数：该处设置一个虚拟用户做多少次的测试。默认为1，意味着一个虚拟用户做完一遍事情之后，该虚拟用户停止运行。如果选中“永远”，则意味着测试运行起来之后就根本停不下来了，除非你把它强制咔嚓。  接下来的一步就是要加入实际被测页面，右击线程组 &gt; 添加 &gt; 取样器Sampler &gt; HTTP请求。  右击线程组 &gt; 监听器 &gt; 察看结果树来查看性能测试过程中请求和响应信息。  右击线程组 &gt; 监听器 &gt; 汇总报告来查看性能测试汇总信息。参考文章  https://zhuanlan.zhihu.com/p/28319871"
},

{
"title": "Maven简介与使用",
"url": "/posts/Maven%E7%AE%80%E4%BB%8B%E4%B8%8E%E4%BD%BF%E7%94%A8/",
"categories": "各种使用指南",
"tags": "Maven常用命令, Maven",
"date": "2018-04-07 10:39:06 +0800",







"snippet": "概述  Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。  在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置...",
"content": "概述  Maven 是一个项目管理和综合工具。Maven 提供了开发人员构建一个完整的生命周期框架。开发团队可以自动完成项目的基础工具建设，Maven 使用标准的目录结构和默认构建生命周期。  在多个开发团队环境时，Maven 可以设置按标准在非常短的时间里完成配置工作。由于大部分项目的设置都很简单，并且可重复使用，Maven 让开发人员的工作更轻松，同时创建报表，检查，构建和测试自动化设置。功能  Builds-构建  Documentation-文档生成  Reporting-报告  Dependencies-依赖  SCMs-SCMs  Releases-发布  Distribution-分发  mailing list-邮件列表Maven 下载安装::: tip 提示确保已安装 JDK，并设置 JAVA_HOME 环境变量到 Windows 环境变量。:::      下载        添加 MAVEN_HOME 环境变量到 Windows 环境变量，并将其指向你的 Maven 文件夹。        添加到环境变量 - PATH        验证：使用命令：mvn -version  Maven 本地仓库配置文件路径为：{MAVEN_HOME}\\conf\\setting.xml, 更新文件中的&lt;localRepository&gt;D:/apache-maven-3.6.1/repo&lt;/localRepository&gt;。新的 Maven 本地存储库现在为 D:/apache-maven-3.6.1/repoMaven 中央仓库当你建立一个 Maven 的项目，Maven 会检查你的 pom.xml 文件，以确定哪些依赖下载。首先，Maven 将从本地资源库获得 Maven 的本地资源库依赖资源，如果没有找到，然后把它会从默认的 Maven 中央存储库 http://repo1.maven.org/maven2/ 查找下载。修改{MAVEN_HOME}\\conf\\setting.xml文件中mirror为阿里云的配置 &lt;mirror&gt;      &lt;id&gt;nexu-aliyun&lt;/id&gt;      &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;      &lt;name&gt;Nexus aliyun&lt;/name&gt;      &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public&lt;/url&gt;    &lt;/mirror&gt;Maven 常用命令      清理项目 mvn clean        编译源代码 mvn compile        打包 mvn package        打包跳过测试 mvn package -dmaven.test.skip=true        安装到本地仓库 mvn install 或 mvn clean install         源码打包 mvn source:jar      或      mvn source:jar-no-fork        安装外部jar到本地仓库 mvn install:install-file -Dfile=D:/bigdata_repository/Jar/jpinyin-1.1.8.jar -DgroupId=com.github.stuxuhai -DartifactId=jpinyin -Dversion=1.1.8 -Dpackaging=jar或者``` xml       ldapjdk     ldapjdk     system     1.0     ${basedir}\\src\\lib\\jpinyin-1.1.8.jar```"
},

{
"title": "IDEA使用指南",
"url": "/posts/IDEA%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",
"categories": "各种使用指南",
"tags": "IDEA使用指南, IDEA",
"date": "2018-04-06 10:39:06 +0800",







"snippet": "概述  IDEA 全称 IntelliJ IDEA，是 Java 语言开发的集成环境，IntelliJ 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、各类版本工具(git、svn、github 等)、JUnit、CVS 整合、代码分析、 创新的 GUI 设计等方面的功能可以说是超常的。IDEA 是 JetBrains 公司的产品，这家公...",
"content": "概述  IDEA 全称 IntelliJ IDEA，是 Java 语言开发的集成环境，IntelliJ 在业界被公认为最好的 Java 开发工具之一，尤其在智能代码助手、代码自动提示、重构、J2EE 支持、各类版本工具(git、svn、github 等)、JUnit、CVS 整合、代码分析、 创新的 GUI 设计等方面的功能可以说是超常的。IDEA 是 JetBrains 公司的产品，这家公司总部位于捷克共和国的首都布拉格，开发人员以严谨著称的东欧程序员为主。它的旗舰版本还支持 HTML，CSS，PHP，MySQL，Python 等。免费版只支持 Java 等少数语言。特色功能  智能的选取：在很多时候我们要选取某个方法，或某个循环或想一步一步从一个变量到整个类慢慢扩充着选取，IDEA就提供这种基于语法的选择，在默认设置中 Ctrl + W，可以实现选取范围的不断扩充，这种方式在重构的时候尤其显得方便。  丰富的导航模式：IDEA 提供了丰富的导航查看模式，例如 Ctrl + E 显示最近打开过的文件，Ctrl + N 显示你希望显示的类名查找框（该框同样有智能补充功能，当你输入字母后IDEA将显示所有候选类名）。在最基本的 Project 视图中，你还可以选择多种的视图方式。  历史记录功能：不用通过版本管理服务器，单纯的 IDEA 就可以查看任何工程中文件的历史记录，在版本恢复时你可以很容易的将其恢复。  JUnit 的完美支持  对重构的优越支持：IDEA 是所有 IDE 中最早支持重构的，其优秀的重构能力一直是其主要卖点之一。  编码辅助：Java 规范中提倡的 toString()、hashCode()、equals() 以及所有的 get/set 方法，你可以不用进行任何的输入就可以实现代码的自动生成，从而把你从无聊的基本方法编码中解放出来。  灵活的排版功能：基本所有的 IDE 都有重排版功能，但仅有 IDEA 的是人性的，因为它支持排版模式的定制，你可以根据不同的项目要求采用不同的排版方式。  XML 的完美支持：XML 全提示支持：所有流行框架的 XML 文件都支持全提示，谁用谁知道。  动态语法检测：任何不符合 Java 规范、自己预定义的规范、累赘都将在页面中加亮显示。  代码检查：对代码进行自动分析，检测不符合规范的，存在风险的代码，并加亮显示。  对 JSP 的完全支持：不需要任何的插件，完全支持 JSP。  智能编辑：代码输入过程中，自动补充方法或类。  EJB 支持：不需要任何插件完全支持 EJB(6.0 支持 EJB 3.0)  列编辑模式：用过 UtralEdit 的肯定对其的列编辑模式赞赏不已，因为它减少了很多无聊的重复工作，而 IDEA 完全支持该模式，从而更加提高了编码效率。  预置模板：预置模板可以让你把经常用到的方法编辑进模板，使用时你只用输入简单的几个字母就可以完成全部代码的编写。例如使用比较高的 public static void main(String[] args){} 你可以在模板中预设 pm 为该方法，输入时你只要输入 pm 再按代码辅助键，IDEA 将完成代码的自动输入。  完美的自动代码完成：智能检查类中的方法，当发现方法名只有一个时自动完成代码输入，从而减少剩下代码的编写工作。  版本控制完美支持：集成了目前市面上常见的所有版本控制工具插件，包括 git、svn、github，让开发人员在编程的工程中直接在 Intellij IDEA 里就能完成代码的提交、检出、解决冲突、查看版本控制服务器内容等等。  不使用代码的检查：自动检查代码中不使用的代码，并给出提示，从而使代码更高效。  智能代码：自动检查代码，发现与预置规范有出入的代码给出提示，若程序员同意修改自动完成修改。例如代码：String str = “Hello Intellij “ + “IDEA”; IDEA 将给出优化提示，若程序员同意修改 IDEA 将自动将代码修改为：String str = “Hello Intellij IDEA”;  正则表达式的查找和替换功能：查找和替换支持正则表达式，从而提高效率。  JavaDoc 预览支持：支持 JavaDoc 的预览功能，在 JavaDoc 代码中 Ctrl + Q 显示 JavaDoc 的结果，从而提高 DOC 文档的质量。  程序员意图支持：程序员编码时 IDEA 时时检测你的意图，或提供建议，或直接帮你完成代码。系统要求  JDK 版本：Oracle JDK 1.6 或以上  内存：最低要求 1 GB，推荐 2 GB 以上  硬盘：最低要求 2 GB  显示器：最低要求 1024 X 768 分辨率下载地址基础教程基础教程及使用技巧 -&gt; 菜鸟教程idea快捷键大全  Ctrl            快捷键      介绍                  Ctrl + F      在当前文件进行文本查找 （必备）              Ctrl + R      在当前文件进行文本替换 （必备）              Ctrl + Z      撤销 （必备）              Ctrl + Y      删除光标所在行 或 删除选中的行 （必备）              Ctrl + X      剪切光标所在行 或 剪切选择内容              Ctrl + C      复制光标所在行 或 复制选择内容              Ctrl + D      复制光标所在行 或 复制选择内容，并把复制内容插入光标位置下面 （必备）              Ctrl + W      递进式选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展选中范围 （必备）              Ctrl + E      显示最近打开的文件记录列表              Ctrl + N      根据输入的 类名 查找类文件              Ctrl + G      在当前文件跳转到指定行处              Ctrl + J      插入自定义动态代码模板              Ctrl + P      方法参数提示显示              Ctrl + Q      光标所在的变量 / 类名 / 方法名等上面（也可以在提示补充的时候按），显示文档内容              Ctrl + U      前往当前光标所在的方法的父类的方法 / 接口定义              Ctrl + B      进入光标所在的方法/变量的接口或是定义出，等效于 Ctrl + 左键单击              Ctrl + K      版本控制提交项目，需要此项目有加入到版本控制才可用              Ctrl + T      版本控制更新项目，需要此项目有加入到版本控制才可用              Ctrl + H      显示当前类的层次结构              Ctrl + O      选择可重写的方法              Ctrl + I      选择可继承的方法              Ctrl + +      展开代码              Ctrl + -      折叠代码              Ctrl + /      注释光标所在行代码，会根据当前不同文件类型使用不同的注释符号 （必备）              Ctrl + [      移动光标到当前所在代码的花括号开始位置              Ctrl + ]      移动光标到当前所在代码的花括号结束位置              Ctrl + F1      在光标所在的错误代码出显示错误信息              Ctrl + F3      调转到所选中的词的下一个引用位置              Ctrl + F4      关闭当前编辑文件              Ctrl + F8      在 Debug 模式下，设置光标当前行为断点，如果当前已经是断点则去掉断点              Ctrl + F9      执行 Make Project 操作              Ctrl + F11      选中文件 / 文件夹，使用助记符设定 / 取消书签              Ctrl + F12      弹出当前文件结构层，可以在弹出的层上直接输入，进行筛选              Ctrl + Tab      编辑窗口切换，如果在切换的过程又加按上delete，则是关闭对应选中的窗口              Ctrl + Enter      智能分隔行              Ctrl + End      跳到文件尾              Ctrl + Home      跳到文件头              Ctrl + Space      基础代码补全，默认在 Windows 系统上被输入法占用，需要进行修改，建议修改为 Ctrl + 逗号 （必备）              Ctrl + Delete      删除光标后面的单词或是中文句              Ctrl + BackSpace      删除光标前面的单词或是中文句              Ctrl + 1,2,3…9      定位到对应数值的书签位置              Ctrl + 左键单击      在打开的文件标题上，弹出该文件路径              Ctrl + 光标定位      按 Ctrl 不要松开，会显示光标所在的类信息摘要              Ctrl + 左方向键      光标跳转到当前单词 / 中文句的左侧开头位置              Ctrl + 右方向键      光标跳转到当前单词 / 中文句的右侧开头位置              Ctrl + 前方向键      等效于鼠标滚轮向前效果              Ctrl + 后方向键      等效于鼠标滚轮向后效果        Alt            快捷键      介绍                  Alt + `      显示版本控制常用操作菜单弹出层              Alt + Q      弹出一个提示，显示当前类的声明 / 上下文信息              Alt + F1      显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择              Alt + F2      对于前面页面，显示各类浏览器打开目标选择弹出层              Alt + F3      选中文本，逐个往下查找相同文本，并高亮显示              Alt + F7      查找光标所在的方法 / 变量 / 类被调用的地方              Alt + F8      在 Debug 的状态下，选中对象，弹出可输入计算表达式调试框，查看该输入内容的调试结果              Alt + Home      定位 / 显示到当前文件的 Navigation Bar              Alt + Enter      IntelliJ IDEA 根据光标所在问题，提供快速修复选择，光标放在的位置不同提示的结果也不同 （必备）              Alt + Insert      代码自动生成，如生成对象的 set / get 方法，构造函数，toString() 等              Alt + 左方向键      按左方向切换当前已打开的文件视图              Alt + 右方向键      按右方向切换当前已打开的文件视图              Alt + 前方向键      当前光标跳转到当前文件的前一个方法名位置              Alt + 后方向键      当前光标跳转到当前文件的后一个方法名位置              Alt + 1,2,3…9      显示对应数值的选项卡，其中 1 是 Project 用得最多        Shift            快捷键      介绍                  Shift + F1      如果有外部文档可以连接外部文档              Shift + F2      跳转到上一个高亮错误 或 警告位置              Shift + F3      在查找模式下，查找匹配上一个              Shift + F4      对当前打开的文件，使用新Windows窗口打开，旧窗口保留              Shift + F6      对文件 / 文件夹 重命名              Shift + F7      在 Debug 模式下，智能步入。断点所在行上有多个方法调用，会弹出进入哪个方法              Shift + F8      在 Debug 模式下，跳出，表现出来的效果跟 F9 一样              Shift + F9      等效于点击工具栏的 Debug 按钮              Shift + F10      等效于点击工具栏的 Run 按钮              Shift + F11      弹出书签显示层              Shift + Tab      取消缩进              Shift + ESC      隐藏当前 或 最后一个激活的工具窗口              Shift + End      选中光标到当前行尾位置              Shift + Home      选中光标到当前行头位置              Shift + Enter      开始新一行。光标所在行下空出一行，光标定位到新行位置              Shift + 左键单击      在打开的文件名上按此快捷键，可以关闭当前打开文件              Shift + 滚轮前后滚动      当前文件的横向滚动轴滚动        Ctrl + Alt            快捷键      介绍                  Ctrl + Alt + L      格式化代码，可以对当前文件和整个包目录使用 （必备）              Ctrl + Alt + O      优化导入的类，可以对当前文件和整个包目录使用 （必备）              Ctrl + Alt + I      光标所在行 或 选中部分进行自动代码缩进，有点类似格式化              Ctrl + Alt + T      对选中的代码弹出环绕选项弹出层              Ctrl + Alt + J      弹出模板选择窗口，讲选定的代码加入动态模板中              Ctrl + Alt + H      调用层次              Ctrl + Alt + B      在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口              Ctrl + Alt + V      快速引进变量              Ctrl + Alt + Y      同步、刷新              Ctrl + Alt + S      打开 IntelliJ IDEA 系统设置              Ctrl + Alt + F7      显示使用的地方。寻找被该类或是变量被调用的地方，用弹出框的方式找出来              Ctrl + Alt + F11      切换全屏模式              Ctrl + Alt + Enter      光标所在行上空出一行，光标定位到新行              Ctrl + Alt + Home      弹出跟当前文件有关联的文件弹出层              Ctrl + Alt + Space      类名自动完成              Ctrl + Alt + 左方向键      退回到上一个操作的地方 （必备）              Ctrl + Alt + 右方向键      前进到上一个操作的地方 （必备）              Ctrl + Alt + 前方向键      在查找模式下，跳到上个查找的文件              Ctrl + Alt + 后方向键      在查找模式下，跳到下个查找的文件        Ctrl + Shift            快捷键      介绍                  Ctrl + Shift + F      根据输入内容查找整个项目 或 指定目录内文件 （必备）              Ctrl + Shift + R      根据输入内容替换对应内容，范围为整个项目 或 指定目录内文件 （必备）              Ctrl + Shift + J      自动将下一行合并到当前行末尾 （必备）              Ctrl + Shift + Z      取消撤销 （必备）              Ctrl + Shift + W      递进式取消选择代码块。可选中光标所在的单词或段落，连续按会在原有选中的基础上再扩展取消选中范围 （必备）              Ctrl + Shift + N      通过文件名定位 / 打开文件 / 目录，打开目录需要在输入的内容后面多加一个正斜杠 （必备）              Ctrl + Shift + U      对选中的代码进行大 / 小写轮流转换 （必备）              Ctrl + Shift + T      对当前类生成单元测试类，如果已经存在的单元测试类则可以进行选择              Ctrl + Shift + C      复制当前文件磁盘路径到剪贴板              Ctrl + Shift + V      弹出缓存的最近拷贝的内容管理器弹出层              Ctrl + Shift + E      显示最近修改的文件列表的弹出层              Ctrl + Shift + H      显示方法层次结构              Ctrl + Shift + B      跳转到类型声明处              Ctrl + Shift + I      快速查看光标所在的方法 或 类的定义              Ctrl + Shift + A      查找动作 / 设置              Ctrl + Shift + /      代码块注释 （必备）              Ctrl + Shift + [      选中从光标所在位置到它的顶部中括号位置              Ctrl + Shift + ]      选中从光标所在位置到它的底部中括号位置              Ctrl + Shift + +      展开所有代码              Ctrl + Shift + -      折叠所有代码              Ctrl + Shift + F7      高亮显示所有该选中文本，按Esc高亮消失              Ctrl + Shift + F8      在 Debug 模式下，指定断点进入条件              Ctrl + Shift + F9      编译选中的文件 / 包 / Module              Ctrl + Shift + F12      编辑器最大化              Ctrl + Shift + Space      智能代码提示              Ctrl + Shift + Enter      自动结束代码，行末自动添加分号 （必备）              Ctrl + Shift + Backspace      退回到上次修改的地方              Ctrl + Shift + 1,2,3…9      快速添加指定数值的书签              Ctrl + Shift + 左方向键      在代码文件上，光标跳转到当前单词 / 中文句的左侧开头位置，同时选中该单词 / 中文句              Ctrl + Shift + 右方向键      在代码文件上，光标跳转到当前单词 / 中文句的右侧开头位置，同时选中该单词 / 中文句              Ctrl + Shift + 左方向键      在光标焦点是在工具选项卡上，缩小选项卡区域              Ctrl + Shift + 右方向键      在光标焦点是在工具选项卡上，扩大选项卡区域              Ctrl + Shift + 前方向键      光标放在方法名上，将方法移动到上一个方法前面，调整方法排序              Ctrl + Shift + 后方向键      光标放在方法名上，将方法移动到下一个方法前面，调整方法排序        Alt + Shift            快捷键      介绍                  Alt + Shift + N      选择 / 添加 task              Alt + Shift + F      显示添加到收藏夹弹出层              Alt + Shift + C      查看最近操作项目的变化情况列表              Alt + Shift + F      添加到收藏夹              Alt + Shift + I      查看项目当前文件              Alt + Shift + F7      在 Debug 模式下，下一步，进入当前方法体内，如果方法体还有方法，则会进入该内嵌的方法中，依此循环进入              Alt + Shift + F9      弹出 Debug 的可选择菜单              Alt + Shift + F10      弹出 Run 的可选择菜单              Alt + Shift + 左键双击      选择被双击的单词 / 中文句，按住不放，可以同时选择其他单词 / 中文句              Alt + Shift + 前方向键      移动光标所在行向上移动              Alt + Shift + 后方向键      移动光标所在行向下移动        Ctrl + Shift + Alt            快捷键      介绍                  Ctrl + Shift + Alt + V      无格式黏贴              Ctrl + Shift + Alt + N      前往指定的变量 / 方法              Ctrl + Shift + Alt + S      打开当前项目设置              Ctrl + Shift + Alt + C      复制参考信息        其他            快捷键      介绍                  F2      跳转到下一个高亮错误 或 警告位置 （必备）              F3      在查找模式下，定位到下一个匹配处              F4      编辑源              F7      在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中              F8      在 Debug 模式下，进入下一步，如果当前行断点是一个方法，则不进入当前方法体内              F9      在 Debug 模式下，恢复程序运行，但是如果该断点下面代码还有断点则停在下一个断点上              F11      添加书签              F12      回到前一个工具窗口              Tab      缩进              ESC      从工具窗口进入代码文件窗口              连按两次Shift      弹出 Search Everywhere 弹出层      "
},

{
"title": "markdown使用指南",
"url": "/posts/markdown%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/",
"categories": "各种使用指南",
"tags": "markdown, markdown语法, markdown使用",
"date": "2018-04-05 10:39:06 +0800",







"snippet": "markdown语法目录生成[toc]标题# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题段落   两个以上空格加上回车图片![alt](http://img.jpg \"title\")alt图片下面的文字，图片内容的解释。title图片的标题，鼠标移到图片上时显示。超链接[百度](https://baidu.com)示例：唐悦玮字体**加粗...",
"content": "markdown语法目录生成[toc]标题# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题段落   两个以上空格加上回车图片![alt](http://img.jpg \"title\")alt图片下面的文字，图片内容的解释。title图片的标题，鼠标移到图片上时显示。超链接[百度](https://baidu.com)示例：唐悦玮字体**加粗**  或&lt;b&gt;&lt;/b&gt;包围*倾斜****斜体加粗***~~删除线~~加粗倾斜斜体加粗删除线引用&gt;引用的内容&gt;&gt;引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;引用的内容  引用的内容      引用的内容                                                                                                            引用的内容                                                                                          无序列表  无序列表``` markdown          列表      列表      列表  tips：- + * 跟内容后面有空格```        列表  列表  列表有序列表    1. 列表内容        - 111        - 111    2. 列表内容        1. 222        2. 222    3. 列表内容        - 333            1. 333            2. 333        - 444            - 444            - 444    tips：序号跟内容后面有空格  列表内容          111      111        列表内容  222  222  列表内容          333              333      333     - 444                  444          444                    表格  表头|表头|表头  ---|:---:|---:  内容|内容|内容  文字默认居左  两边加：文字居中  右边加：文字居右  tips：原生语法两边都用 |            名称      性别      技能                  tyw      男      全栈      代码    `单行代码`    (```)      代码块...    (```)    或者    ```    代码块...    ```分割线    ---    ----    ***    *****提示    ::: tip 提示    this is a tip    :::    ::: warning 注意    this is a tip    :::    ::: danger 警告    this is a tip    :::::: tip 提示提示 tip:::::: warning 注意注意 tip:::::: danger 警告警告 tip:::"
},

{
"title": "开发常用工具类",
"url": "/posts/%E5%BC%80%E5%8F%91%E5%B8%B8%E7%94%A8%E5%B7%A5%E5%85%B7%E7%B1%BB/",
"categories": "开发常用工具类",
"tags": "guava, JSON",
"date": "2018-03-03 10:39:06 +0800",







"snippet": "开发常用工具类Google guavaguava的优点  高效设计良好的API，被Google的开发者设计，实现和使用  遵循高效的java语法实践  使代码更刻度，简洁，简单  节约时间，资源，提高生产力    guava的核心库    集合 [collections]  缓存 [caching]  原生类型支持 [primitives support]  并发库 [concurrency...",
"content": "开发常用工具类Google guavaguava的优点  高效设计良好的API，被Google的开发者设计，实现和使用  遵循高效的java语法实践  使代码更刻度，简洁，简单  节约时间，资源，提高生产力    guava的核心库    集合 [collections]  缓存 [caching]  原生类型支持 [primitives support]  并发库 [concurrency libraries]  通用注解 [common annotations]  字符串处理 [string processing]  I/O 等等。maven引入&lt;dependency&gt;    &lt;groupId&gt;com.google.guava&lt;/groupId&gt;    &lt;artifactId&gt;guava&lt;/artifactId&gt;    &lt;version&gt;23.0&lt;/version&gt;&lt;/dependency&gt;基本工具[Basic utilities]集合[Collections]MultiMapMultiSet统计一个词在文档中出现了多少次，传统的做法是这样的：Map&lt;String, Integer&gt; counts = new HashMap&lt;String, Integer&gt;();for (String word : words) {    Integer count = counts.get(word);    if (count == null) {        counts.put(word, 1);    } else {        counts.put(word, count + 1);    }}Multiset.addAll(Collection)可以添加Collection中的所有元素并进行计数Table当你想使用多个键做索引的时候，你可能会用类似Map&lt;FirstName, Map&lt;LastName, Person»的实现，这种方式很丑陋，使用上也不友好。Guava为此提供了新集合类型Table，它有两个支持所有类型的键：”行”和”列”。Table提供多种视图，以便你从各种角度使用它：  rowMap()：用Map&lt;R, Map&lt;C, V»表现Table&lt;R, C, V&gt;。同样的， rowKeySet()返回”行”的集合Set。  row(r) ：用Map&lt;C, V&gt;返回给定”行”的所有列，对这个map进行的写操作也将写入Table中。  类似的列访问方法：columnMap()、columnKeySet()、column(c)。（基于列的访问会比基于的行访问稍微低效点）  cellSet()：用元素类型为Table.Cell&lt;R, C, V&gt;的Set表现Table&lt;R, C, V&gt;。Cell类似于Map.Entry，但它是用行和列两个键区分的。Table有如下几种实现：  HashBasedTable：本质上用HashMap&lt;R, HashMap&lt;C, V»实现；  TreeBasedTable：本质上用TreeMap&lt;R, TreeMap&lt;C,V»实现；  ImmutableTable：本质上用ImmutableMap&lt;R, ImmutableMap&lt;C, V»实现；注：ImmutableTable对稀疏或密集的数据集都有优化。  ArrayTable：要求在构造时就指定行和列的大小，本质上由一个二维数组实现，以提升访问速度和密集Table的内存利用率。ArrayTable与其他Table的工作原理有点不同，请参见Javadoc了解详情。BiMap  要实现键值对的双向映射需要维护两个单独的map，并保持它们间的同步。例如：Map&lt;String, Integer&gt; nameAndId = Maps.newHashMap();Map&lt;Integer, String&gt; idAndName = Maps.newHashMap();nameAndId.put(\"Bob\", 42);idAndName.put(42, \"Bob\");这种方式容易出错，而且对于值已经在map中的情况，会变得非常混乱。在BiMap中可以这样：BiMap&lt;String, Integer&gt; userId = HashBiMap.create();...String userForId = userId.inverse().get(id);ClassToInstanceMapClassToInstanceMap是一种特殊的Map：它的键是类型，而值是符合键所指类型的对象。为了扩展Map接口，ClassToInstanceMap额外声明了两个方法：T getInstance(Class) 和T putInstance(Class, T)，从而避免强制类型转换，同时保证了类型安全。ClassToInstanceMap有唯一的泛型参数，通常称为B，代表Map支持的所有类型的上界。例如：ClassToInstanceMap&lt;Number&gt; numberDefaults=MutableClassToInstanceMap.create();numberDefaults.putInstance(Integer.class, Integer.valueOf(0));从技术上讲，ClassToInstanceMap实现了Map&lt;Class&lt;? extends B&gt;, B&gt;——或者说，是一个映射B的子类型到对应实例的Map。这让ClassToInstanceMap包含的泛型声明有点令人困惑，但B始终是Map所支持类型的上界——通常B就是Object。对于ClassToInstanceMap，Guava提供了两种有用的实现：MutableClassToInstanceMap和 ImmutableClassToInstanceMap。Apache common Lang/BeanUtilsapache common Langapache提供的众多commons工具包，号称Java第二API，而common里面lang3包更是被我们使用得最多的。使用apache common LangHutool                                      模块      介绍              hutool-aop\tJ      DK动态代理封装，提供非IOC下的切面支持              hutool-bloomFilter      布隆过滤，提供一些Hash算法的布隆过滤              hutool-cache      简单缓存实现              hutool-core      核心，包括Bean操作、日期、各种Util等              hutool-cron      定时任务模块，提供类Crontab表达式的定时任务              hutool-crypto      加密解密模块，提供对称、非对称和摘要算法封装              hutool-db      JDBC封装后的数据操作，基于ActiveRecord思想              hutool-dfa      基于DFA模型的多关键字查找              hutool-extra      扩展模块，对第三方封装（模板引擎、邮件、Servlet、二维码、Emoji、FTP、分词等）              hutool-http      基于HttpUrlConnection的Http客户端封装              hutool-log      自动识别日志实现的日志门面              hutool-script      脚本执行封装，例如Javascript              hutool-setting      功能更强大的Setting配置文件和Properties封装              hutool-system      系统参数调用封装（JVM信息等）              hutool-json      JSON实现              hutool-captcha      图片验证码实现              hutool-poi      针对POI中Excel和Word的封装              hutool-socket      基于Java的NIO和AIO的Socket封装              hutool-jwt      JSON Web Token (JWT)封装实现        使用Hutoolfastjson在日志解析,前后端数据传输交互中,经常会遇到字符串(String)与json,XML等格式相互转换与解析，其中json以跨语言，跨前后端的优点在开发中被频繁使用，基本上可以说是标准的数据交换格式。fastjson是一个java语言编写的高性能且功能完善的JSON库，它采用一种“假定有序快速匹配”的算法，把JSON Parse 的性能提升到了极致。它的接口简单易用，已经被广泛使用在缓存序列化，协议交互，Web输出等各种应用场景中。 JSON.parseObject(jsonStr, Model.class); JSON.parseArray(jsonStr, Model.class);gsonGSON是Google提供的用来在Java对象和JSON数据之间进行映射的Java类库。可以将一个Json字符转成一个Java对象，或者将一个Java转化为Json字符串。特点：  快速、高效  代码量少、简洁  面向对象  数据传递和解析方便&lt;dependency&gt;    &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt;    &lt;artifactId&gt;gson&lt;/artifactId&gt;    &lt;version&gt;2.8.0&lt;/version&gt;&lt;/dependency&gt;Gson gson = new gson();"
},

{
"title": "前端 JS 项目开发规范",
"url": "/posts/%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/",
"categories": "前端",
"tags": "前端, 项目开发规范",
"date": "2018-01-01 10:39:06 +0800",







"snippet": "前端 JS 项目开发规范  现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌...",
"content": "前端 JS 项目开发规范  现代软件架构的复杂性需要协同开发完成，如何高效地协同呢？无规矩不成方圆，无规范难以协同，比如，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全，试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率，降低沟通成本。代码的字里行间流淌的是软件系统的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升系统稳定性，码出质量。一、编程规约(一)命名规范1.1.1 项目命名全部采用小写方式， 以中划线分隔。正例：mall-management-system反例：mall_management-system / mallManagementSystem1.1.2 目录命名全部采用小写方式， 以中划线分隔，有复数结构时，要采用复数命名法， 缩写不用复数正例： scripts / styles / components / images / utils / layouts / demo-styles / demo-scripts / img / doc反例： script / style / demo_scripts / demoStyles / imgs / docs【特殊】VUE 的项目中的 components 中的组件目录，使用 kebab-case 命名正例： head-search / page-loading / authorized / notice-icon反例： HeadSearch / PageLoading【特殊】VUE 的项目中的除 components 组件目录外的所有目录也使用 kebab-case 命名正例： page-one / shopping-car / user-management反例： ShoppingCar / UserManagement1.1.3 JS、CSS、SCSS、HTML、PNG 文件命名全部采用小写方式， 以中划线分隔正例： render-dom.js / signup.css / index.html / company-logo.png反例： renderDom.js / UserManagement.html1.1.4 命名严谨性代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用正例：henan / luoyang / rmb 等国际通用的名称，可视同英文。反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3杜绝完全不规范的缩写，避免望文不知义：反例：AbstractClass“缩写”命名成 AbsClass；condition“缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。(二)HTML 规范 （Vue Template 同样适用）1.2.1 HTML 类型推荐使用 HTML5 的文档类型申明： &lt;!DOCTYPE html&gt;.（建议使用 text/html 格式的 HTML。避免使用 XHTML。XHTML 以及它的属性，比如 application/xhtml+xml 在浏览器中的应用支持与优化空间都十分有限）。  规定字符编码  IE 兼容模式  规定字符编码  doctype 大写正例：&lt;!DOCTYPE html&gt;&lt;html&gt;  &lt;head&gt;    &lt;meta http-equiv=\"X-UA-Compatible\" content=\"IE=Edge\" /&gt;    &lt;meta charset=\"UTF-8\" /&gt;    &lt;title&gt;Page title&lt;/title&gt;  &lt;/head&gt;  &lt;body&gt;    &lt;img src=\"images/company-logo.png\" alt=\"Company\" /&gt;  &lt;/body&gt;&lt;/html&gt;1.2.2 缩进缩进使用 2 个空格（一个 tab）嵌套的节点应该缩进。1.2.3 分块注释在每一个块状元素，列表元素和表格元素后，加上一对 HTML 注释。注释格式&lt;!– 英文 中文 start &gt;&lt;!– 英文 中文 end &gt;正例：&lt;body&gt;  &lt;!-- header 头部 start --&gt;  &lt;header&gt;    &lt;div class=\"container\"&gt;      &lt;a href=\"#\"&gt;        &lt;!-- 图片会把a标签给撑开，所以不用设置a标签的大小 --&gt;        &lt;img src=\"images/header.jpg\" /&gt;      &lt;/a&gt;    &lt;/div&gt;  &lt;/header&gt;  &lt;!-- header 头部 end --&gt;&lt;/body&gt;1.2.4 语义化标签HTML5 中新增很多语义化标签，所以优先使用语义化标签，避免一个页面都是 div 或者 p 标签正例&lt;header&gt;&lt;/header&gt;&lt;footer&gt;&lt;/footer&gt;反例&lt;div&gt;  &lt;p&gt;&lt;/p&gt;&lt;/div&gt;1.2.5 引号使用双引号(“ “) 而不是单引号(‘ ‘) 。正例： &lt;div class=\"news-div\"&gt;&lt;/div&gt;反例： &lt;div class='news-div'&gt;&lt;/div&gt;(三) CSS 规范1.3.1 命名  类名使用小写字母，以中划线分隔  id 采用驼峰式命名  scss 中的变量、函数、混合、placeholder 采用驼峰式命名ID 和 class 的名称总是使用可以反应元素目的和用途的名称，或其他通用的名称，代替表象和晦涩难懂的名称不推荐：.fw-800 {  font-weight: 800;}.red {  color: red;}推荐:.heavy {  font-weight: 800;}.important {  color: red;}1.3.2 选择器1)css 选择器中避免使用标签名从结构、表现、行为分离的原则来看，应该尽量避免 css 中出现 HTML 标签，并且在 css 选择器中出现标签名会存在潜在的问题。2)很多前端开发人员写选择器链的时候不使用 直接子选择器（注：直接子选择器和后代选择器的区别）。有时，这可能会导致疼痛的设计问题并且有时候可能会很耗性能。然而，在任何情况下，这是一个非常不好的做法。如果你不写很通用的，需要匹配到 DOM 末端的选择器， 你应该总是考虑直接子选择器。不推荐:.content .title {  font-size: 2rem;}推荐:.content &gt; .title {  font-size: 2rem;}1.3.3 尽量使用缩写属性不推荐：border-top-style: none;font-family: palatino, georgia, serif;font-size: 100%;line-height: 1.6;padding-bottom: 2em;padding-left: 1em;padding-right: 1em;padding-top: 0;推荐：border-top: 0;font: 100%/1.6 palatino, georgia, serif;padding: 0 1em 2em;1.3.4 每个选择器及属性独占一行不推荐：button{  width:100px;height:50px;color:#fff;background:#00a0e9;}推荐：button{  width:100px;  height:50px;  color:#fff;  background:#00a0e9;}1.3.5 省略0后面的单位不推荐：div{  padding-bottom: 0px;  margin: 0em;}推荐：div{  padding-bottom: 0;  margin: 0;}1.3.6 避免使用ID选择器及全局标签选择器防止污染全局样式不推荐：#header{  padding-bottom: 0px;  margin: 0em;}推荐：.header{  padding-bottom: 0px;  margin: 0em;}(四) LESS 规范1.4.1 代码组织1)将公共less文件放置在style/less/common文件夹例:// color.less,common.less2)按以下顺序组织1、@import;2、变量声明;3、样式声明;@import \"mixins/size.less\";@default-text-color: #333;.page {  width: 960px;  margin: 0 auto;}1.4.2 避免嵌套层级过多将嵌套深度限制在3级。对于超过4级的嵌套，给予重新评估。这可以避免出现过于详实的CSS选择器。避免大量的嵌套规则。当可读性受到影响时，将之打断。推荐避免出现多于20行的嵌套规则出现不推荐：.main{  .title{    .name{       color:#fff    }  }}推荐：.main-title{   .name{      color:#fff   }}(五) Javascript 规范1.5.1 命名1) 采用小写驼峰命名 lowerCamelCase，代码中的命名均不能以下划线，也不能以下划线或美元符号结束反例： _name / name_ / name$2) 方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId**其中 method 方法命名必须是 动词 或者 动词+名词 形式**正例：saveShopCarData /openShopCarInfoDialog反例：save / open / show / go**特此说明，增删查改，详情统一使用如下 5 个单词，不得使用其他（目的是为了统一各个端）**add / update / delete / detail / get附： 函数方法常用的动词:get 获取/set 设置,add 增加/remove 删除create 创建/destory 移除start 启动/stop 停止open 打开/close 关闭,read 读取/write 写入load 载入/save 保存,create 创建/destroy 销毁begin 开始/end 结束,backup 备份/restore 恢复import 导入/export 导出,split 分割/merge 合并inject 注入/extract 提取,attach 附着/detach 脱离bind 绑定/separate 分离,view 查看/browse 浏览edit 编辑/modify 修改,select 选取/mark 标记copy 复制/paste 粘贴,undo 撤销/redo 重做insert 插入/delete 移除,add 加入/append 添加clean 清理/clear 清除,index 索引/sort 排序find 查找/search 搜索,increase 增加/decrease 减少play 播放/pause 暂停,launch 启动/run 运行compile 编译/execute 执行,debug 调试/trace 跟踪observe 观察/listen 监听,build 构建/publish 发布input 输入/output 输出,encode 编码/decode 解码encrypt 加密/decrypt 解密,compress 压缩/decompress 解压缩pack 打包/unpack 解包,parse 解析/emit 生成connect 连接/disconnect 断开,send 发送/receive 接收download 下载/upload 上传,refresh 刷新/synchronize 同步update 更新/revert 复原,lock 锁定/unlock 解锁check out 签出/check in 签入,submit 提交/commit 交付push 推/pull 拉,expand 展开/collapse 折叠begin 起始/end 结束,start 开始/finish 完成enter 进入/exit 退出,abort 放弃/quit 离开obsolete 废弃/depreciate 废旧,collect 收集/aggregate 聚集3) 常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX_STOCK_COUNT反例： MAX_COUNT1.5.2 代码格式1) 使用 2 个空格进行缩进正例：if (x &lt; y) {  x += 10;} else {  x += 1;}2) 不同逻辑、不同语义、不同业务的代码之间插入一个空行分隔开来以提升可读性。  说明：任何情形，没有必要插入多个空行进行隔开。1.5.3 字符串统一使用单引号(‘)，不使用双引号(“)。这在创建 HTML 字符串非常有好处：正例:let str = 'foo';let testDiv = '&lt;div id=\"test\"&gt;&lt;/div&gt;';反例:let str = 'foo';let testDiv = \"&lt;div id='test'&gt;&lt;/div&gt;\";1.5.4 对象声明1)使用字面值创建对象正例： let user = {};反例： let user = new Object();2) 使用字面量来代替对象构造器正例：var user = {  age: 0,  name: 1,  city: 3};反例：var user = new Object();user.age = 0;user.name = 0;user.city = 0;1.5.5 使用 ES6,7必须优先使用 ES6,7 中新增的语法糖和函数。这将简化你的程序，并让你的代码更加灵活和可复用。  必须强制使用 ES6, ES7 的新语法，比如箭头函数、await/async ， 解构， let ， for…of 等等1.5.6 括号下列关键字后必须有大括号（即使代码块的内容只有一行）：if, else, for, while, do, switch, try, catch, finally, with。正例：if (condition) {  doSomething();}反例：if (condition) doSomething();1.5.7 undefined 判断永远不要直接使用 undefined 进行变量判断；使用 typeof 和字符串’undefined’对变量进行判断。正例：if (typeof person === 'undefined') {    ...}反例：if (person === undefined) {    ...}1.5.8 条件判断和循环最多三层条件判断能使用三目运算符和逻辑运算符解决的，就不要使用条件判断，但是谨记不要写太长的三目运算符。如果超过 3 层请抽成函数，并写清楚注释。1.5.9 this 的转换命名对上下文 this 的引用只能使用’self’来命名1.5.10 慎用 console.log因 console.log 大量使用会有性能问题，所以在非 webpack 项目中谨慎使用 log 功能二、Vue 项目规范(一) Vue 编码基础vue 项目规范以 Vue 官方规范 （https://cn.vuejs.org/v2/style-guide/） 中的 A 规范为基础，在其上面进行项目开发，故所有代码均遵守该规范。  请仔仔细细阅读 Vue 官方规范，切记，此为第一步。2.1.1. 组件规范1) 组件名为多个单词。组件名应该始终是多个单词组成（大于等于 2），且命名规范为KebabCase格式。这样做可以避免跟现有的以及未来的 HTML 元素相冲突，因为所有的 HTML 元素名称都是单个单词的。正例：export default {  name: 'TodoItem'  // ...};反例：export default {  name: 'Todo',  // ...}export default {  name: 'todo-item',  // ...}2) 组件文件名为 pascal-case 格式正例：components/|- my-component.vue反例：components/|- myComponent.vue|- MyComponent.vue3) 基础组件文件名为 base 开头，使用完整单词而不是缩写。正例：components/|- base-button.vue|- base-table.vue|- base-icon.vue反例：components/|- MyButton.vue|- VueTable.vue|- Icon.vue4) 和父组件紧密耦合的子组件应该以父组件名作为前缀命名正例：components/|- todo-list.vue|- todo-list-item.vue|- todo-list-item-button.vue|- user-profile-options.vue （完整单词）反例：components/|- TodoList.vue|- TodoItem.vue|- TodoButton.vue|- UProfOpts.vue （使用了缩写）5) 在 Template 模版中使用组件，应使用 PascalCase 模式，并且使用自闭合组件。正例：&lt;!-- 在单文件组件、字符串模板和 JSX 中 --&gt;&lt;MyComponent /&gt;&lt;Row&gt;&lt;table :column=\"data\"/&gt;&lt;/Row&gt;反例：&lt;my-component /&gt; &lt;row&gt;&lt;table :column=\"data\"/&gt;&lt;/row&gt;6) 组件的 data 必须是一个函数当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 因为如果直接是一个对象的话，子组件之间的属性值会互相影响。正例：export default {  data () {    return {       name: 'jack'    }  }}反例：export default {  data: {    name: 'jack'  }}7) Prop 定义应该尽量详细  必须使用 camelCase 驼峰命名  必须指定类型  必须加上注释，表明其含义  必须加上 required 或者 default，两者二选其一  如果有业务需要，必须加上 validator 验证正例： props: {  // 组件状态，用于控制组件的颜色   status: {     type: String,     required: true,     validator: function (value) {       return [         'succ',         'info',         'error'       ].indexOf(value) !== -1     }   },    // 用户级别，用于显示皇冠个数   userLevel：{      type: String,      required: true   }}8) 为组件样式设置作用域正例：&lt;template&gt;  &lt;button class=\"btn btn-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 使用 `scoped` 特性 --&gt;&lt;style scoped&gt;  .btn-close {    background-color: red;  }&lt;/style&gt;反例：&lt;template&gt;  &lt;button class=\"btn btn-close\"&gt;X&lt;/button&gt;&lt;/template&gt;&lt;!-- 没有使用 `scoped` 特性 --&gt;&lt;style&gt;  .btn-close {    background-color: red;  }&lt;/style&gt;9) 如果特性元素较多，应该主动换行。正例：&lt;MyComponent foo=\"a\" bar=\"b\" baz=\"c\"    foo=\"a\" bar=\"b\" baz=\"c\"    foo=\"a\" bar=\"b\" baz=\"c\" /&gt;反例：&lt;MyComponent foo=\"a\" bar=\"b\" baz=\"c\" foo=\"a\" bar=\"b\" baz=\"c\" foo=\"a\" bar=\"b\" baz=\"c\" foo=\"a\" bar=\"b\" baz=\"c\"/&gt;2.1.2. 模板中使用简单的表达式组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。正例：&lt;template&gt;  &lt;p&gt;{{normalizedFullName}}&lt;/p&gt;&lt;/template&gt;&lt;!--// 复杂表达式已经移入一个计算属性--&gt;computed: {  normalizedFullName: function(){    return this.fullName.split('').map(function(word){      return word[0].toUpperCase() + word.slice(1)    }).join('');  }}反例：&lt;template&gt;  &lt;p&gt;    {{    fullName.split('').map(function(word){      return word[0].toUpperCase() + word.slice(1)    }).join('');    }}  &lt;/p&gt;&lt;/template&gt;2.1.3 指令都使用缩写形式指令推荐都使用缩写形式，(用 : 表示 v-bind: 、用 @ 表示 v-on: 和用 # 表示 v-slot:)正例：&lt;input  @input=\"onInput\"  @focus=\"onFocus\"&gt;反例：&lt;input  v-on:input=\"onInput\"  @focus=\"onFocus\"&gt;2.1.4 标签顺序保持一致单文件组件应该总是让标签顺序保持为 &lt;template&gt; 、&lt;script&gt;、 &lt;style&gt;正例：&lt;template&gt;...&lt;/template&gt;&lt;script&gt;...&lt;/script&gt;&lt;style&gt;...&lt;/style&gt;反例：&lt;template&gt;...&lt;/template&gt;&lt;style&gt;...&lt;/style&gt;&lt;script&gt;...&lt;/script&gt;2.1.5 必须为 v-for 设置键值 key2.1.6 v-show 与 v-if 选择如果运行时，需要非常频繁地切换，使用 v-show ；如果在运行时，条件很少改变，使用 v-if。2.1.7 script 标签内部结构顺序components &gt; props &gt; data &gt; computed &gt; watch &gt; filter &gt; 钩子函数（钩子函数按其执行顺序） &gt; methods2.1.8 Vue Router 规范1) 页面跳转数据传递使用路由参数页面跳转，例如 A 页面跳转到 B 页面，需要将 A 页面的数据传递到 B 页面，推荐使用 路由参数进行传参，而不是将需要传递的数据保存 vuex，然后在 B 页面取出 vuex 的数据，因为如果在 B 页面刷新会导致 vuex 数据丢失，导致 B 页面无法正常显示数据。正例：let id = ' 123';this.$router.push({ name: 'userCenter', query: { id: id } });2) 使用路由懒加载（延迟加载）机制    {        path: '/uploadAttachment',        name: 'uploadAttachment',        meta: {          title: '上传附件'        },        component: () =&gt; import('@/view/components/uploadAttachment/index.vue')     }3) router 中的命名规范path、childrenPoints 命名规范采用kebab-case命名规范（尽量vue文件的目录结构保持一致，因为目录、文件名都是kebab-case，这样很方便找到对应的文件）name 命名规范采用KebabCase命名规范且和component组件名保持一致！（因为要保持keep-alive特性，keep-alive按照component的name进行缓存，所以两者必须高度保持一致）// 动态加载export const reload = [  {    path: '/reload',    name: 'reload',    component: Main,    meta: {      title: '动态加载',      icon: 'icon iconfont'    },    children: [      {        path: '/reload/smart-reload-list',        name: 'SmartReloadList',        meta: {          title: 'SmartReload',          childrenPoints: [            {              title: '查询',              name: 'smart-reload-search'            },            {              title: '执行reload',              name: 'smart-reload-update'            },            {              title: '查看执行结果',              name: 'smart-reload-result'            }          ]        },        component: () =&gt;          import('@/views/reload/smart-reload/smart-reload-list.vue')      }    ]  }];4) router 中的 path 命名规范path除了采用kebab-case命名规范以外，必须以 / 开头，即使是children里的path也要以 / 开头。如下示例*目的：经常有这样的场景：某个页面有问题，要立刻找到这个vue文件，如果不用以/开头，path为parent和children组成的，可能经常需要在router文件里搜索多次才能找到，而如果以/开头，则能立刻搜索到对应的组件*{    path: '/file',    name: 'File',    component: Main,    meta: {      title: '文件服务',      icon: 'ios-cloud-upload'    },    children: [      {        path: '/file/file-list',        name: 'FileList',        component: () =&gt; import('@/views/file/file-list.vue')      },      {        path: '/file/file-add',        name: 'FileAdd',        component: () =&gt; import('@/views/file/file-add.vue')      },      {        path: '/file/file-update',        name: 'FileUpdate',        component: () =&gt; import('@/views/file/file-update.vue')      }    ]  }(二) Vue 项目目录规范2.2.1 基础vue 项目中的所有命名一定要与后端命名统一。比如权限：后端 privilege, 前端无论 router , store, api 等都必须使用 privielege 单词！2.2.2 使用 Vue-cli 脚手架使用 vue-cli3 来初始化项目，项目名按照上面的命名规范。2.2.3 目录说明目录名按照上面的命名规范，其中 components 组件用大写驼峰，其余除 components 组件目录外的所有目录均使用 kebab-case 命名。src                               源码目录|-- api                              所有api接口|-- assets                           静态资源，images, icons, styles等|-- components                       公用组件|-- config                           配置信息|-- constants                        常量信息，项目所有Enum, 全局常量等|-- directives                       自定义指令|-- filters                          过滤器，全局工具|-- datas                            模拟数据，临时存放|-- lib                              外部引用的插件存放及修改文件|-- mock                             模拟接口，临时存放|-- plugins                          插件，全局使用|-- router                           路由，统一管理|-- store                            vuex, 统一管理|-- themes                           自定义样式主题|-- views                            视图目录|   |-- role                             role模块名|   |-- |-- role-list.vue                    role列表页面|   |-- |-- role-add.vue                     role新建页面|   |-- |-- role-update.vue                  role更新页面|   |-- |-- index.less                      role模块样式|   |-- |-- components                      role模块通用组件文件夹|   |-- employee                         employee模块1) api 目录  文件、变量命名要与后端保持一致。  此目录对应后端 API 接口，按照后端一个 controller 一个 api js 文件。若项目较大时，可以按照业务划分子目录，并与后端保持一致。  api 中的方法名字要与后端 api url 尽量保持语义高度一致性。  对于 api 中的每个方法要添加注释，注释与后端 swagger 文档保持一致。正例：后端 url： EmployeeController.java/employee/add/employee/delete/{id}/employee/update前端： employee.js  // 添加员工  addEmployee: (data) =&gt; {    return postAxios('/employee/add', data)  },  // 更新员工信息  updateEmployee: (data) =&gt; {    return postAxios('/employee/update', data)  },    // 删除员工  deleteEmployee: (employeeId) =&gt; {    return postAxios('/employee/delete/' + employeeId)   }2) assets 目录assets 为静态资源，里面存放 images, styles, icons 等静态资源，静态资源命名格式为 kebab-case|assets|-- icons|-- images|   |-- background-color.png|   |-- upload-header.png|-- styles3) components 目录此目录应按照组件进行目录划分，目录命名为 KebabCase，组件命名规则也为 KebabCase|components|-- error-log|   |-- index.vue|   |-- index.less|-- markdown-editor|   |-- index.vue|   |-- index.js|-- kebab-case4) constants 目录此目录存放项目所有常量，如果常量在 vue 中使用，请使用 vue-enum 插件(https://www.npmjs.com/package/vue-enum)目录结构：|constants|-- index.js|-- role.js|-- employee.js例子： employee.jsexport const EMPLOYEE_STATUS = {  NORMAL: {    value: 1,    desc: '正常'  },  DISABLED: {    value: 1,    desc: '禁用'  },  DELETED: {    value: 2,    desc: '已删除'  }};export const EMPLOYEE_ACCOUNT_TYPE = {  QQ: {    value: 1,    desc: 'QQ登录'  },  WECHAT: {    value: 2,    desc: '微信登录'  },  DINGDING: {    value: 3,    desc: '钉钉登录'  },  USERNAME: {    value: 4,    desc: '用户名密码登录'  }};export default {  EMPLOYEE_STATUS,  EMPLOYEE_ACCOUNT_TYPE};5) router 与 store 目录这两个目录一定要将业务进行拆分，不能放到一个 js 文件里。router 尽量按照 views 中的结构保持一致store 按照业务进行拆分不同的 js 文件6) views 目录  命名要与后端、router、api 等保持一致  components 中组件要使用 PascalCase 规则|-- views                            视图目录|   |-- role                             role模块名|   |   |-- role-list.vue                    role列表页面|   |   |-- role-add.vue                     role新建页面|   |   |-- role-update.vue                  role更新页面|   |   |-- index.less                      role模块样式|   |   |-- components                      role模块通用组件文件夹|   |   |   |-- role-header.vue                        role头部组件|   |   |   |-- role-modal.vue                         role弹出框组件|   |-- employee                         employee模块|   |-- behavior-log                      行为日志log模块|   |-- code-generator                    代码生成器模块2.2.4 注释说明整理必须加注释的地方  公共组件使用说明  api 目录的接口 js 文件必须加注释  store 中的 state, mutation, action 等必须加注释  vue 文件中的 template 必须加注释，若文件较大添加 start end 注释  vue 文件的 methods，每个 method 必须添加注释  vue 文件的 data, 非常见单词要加注释2.2.5 其他1) 尽量不要手动操作 DOM因使用 vue 框架，所以在项目开发中尽量使用 vue 的数据驱动更新 DOM，尽量（不到万不得已）不要手动操作 DOM，包括：增删改 dom 元素、以及更改样式、添加事件等。2) 删除无用代码因使用了 git/svn 等代码版本工具，对于无用代码必须及时删除，例如：一些调试的 console 语句、无用的弃用功能代码。"
}

]

